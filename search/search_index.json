{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>opensourceleg: An open-source SDK for developing and testing algorithms on commonly used robotic hardware. Originally developed for the Open-Source Leg project, this library provides a comprehensive framework for interfacing with various actuators and sensors in robotic systems. While initially designed for prosthetic leg applications, the <code>opensourceleg</code> library's modular architecture makes it versatile for use with any robotic platform utilizing similar components.</p> <p>Note: Starting from version <code>opensourceleg 3.3.0</code>, only Python 3.11 and above are supported. If you need compatibility with Python 3.9, please install <code>opensourceleg 3.2.1</code>: <pre><code>pip install opensourceleg==3.2.1\n</code></pre></p>"},{"location":"#key-features","title":"\ud83c\udfaf Key Features","text":"<p>This library solves common challenges in developing, testing, and deploying robotic algorithms:</p> Feature Description \ud83d\udce6 Standardized Interfaces Provides consistent interfaces for common actuators and sensors \ud83d\udd04 Ready-to-Use Implementations Offers ready-to-use implementations for popular hardware components \ud83d\udd0d Extensible Architecture Allows for easy integration of custom components \ud83e\uddea Comprehensive Benchmarks Includes comprehensive benchmarks for popular hardware components"},{"location":"#ideal-for-roboticists-who","title":"\ud83d\udc65 Ideal for Roboticists Who","text":"<ul> <li>Want to develop robotic algorithms for the Open-Source Leg platform or any other robotic platform</li> <li>Need a reliable and extensible framework for interfacing with various actuators and sensors</li> <li>Are working on a robotic project and need a flexible and powerful software development kit</li> <li>Are looking for benchmarks to pick the best hardware for their robotic project</li> </ul> \ud83d\udd04 Available Hardware Interfaces  The library currently supports the following hardware components:  | Sensors              | Unit Tests | Hardware Tests | Benchmarks | Documentation | | -------------------- | ---------- | -------------- | ---------- | ------------- | | AS5048B Encoder      |     \u2705    |        \u2705      |     \u274c    |      \u2705      | | Lord Microstrain IMU |     \u2705    |        \u2705      |     \u274c    |      \u2705      | | SRI Loadcell         |     \u2705    |        \u2705      |     \u274c    |      \u2705      |    | Actuators         | Unit Tests | Hardware Tests | Benchmarks | Documentation | | ----------------- | ---------- | -------------- | ---------- | ------------- | | Dephy Actpack     |     \u26a0\ufe0f    |       \u2705       |     \u26a0\ufe0f     |      \u2705      | | Moteus            |     \u26a0\ufe0f    |       \u26a0\ufe0f       |     \u26a0\ufe0f     |      \u2705      | | TMotor            |     \u274c    |       \u26a0\ufe0f       |     \u274c     |      \u274c      |     &gt; Legend: \u2705 Complete/Available; \u26a0\ufe0f Partial/In Progress; \u274c Not Yet Available;  Hardware tests indicate successful testing on physical devices. Benchmarks include performance metrics such as response time and accuracy measurements. Documentation includes API reference and usage examples."},{"location":"#installation","title":"\ud83d\udce6 Installation","text":"<p>The library is available on PyPI and can be installed using pip:</p> <pre><code>pip install opensourceleg\n</code></pre> \ud83d\udd27 Hardware-Specific Dependencies  To keep your installation lightweight, you can install only the dependencies needed for your specific hardware:  <pre><code># For Dephy actuators\npip install opensourceleg[dephy]\n\n# For Moteus actuators\npip install opensourceleg[moteus]\n\n# For I2C communication\npip install opensourceleg[communication]\n</code></pre>  | Extra           | Dependencies                         | | --------------- | ------------------------------------ | | `dephy`         | flexsea                              | | `moteus`        | moteus, moteus-pi3hat                | | `communication` | smbus2                               | | `messaging`     | grpcio, grpcio-tools, types-protobuf |   <p>For more details on the installation process, please refer to the installation guide.</p>"},{"location":"#usage","title":"\ud83d\udcda Usage","text":"<p>Once the library is installed, you can import it in your projects and start using the modules:</p> <pre><code>from opensourceleg.actuators.dephy import DephyActuator\nfrom opensourceleg.sensors.encoder import AS5048B\n...\n</code></pre> <p>For more details on available modules, tutorials, and examples, please refer to the documentation.</p>"},{"location":"#community-activity","title":"/ Community Activity","text":""},{"location":"#contributors","title":"Contributors \u2728","text":"<p>Thanks to all the wonderful people who have contributed to the project!</p> <sub>Senthur Ayyappan</sub>\ud83d\ude87 \ud83d\udee1\ufe0f \ud83d\udea7 \ud83d\udcbb <sub>tkevinbest</sub>\ud83d\udc1b \u26a0\ufe0f \ud83d\udca1 \ud83d\udcbb <sub>jderosia</sub>\ud83d\udcd6 \u26a0\ufe0f \ud83d\udca1 \ud83d\udcbb <sub>Yuanshao Yang</sub>\u26a0\ufe0f \ud83d\udc1b \ud83d\udcd6 \ud83d\udcbb <sub>shreyhas</sub>\ud83d\udcd6 \u26a0\ufe0f \ud83d\udca1 <sub>jkotar3</sub>\u26a0\ufe0f \ud83d\udc1b \ud83d\udcbb <sub>esharnow</sub>\u26a0\ufe0f \ud83d\udc1b \ud83d\udcd6 <sub>Japman Gill</sub>\u26a0\ufe0f \ud83d\udc1b \ud83d\udcbb <sub>unshrawal</sub>\ud83d\udc1b \ud83d\udcbb <sub>anujtaosf</sub>\ud83d\udcd6 \ud83d\udca1 <sub>Varun Satyadev Shetty</sub>\ud83d\udcd6 \ud83d\udca1 <sub>Katharine-Walters</sub>\ud83d\udc1b <sub>zachbons</sub>\ud83d\udc1b <sub>Anushka</sub>\ud83d\udc1b <sub>Nundini Rawal</sub>\ud83d\udc1b <sub>matteo-crotti</sub>\ud83d\udc1b <p>Contributions of any kind are welcome! For more details, read our contribution guidelines.</p>"},{"location":"#license","title":"\ud83d\udcdd License","text":"<p>The <code>opensourceleg</code> library is licensed under the terms of the LGPL-v2.1 license. This license grants users a number of freedoms:</p> <ul> <li>You are free to use the <code>opensourceleg</code> library for any purpose.</li> <li>You are free to modify the <code>opensourceleg</code> library to suit your needs.</li> <li>You can study how the <code>opensourceleg</code> library works and change it.</li> <li>You can distribute modified versions of the <code>opensourceleg</code> library.</li> </ul> <p>The LGPL license ensures that all these freedoms are protected, now and in the future, requiring everyone to share their modifications when they also share the library in public.</p>"},{"location":"#issues","title":"\ud83d\udc1b Issues","text":"<p>Found a bug or have a suggestion? Please open an issue.</p>"},{"location":"contributing/","title":"Contributing to <code>opensourceleg</code>","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":"<p>You can contribute in many ways:</p>"},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs here</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Expected behavior vs actual behavior.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement a fix for it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>The <code>opensourceleg</code> package could always use more documentation, whether as part of the official docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at here.</p> <p>If you are proposing a new feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions   are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up <code>opensourceleg</code> for local development. Please note this documentation assumes you already have <code>uv</code> and <code>Git</code> installed and ready to go.</p> <ol> <li> <p>Fork the <code>opensourceleg</code> repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> </li> </ol> <pre><code>cd &lt;directory_in_which_repo_should_be_created&gt;\ngit clone git@github.com:YOUR_NAME/opensourceleg.git\n</code></pre> <ol> <li>Now we need to install the environment. Navigate into the directory</li> </ol> <pre><code>cd opensourceleg\n</code></pre> <p>Then, create and activate a virtual environment with uv:</p> <pre><code>uv venv\n</code></pre> <p>Then, activate the virtual environment:</p> <pre><code>source .venv/bin/activate\n</code></pre> <p>Finally, install the dependencies:</p> <pre><code>uv sync\n</code></pre> <p>or, if you want to install all extra/optional dependencies:</p> <pre><code>uv sync --all-extras\n</code></pre> <ol> <li>Install pre-commit to run linters/formatters at commit time:</li> </ol> <pre><code>uv run pre-commit install\n</code></pre> <ol> <li>Create a branch for local development:</li> </ol> <pre><code>git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> <ol> <li> <p>Don't forget to add test cases for your added functionality to the <code>tests</code> directory.</p> </li> <li> <p>When you're done making changes, check that your changes pass the formatting tests.</p> </li> </ol> <pre><code>make check\n</code></pre> <ol> <li>Now, validate that all unit tests are passing:</li> </ol> <pre><code>make test\n</code></pre> <ol> <li>Before raising a pull request you should also run tox.    This will run the tests across different versions of Python:</li> </ol> <pre><code>tox\n</code></pre> <p>This requires you to have multiple versions of python installed. This step is also triggered in the CI/CD pipeline, so you could also choose to skip this step locally.</p> <ol> <li>Commit your changes and push your branch to GitHub:</li> </ol> <pre><code>git add .\ngit commit -m \"Your detailed description of your changes.\"\ngit push origin name-of-your-bugfix-or-feature\n</code></pre> <ol> <li>Submit a pull request through the GitHub website.</li> </ol>"},{"location":"contributing/#commit-message-guidelines","title":"Commit Message Guidelines","text":"<p>This project uses Conventional Commits for commit messages and Release Please for automated releases.</p>"},{"location":"contributing/#conventional-commit-format","title":"Conventional Commit Format","text":"<p>Commit messages should follow this format:</p> <pre><code>&lt;type&gt;[optional scope]: &lt;description&gt;\n\n[optional body]\n\n[optional footer(s)]\n</code></pre>"},{"location":"contributing/#types","title":"Types","text":"<ul> <li><code>feat</code>: A new feature</li> <li><code>fix</code>: A bug fix</li> <li><code>docs</code>: Documentation only changes</li> <li><code>style</code>: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc)</li> <li><code>refactor</code>: A code change that neither fixes a bug nor adds a feature</li> <li><code>perf</code>: A code change that improves performance</li> <li><code>test</code>: Adding missing tests or correcting existing tests</li> <li><code>build</code>: Changes that affect the build system or external dependencies</li> <li><code>ci</code>: Changes to CI configuration files and scripts</li> <li><code>chore</code>: Other changes that don't modify src or test files</li> <li><code>revert</code>: Reverts a previous commit</li> </ul>"},{"location":"contributing/#examples","title":"Examples","text":"<pre><code>feat: add support for new actuator model\nfix: resolve memory leak in joint controller\ndocs: update installation instructions\nrefactor: simplify sensor calibration logic\ntest: add unit tests for PID controller\n</code></pre>"},{"location":"contributing/#breaking-changes","title":"Breaking Changes","text":"<p>Breaking changes should be indicated by adding <code>!</code> after the type/scope or by including <code>BREAKING CHANGE:</code> in the footer:</p> <pre><code>feat!: remove deprecated API methods\n# or\nfeat: add new configuration format\n\nBREAKING CHANGE: Configuration file format has changed from JSON to YAML\n</code></pre>"},{"location":"contributing/#release-please","title":"Release Please","text":"<p>This project uses Release Please to automatically: - Generate changelogs - Create releases - Update version numbers - Publish to PyPI - Deploy documentation</p> <p>Release Please analyzes conventional commit messages to determine the type of release (major, minor, or patch) and generates appropriate release notes. This happens automatically when commits are pushed to the main branch.</p>"},{"location":"contributing/#how-release-please-works","title":"How Release Please Works","text":"<ol> <li>On every push to main: Release Please analyzes new commits using conventional commit format</li> <li>Creates/updates a Release PR: If releasable changes are found, it creates or updates a \"chore: release X.Y.Z\" PR</li> <li>When Release PR is merged: A GitHub release is created and the package is automatically published to PyPI</li> </ol>"},{"location":"contributing/#avoiding-unintended-releases","title":"Avoiding Unintended Releases","text":"<p>If you need to commit to main without triggering a release (for urgent fixes, documentation, etc.), use these strategies:</p>"},{"location":"contributing/#skip-release-processing","title":"Skip Release Processing","text":"<p>Add <code>Release-As: skip</code> to your commit message:</p> <pre><code>git commit -m \"docs: fix typo in contributing guide\n\nRelease-As: skip\"\n</code></pre>"},{"location":"contributing/#use-non-release-commit-types","title":"Use Non-Release Commit Types","text":"<p>Some commit types don't trigger releases by default: - <code>chore</code>: Maintenance tasks - <code>ci</code>: CI/CD changes - <code>build</code>: Build system changes - <code>docs</code>: Documentation-only changes (depending on configuration)</p> <pre><code>git commit -m \"chore: update GitHub Actions workflow\"\n</code></pre>"},{"location":"contributing/#manual-release-control","title":"Manual Release Control","text":""},{"location":"contributing/#force-a-specific-version","title":"Force a Specific Version","text":"<p>Override the automatic version bump:</p> <pre><code>git commit -m \"feat: add new actuator support\n\nRelease-As: 2.1.0\"\n</code></pre>"},{"location":"contributing/#force-a-patch-release","title":"Force a Patch Release","text":"<p>Convert a non-release commit into a patch release:</p> <pre><code>git commit -m \"docs: improve API documentation\n\nRelease-As: patch\"\n</code></pre>"},{"location":"contributing/#working-with-release-please-prs","title":"Working with Release Please PRs","text":"<p>When Release Please creates a release PR:</p> <ol> <li>Review the changelog: Ensure all changes are accurately described</li> <li>Check the version bump: Verify it matches the significance of changes</li> <li>Merge to release: Merging the PR will create the GitHub release and publish to PyPI</li> <li>Never close without merging: This will skip the release entirely</li> </ol> <p>The release PR will also trigger a test publication to Test PyPI for validation.</p>"},{"location":"contributing/#troubleshooting","title":"Troubleshooting","text":"<p>No Release PR created? - Ensure commits follow conventional commit format exactly - Check that commits aren't marked with <code>Release-As: skip</code> - Verify there isn't already an open Release Please PR (only one can exist)</p> <p>Wrong version bump? - <code>fix:</code> commits create patch releases (0.0.1) - <code>feat:</code> commits create minor releases (0.1.0) - Breaking changes (with <code>!</code> or <code>BREAKING CHANGE:</code>) create major releases (1.0.0)</p> <p>Need to cancel a release? - Close the Release Please PR (don't merge it) - The next qualifying commit will create a new release PR</p>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li> <p>The pull request should include tests.</p> </li> <li> <p>If the pull request adds functionality, the docs should be updated.    Put your new functionality into a function with a docstring, and add the feature to the list in <code>README.md</code>.</p> </li> </ol>"},{"location":"installation/","title":"Installation Guide","text":"<p>This guide will walk you through installing and setting up the opensourceleg library. Whether you're new to Python or an experienced developer, we'll cover everything you need to get started.</p>"},{"location":"installation/#quick-start","title":"Quick Start","text":"<pre><code>pip install opensourceleg\n</code></pre> <p>If you're familiar with Python packages, the command above will get you started quickly. However, we recommend reading through the complete guide for a better setup.</p>"},{"location":"installation/#understanding-installation-methods","title":"Understanding Installation Methods","text":"<p>We offer two ways to install opensourceleg:</p> <ul> <li>Standard Installation: For users who want to use the library as-is. (Suitable for beginners, end users, testers/ validators, and for anyone who is not planning to modify the library's source code or connect it to non-standard database systems, hardware, or third-party frameworks. )</li> <li>Development Installation: For contributors or users who need to modify the library (Suitable for external contributors and advanced users who can perform bug fixes and improve functionality.)</li> </ul>"},{"location":"installation/#1-standard-installation-recommended-for-most-users","title":"1. Standard Installation (Recommended for Most Users)","text":""},{"location":"installation/#prerequisites-explained","title":"Prerequisites Explained","text":"<ul> <li>Python 3.11 or newer: The library requires modern Python features. Download Python here <p>\ud83d\udca1 When installing Python, make sure to check \"Add Python to PATH\" on Windows!</p> </li> <li>pip: Python's package installer (comes with Python) <p>\ud83d\udca1 To verify your installation, open a terminal and run:</p> <pre><code>python --version\npip --version\n</code></pre> </li> </ul>"},{"location":"installation/#virtual-environment-setup","title":"Virtual Environment Setup","text":"<p>A virtual environment helps avoid conflicts between different projects and their dependencies. It is generally a good idea to use one.</p> <pre><code># Step 1: Create a virtual environment\n# This creates a new folder named .venv with a fresh Python installation\npython -m venv .venv\n\n# Step 2: Activate the virtual environment\n# On Linux/macOS:\nsource .venv/bin/activate\n# On Windows:\n.venv\\Scripts\\activate\n\n# You'll know it's working when you see (.venv) at the start of your terminal line\n\n# Step 3: Install opensourceleg\npip install opensourceleg\n</code></pre>"},{"location":"installation/#hardware-specific-dependencies","title":"Hardware-Specific Dependencies","text":"<p>The opensourceleg library supports a variety of actuators and sensors, each with its own dependencies. Rather than installing all possible dependencies (which can be extensive), we recommend installing only what you need for your specific hardware configuration.</p>"},{"location":"installation/#installing-hardware-specific-packages","title":"Installing Hardware-Specific Packages","text":"<p>You can easily install hardware-specific dependencies using pip's \"extras\" feature:</p> <pre><code># For Dephy actuators\npip install opensourceleg[dephy]\n\n# For Moteus actuators\npip install opensourceleg[moteus]\n\n# For I2C communication\npip install opensourceleg[communication]\n\n# For gRPC messaging functionality\npip install opensourceleg[messaging]\n</code></pre>"},{"location":"installation/#available-extras","title":"Available Extras","text":"Extra Dependencies <code>dephy</code> flexsea <code>moteus</code> moteus, moteus-pi3hat <code>communication</code> smbus2 <code>messaging</code> grpcio, grpcio-tools, types-protobuf <p>This approach keeps your installation lightweight and focused on just the hardware you're working with.</p> <p>\ud83d\udca1 Why Use a Virtual Environment? Keeps your projects isolated</p> <ul> <li>Prevents version conflicts</li> <li>Makes it easier to share your project</li> <li>Allows different Python versions for different projects</li> </ul>"},{"location":"installation/#basic-usage-example","title":"Basic Usage Example","text":"<pre><code># Import the components you need\nfrom opensourceleg.actuators.dephy import DephyActuator\nfrom opensourceleg.sensors.encoder import AS5048B\n\n# Now you can use these components in your code\n...\n</code></pre>"},{"location":"installation/#2-development-installation","title":"2. Development Installation","text":"<p>This section is for those who want to contribute to opensourceleg or need to modify its code.</p>"},{"location":"installation/#prerequisites-in-detail","title":"Prerequisites in Detail","text":"<ul> <li>Python 3.11+: Same as above (we support Python 3.11, 3.12, and 3.13)</li> <li>UV: A fast Python package manager. The easiest way to install UV is via pip:    <pre><code>pip install uv\n</code></pre>    OR    If you are unable to install uv, do</li> </ul> <pre><code>pip install uv --break-system-packages\n</code></pre> <p>If you are unable to find uv command then add following line in your <code>.bashrc</code> script :    <pre><code>export PATH=\"$PATH:/home/$USER/.local/bin\"\n</code></pre></p> <p>Then, open a new shell or reload your shell configuration:    <pre><code>source ~/.bashrc\n</code></pre>    For other installation methods (including standalone installers), see the UV installation guide.</p> <ul> <li>Git: Version control system, see Git installation guide</li> </ul>"},{"location":"installation/#detailed-development-setup","title":"Detailed Development Setup","text":"<ol> <li>Fork &amp; Clone the Repository</li> </ol> <pre><code># First, fork the repository on GitHub (click the 'Fork' button)\n\n# Then clone your fork (replace YOUR-USERNAME with your GitHub username)\ngit clone https://github.com/YOUR-USERNAME/opensourceleg.git\n\n# Move into the project directory\ncd opensourceleg\n</code></pre> <ol> <li>Configure Development Environment</li> </ol> <pre><code># Connect your fork to the main repository for updates\ngit remote add upstream https://github.com/neurobionics/opensourceleg.git\n\n# Create and activate a virtual environment with UV\nuv venv\n\n# Activate the virtual environment\n# On Linux/macOS:\nsource .venv/bin/activate\n# On Windows:\n.venv\\Scripts\\activate\n\n# Install project dependencies using UV\nuv sync  # Installs all dependencies including hardware-specific packages\n\n# Install pre-commit hooks and setup development tools\nmake install\n</code></pre> <p>Windows Users: You'll need to install <code>make</code> first: Install chocolatey and run: <code>choco install make</code>. Alternatively, download from GnuWin32</p> <ol> <li>Development Workflow Guide</li> </ol> <pre><code># Create a new branch for your changes\ngit checkout -b feature-name\n# Use a descriptive name like 'add-new-sensor' or 'fix-motor-bug'\n\n# After making changes, run the quality checks\nmake check    # Runs linting, type checking, and dependency validation\nmake test     # Runs the full test suite with coverage\n\n# Run documentation locally to preview changes\nmake docs     # Serves documentation at http://localhost:8000\n\n# Commit your changes\ngit add .\ngit commit -m \"Detailed description of your changes\"\ngit push origin feature-name\n</code></pre> <ol> <li>UV Development Commands</li> </ol> <p>UV makes development much faster and more reliable:</p> <pre><code># Add a new dependency\nuv add package-name\n\n# Add a development dependency\nuv add --group dev package-name\n\n# Run commands in the project environment\nuv run python script.py\nuv run pytest tests/\nuv run mypy opensourceleg/\n\n# Check your environment\nuv pip list              # See installed packages\nuv python list           # See available Python versions\n</code></pre> <ol> <li>Contributing to opensourceleg    If you want to contribute your modifications to the <code>opensourceleg</code> library so that others can use them, please read our contribution guidelines.</li> </ol>"},{"location":"installation/#troubleshooting-common-issues","title":"Troubleshooting Common Issues","text":""},{"location":"installation/#1-system-package-warnings","title":"1. System Package Warnings","text":"<p>If you see warnings about breaking system packages (common in Python 3.11+):</p> <pre><code># Not recommended, but works if you're in a hurry:\npip install opensourceleg --break-system-packages\n\n# Better solution: Use a virtual environment as described above\n</code></pre>"},{"location":"installation/#2-virtual-environment-problems","title":"2. Virtual Environment Problems","text":"<p>If your virtual environment isn't activating:</p> <pre><code># Check where Python is running from\nwhich python  # on Unix/macOS\nwhere python  # on Windows\n\n# Should show path to your virtual environment\n# Example: .venv/bin/python\n</code></pre>"},{"location":"installation/#3-uv-installation-issues","title":"3. UV Installation Issues","text":"<p>If UV isn't working:</p> <pre><code># Verify UV installation\nuv --version\n\n# Check if UV is in your PATH\nwhich uv  # on Unix/macOS\nwhere uv  # on Windows\n\n# If not found, try adding to PATH or reinstalling\n</code></pre>"},{"location":"installation/#4-development-environment-issues","title":"4. Development Environment Issues","text":"<p>If you encounter issues with the development setup:</p> <pre><code># Clean and reinstall everything\nrm -rf .venv uv.lock\nuv sync\n\n# Verify development tools are working\nuv run pre-commit --version\nuv run pytest --version\nuv run mypy --version\n</code></pre>"},{"location":"installation/#5-unauthorized-error-or-venvscriptsactivateps1-cannot-be-loaded-error","title":"5. Unauthorized error or \".venv\\Scripts\\Activate.ps1 cannot be loaded\" error","text":"<p>While running \".venv\\Scripts\\activate\" command, sometimes you may get an \"Unauthorized error\" (below error). For this error, you would need to run \"Set-ExecutionPolicy -ExecutionPolicy Unrestricted -Scope CurrentUser\" command to remove the restrictions and let the current user run the command.</p> <pre><code>#ERROR MESSAGE: .venv\\Scripts\\Activate.ps1 cannot be loaded because running scripts is disabled on this system. For more information, see about_Execution_Policies at https:/go.microsoft.com/fwlink/?LinkID=135170.\n\n#SOLUTION: Run \u201cSet-ExecutionPolicy -ExecutionPolicy Unrestricted -Scope CurrentUser\u201d command\nSet-ExecutionPolicy -ExecutionPolicy Unrestricted -Scope CurrentUser\n</code></pre>"},{"location":"installation/#getting-help","title":"Getting Help","text":"<p>Everyone was a beginner once! Don't hesitate to ask questions if you get stuck. We have several ways to get help:</p> <ol> <li>Bug Reports: Open an issue on GitHub</li> <li>Questions: Check our discussions</li> </ol>"},{"location":"installation/#next-steps","title":"Next Steps","text":"<ol> <li>Read the Documentation: Full Documentation</li> <li>Try Tutorials: Start with our getting started guide</li> <li>Join the Community: Connect with other users on our community forum</li> <li>Contribute: Check our contribution guidelines</li> </ol>"},{"location":"license/","title":"License","text":"<pre><code>              GNU LESSER GENERAL PUBLIC LICENSE\n                   Version 2.1, February 1999\n</code></pre> <p>Copyright (C) 1991, 1999 Free Software Foundation, Inc. 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed.</p> <p>[This is the first released version of the Lesser GPL. It also counts as the successor of the GNU Library Public License, version 2, hence the version number 2.1.]</p> <pre><code>                        Preamble\n</code></pre> <p>The licenses for most software are designed to take away your freedom to share and change it. By contrast, the GNU General Public Licenses are intended to guarantee your freedom to share and change free software--to make sure the software is free for all its users.</p> <p>This license, the Lesser General Public License, applies to some specially designated software packages--typically libraries--of the Free Software Foundation and other authors who decide to use it. You can use it too, but we suggest you first think carefully about whether this license or the ordinary General Public License is the better strategy to use in any particular case, based on the explanations below.</p> <p>When we speak of free software, we are referring to freedom of use, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for this service if you wish); that you receive source code or can get it if you want it; that you can change the software and use pieces of it in new free programs; and that you are informed that you can do these things.</p> <p>To protect your rights, we need to make restrictions that forbid distributors to deny you these rights or to ask you to surrender these rights. These restrictions translate to certain responsibilities for you if you distribute copies of the library or if you modify it.</p> <p>For example, if you distribute copies of the library, whether gratis or for a fee, you must give the recipients all the rights that we gave you. You must make sure that they, too, receive or can get the source code. If you link other code with the library, you must provide complete object files to the recipients, so that they can relink them with the library after making changes to the library and recompiling it. And you must show them these terms so they know their rights.</p> <p>We protect your rights with a two-step method: (1) we copyright the library, and (2) we offer you this license, which gives you legal permission to copy, distribute and/or modify the library.</p> <p>To protect each distributor, we want to make it very clear that there is no warranty for the free library. Also, if the library is modified by someone else and passed on, the recipients should know that what they have is not the original version, so that the original author's reputation will not be affected by problems that might be introduced by others.</p> <p>Finally, software patents pose a constant threat to the existence of any free program. We wish to make sure that a company cannot effectively restrict the users of a free program by obtaining a restrictive license from a patent holder. Therefore, we insist that any patent license obtained for a version of the library must be consistent with the full freedom of use specified in this license.</p> <p>Most GNU software, including some libraries, is covered by the ordinary GNU General Public License. This license, the GNU Lesser General Public License, applies to certain designated libraries, and is quite different from the ordinary General Public License. We use this license for certain libraries in order to permit linking those libraries into non-free programs.</p> <p>When a program is linked with a library, whether statically or using a shared library, the combination of the two is legally speaking a combined work, a derivative of the original library. The ordinary General Public License therefore permits such linking only if the entire combination fits its criteria of freedom. The Lesser General Public License permits more lax criteria for linking other code with the library.</p> <p>We call this license the \"Lesser\" General Public License because it does Less to protect the user's freedom than the ordinary General Public License. It also provides other free software developers Less of an advantage over competing non-free programs. These disadvantages are the reason we use the ordinary General Public License for many libraries. However, the Lesser license provides advantages in certain special circumstances.</p> <p>For example, on rare occasions, there may be a special need to encourage the widest possible use of a certain library, so that it becomes a de-facto standard. To achieve this, non-free programs must be allowed to use the library. A more frequent case is that a free library does the same job as widely used non-free libraries. In this case, there is little to gain by limiting the free library to free software only, so we use the Lesser General Public License.</p> <p>In other cases, permission to use a particular library in non-free programs enables a greater number of people to use a large body of free software. For example, permission to use the GNU C Library in non-free programs enables many more people to use the whole GNU operating system, as well as its variant, the GNU/Linux operating system.</p> <p>Although the Lesser General Public License is Less protective of the users' freedom, it does ensure that the user of a program that is linked with the Library has the freedom and the wherewithal to run that program using a modified version of the Library.</p> <p>The precise terms and conditions for copying, distribution and modification follow. Pay close attention to the difference between a \"work based on the library\" and a \"work that uses the library\". The former contains code derived from the library, whereas the latter must be combined with the library in order to run.</p> <pre><code>              GNU LESSER GENERAL PUBLIC LICENSE\n</code></pre> <p>TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION</p> <ol> <li>This License Agreement applies to any software library or other    program which contains a notice placed by the copyright holder or    other authorized party saying it may be distributed under the terms of    this Lesser General Public License (also called \"this License\").    Each licensee is addressed as \"you\".</li> </ol> <p>A \"library\" means a collection of software functions and/or data prepared so as to be conveniently linked with application programs (which use some of those functions and data) to form executables.</p> <p>The \"Library\", below, refers to any such software library or work which has been distributed under these terms. A \"work based on the Library\" means either the Library or any derivative work under copyright law: that is to say, a work containing the Library or a portion of it, either verbatim or with modifications and/or translated straightforwardly into another language. (Hereinafter, translation is included without limitation in the term \"modification\".)</p> <p>\"Source code\" for a work means the preferred form of the work for making modifications to it. For a library, complete source code means all the source code for all modules it contains, plus any associated interface definition files, plus the scripts used to control compilation and installation of the library.</p> <p>Activities other than copying, distribution and modification are not covered by this License; they are outside its scope. The act of running a program using the Library is not restricted, and output from such a program is covered only if its contents constitute a work based on the Library (independent of the use of the Library in a tool for writing it). Whether that is true depends on what the Library does and what the program that uses the Library does.</p> <ol> <li>You may copy and distribute verbatim copies of the Library's    complete source code as you receive it, in any medium, provided that    you conspicuously and appropriately publish on each copy an    appropriate copyright notice and disclaimer of warranty; keep intact    all the notices that refer to this License and to the absence of any    warranty; and distribute a copy of this License along with the    Library.</li> </ol> <p>You may charge a fee for the physical act of transferring a copy, and you may at your option offer warranty protection in exchange for a fee.</p> <ol> <li>You may modify your copy or copies of the Library or any portion    of it, thus forming a work based on the Library, and copy and    distribute such modifications or work under the terms of Section 1    above, provided that you also meet all of these conditions:</li> </ol> <p>a) The modified work must itself be a software library.</p> <p>b) You must cause the files modified to carry prominent notices    stating that you changed the files and the date of any change.</p> <p>c) You must cause the whole of the work to be licensed at no    charge to all third parties under the terms of this License.</p> <p>d) If a facility in the modified Library refers to a function or a    table of data to be supplied by an application program that uses    the facility, other than as an argument passed when the facility    is invoked, then you must make a good faith effort to ensure that,    in the event an application does not supply such function or    table, the facility still operates, and performs whatever part of    its purpose remains meaningful.</p> <p>(For example, a function in a library to compute square roots has    a purpose that is entirely well-defined independent of the    application. Therefore, Subsection 2d requires that any    application-supplied function or table used by this function must    be optional: if the application does not supply it, the square    root function must still compute square roots.)</p> <p>These requirements apply to the modified work as a whole. If identifiable sections of that work are not derived from the Library, and can be reasonably considered independent and separate works in themselves, then this License, and its terms, do not apply to those sections when you distribute them as separate works. But when you distribute the same sections as part of a whole which is a work based on the Library, the distribution of the whole must be on the terms of this License, whose permissions for other licensees extend to the entire whole, and thus to each and every part regardless of who wrote it.</p> <p>Thus, it is not the intent of this section to claim rights or contest your rights to work written entirely by you; rather, the intent is to exercise the right to control the distribution of derivative or collective works based on the Library.</p> <p>In addition, mere aggregation of another work not based on the Library with the Library (or with a work based on the Library) on a volume of a storage or distribution medium does not bring the other work under the scope of this License.</p> <ol> <li>You may opt to apply the terms of the ordinary GNU General Public    License instead of this License to a given copy of the Library. To do    this, you must alter all the notices that refer to this License, so    that they refer to the ordinary GNU General Public License, version 2,    instead of to this License. (If a newer version than version 2 of the    ordinary GNU General Public License has appeared, then you can specify    that version instead if you wish.) Do not make any other change in    these notices.</li> </ol> <p>Once this change is made in a given copy, it is irreversible for that copy, so the ordinary GNU General Public License applies to all subsequent copies and derivative works made from that copy.</p> <p>This option is useful when you wish to copy part of the code of the Library into a program that is not a library.</p> <ol> <li>You may copy and distribute the Library (or a portion or    derivative of it, under Section 2) in object code or executable form    under the terms of Sections 1 and 2 above provided that you accompany    it with the complete corresponding machine-readable source code, which    must be distributed under the terms of Sections 1 and 2 above on a    medium customarily used for software interchange.</li> </ol> <p>If distribution of object code is made by offering access to copy from a designated place, then offering equivalent access to copy the source code from the same place satisfies the requirement to distribute the source code, even though third parties are not compelled to copy the source along with the object code.</p> <ol> <li>A program that contains no derivative of any portion of the    Library, but is designed to work with the Library by being compiled or    linked with it, is called a \"work that uses the Library\". Such a    work, in isolation, is not a derivative work of the Library, and    therefore falls outside the scope of this License.</li> </ol> <p>However, linking a \"work that uses the Library\" with the Library creates an executable that is a derivative of the Library (because it contains portions of the Library), rather than a \"work that uses the library\". The executable is therefore covered by this License. Section 6 states terms for distribution of such executables.</p> <p>When a \"work that uses the Library\" uses material from a header file that is part of the Library, the object code for the work may be a derivative work of the Library even though the source code is not. Whether this is true is especially significant if the work can be linked without the Library, or if the work is itself a library. The threshold for this to be true is not precisely defined by law.</p> <p>If such an object file uses only numerical parameters, data structure layouts and accessors, and small macros and small inline functions (ten lines or less in length), then the use of the object file is unrestricted, regardless of whether it is legally a derivative work. (Executables containing this object code plus portions of the Library will still fall under Section 6.)</p> <p>Otherwise, if the work is a derivative of the Library, you may distribute the object code for the work under the terms of Section 6. Any executables containing that work also fall under Section 6, whether or not they are linked directly with the Library itself.</p> <ol> <li>As an exception to the Sections above, you may also combine or    link a \"work that uses the Library\" with the Library to produce a    work containing portions of the Library, and distribute that work    under terms of your choice, provided that the terms permit    modification of the work for the customer's own use and reverse    engineering for debugging such modifications.</li> </ol> <p>You must give prominent notice with each copy of the work that the Library is used in it and that the Library and its use are covered by this License. You must supply a copy of this License. If the work during execution displays copyright notices, you must include the copyright notice for the Library among them, as well as a reference directing the user to the copy of this License. Also, you must do one of these things:</p> <pre><code>a) Accompany the work with the complete corresponding\nmachine-readable source code for the Library including whatever\nchanges were used in the work (which must be distributed under\nSections 1 and 2 above); and, if the work is an executable linked\nwith the Library, with the complete machine-readable \"work that\nuses the Library\", as object code and/or source code, so that the\nuser can modify the Library and then relink to produce a modified\nexecutable containing the modified Library.  (It is understood\nthat the user who changes the contents of definitions files in the\nLibrary will not necessarily be able to recompile the application\nto use the modified definitions.)\n\nb) Use a suitable shared library mechanism for linking with the\nLibrary.  A suitable mechanism is one that (1) uses at run time a\ncopy of the library already present on the user's computer system,\nrather than copying library functions into the executable, and (2)\nwill operate properly with a modified version of the library, if\nthe user installs one, as long as the modified version is\ninterface-compatible with the version that the work was made with.\n\nc) Accompany the work with a written offer, valid for at\nleast three years, to give the same user the materials\nspecified in Subsection 6a, above, for a charge no more\nthan the cost of performing this distribution.\n\nd) If distribution of the work is made by offering access to copy\nfrom a designated place, offer equivalent access to copy the above\nspecified materials from the same place.\n\ne) Verify that the user has already received a copy of these\nmaterials or that you have already sent this user a copy.\n</code></pre> <p>For an executable, the required form of the \"work that uses the Library\" must include any data and utility programs needed for reproducing the executable from it. However, as a special exception, the materials to be distributed need not include anything that is normally distributed (in either source or binary form) with the major components (compiler, kernel, and so on) of the operating system on which the executable runs, unless that component itself accompanies the executable.</p> <p>It may happen that this requirement contradicts the license restrictions of other proprietary libraries that do not normally accompany the operating system. Such a contradiction means you cannot use both them and the Library together in an executable that you distribute.</p> <ol> <li>You may place library facilities that are a work based on the    Library side-by-side in a single library together with other library    facilities not covered by this License, and distribute such a combined    library, provided that the separate distribution of the work based on    the Library and of the other library facilities is otherwise    permitted, and provided that you do these two things:</li> </ol> <p>a) Accompany the combined library with a copy of the same work    based on the Library, uncombined with any other library    facilities. This must be distributed under the terms of the    Sections above.</p> <p>b) Give prominent notice with the combined library of the fact    that part of it is a work based on the Library, and explaining    where to find the accompanying uncombined form of the same work.</p> <ol> <li> <p>You may not copy, modify, sublicense, link with, or distribute    the Library except as expressly provided under this License. Any    attempt otherwise to copy, modify, sublicense, link with, or    distribute the Library is void, and will automatically terminate your    rights under this License. However, parties who have received copies,    or rights, from you under this License will not have their licenses    terminated so long as such parties remain in full compliance.</p> </li> <li> <p>You are not required to accept this License, since you have not    signed it. However, nothing else grants you permission to modify or    distribute the Library or its derivative works. These actions are    prohibited by law if you do not accept this License. Therefore, by    modifying or distributing the Library (or any work based on the    Library), you indicate your acceptance of this License to do so, and    all its terms and conditions for copying, distributing or modifying    the Library or works based on it.</p> </li> <li> <p>Each time you redistribute the Library (or any work based on the     Library), the recipient automatically receives a license from the     original licensor to copy, distribute, link with or modify the Library     subject to these terms and conditions. You may not impose any further     restrictions on the recipients' exercise of the rights granted herein.     You are not responsible for enforcing compliance by third parties with     this License.</p> </li> <li> <p>If, as a consequence of a court judgment or allegation of patent     infringement or for any other reason (not limited to patent issues),     conditions are imposed on you (whether by court order, agreement or     otherwise) that contradict the conditions of this License, they do not     excuse you from the conditions of this License. If you cannot     distribute so as to satisfy simultaneously your obligations under this     License and any other pertinent obligations, then as a consequence you     may not distribute the Library at all. For example, if a patent     license would not permit royalty-free redistribution of the Library by     all those who receive copies directly or indirectly through you, then     the only way you could satisfy both it and this License would be to     refrain entirely from distribution of the Library.</p> </li> </ol> <p>If any portion of this section is held invalid or unenforceable under any particular circumstance, the balance of the section is intended to apply, and the section as a whole is intended to apply in other circumstances.</p> <p>It is not the purpose of this section to induce you to infringe any patents or other property right claims or to contest validity of any such claims; this section has the sole purpose of protecting the integrity of the free software distribution system which is implemented by public license practices. Many people have made generous contributions to the wide range of software distributed through that system in reliance on consistent application of that system; it is up to the author/donor to decide if he or she is willing to distribute software through any other system and a licensee cannot impose that choice.</p> <p>This section is intended to make thoroughly clear what is believed to be a consequence of the rest of this License.</p> <ol> <li> <p>If the distribution and/or use of the Library is restricted in     certain countries either by patents or by copyrighted interfaces, the     original copyright holder who places the Library under this License may add     an explicit geographical distribution limitation excluding those countries,     so that distribution is permitted only in or among countries not thus     excluded. In such case, this License incorporates the limitation as if     written in the body of this License.</p> </li> <li> <p>The Free Software Foundation may publish revised and/or new     versions of the Lesser General Public License from time to time.     Such new versions will be similar in spirit to the present version,     but may differ in detail to address new problems or concerns.</p> </li> </ol> <p>Each version is given a distinguishing version number. If the Library specifies a version number of this License which applies to it and \"any later version\", you have the option of following the terms and conditions either of that version or of any later version published by the Free Software Foundation. If the Library does not specify a license version number, you may choose any version ever published by the Free Software Foundation.</p> <ol> <li> <p>If you wish to incorporate parts of the Library into other free     programs whose distribution conditions are incompatible with these,     write to the author to ask for permission. For software which is     copyrighted by the Free Software Foundation, write to the Free     Software Foundation; we sometimes make exceptions for this. Our     decision will be guided by the two goals of preserving the free status     of all derivatives of our free software and of promoting the sharing     and reuse of software generally.</p> <pre><code>                        NO WARRANTY\n</code></pre> </li> <li> <p>BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO     WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.     EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR     OTHER PARTIES PROVIDE THE LIBRARY \"AS IS\" WITHOUT WARRANTY OF ANY     KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE     IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR     PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE     LIBRARY IS WITH YOU. SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME     THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.</p> </li> <li> <p>IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN     WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY     AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU     FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR     CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE     LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING     RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A     FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF     SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH     DAMAGES.</p> <pre><code>                 END OF TERMS AND CONDITIONS\n\n       How to Apply These Terms to Your New Libraries\n</code></pre> </li> </ol> <p>If you develop a new library, and you want it to be of the greatest possible use to the public, we recommend making it free software that everyone can redistribute and change. You can do so by permitting redistribution under these terms (or, alternatively, under the terms of the ordinary General Public License).</p> <p>To apply these terms, attach the following notices to the library. It is safest to attach them to the start of each source file to most effectively convey the exclusion of warranty; and each file should have at least the \"copyright\" line and a pointer to where the full notice is found.</p> <pre><code>&lt;one line to give the library's name and a brief idea of what it does.&gt;\nCopyright (C) &lt;year&gt;  &lt;name of author&gt;\n\nThis library is free software; you can redistribute it and/or\nmodify it under the terms of the GNU Lesser General Public\nLicense as published by the Free Software Foundation; either\nversion 2.1 of the License, or (at your option) any later version.\n\nThis library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nLesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public\nLicense along with this library; if not, write to the Free Software\nFoundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301\nUSA\n</code></pre> <p>Also add information on how to contact you by electronic and paper mail.</p> <p>You should also get your employer (if you work as a programmer) or your school, if any, to sign a \"copyright disclaimer\" for the library, if necessary. Here is a sample; alter the names:</p> <p>Yoyodyne, Inc., hereby disclaims all copyright interest in the library `Frob' (a library for tweaking knobs) written by James Random Hacker.</p> <p>, 1 April 1990 Ty Coon, President of Vice <p>That's all there is to it!</p>"},{"location":"security/","title":"Security","text":""},{"location":"security/#reporting-security-issues","title":"\ud83d\udd10 Reporting Security Issues","text":"<p>Do not open issues that might have security implications! It is critical that security related issues are reported privately so we have time to address them before they become public knowledge.</p> <p>Vulnerabilities can be reported by emailing the maintainer: Senthur Ayyappan or emailing the Open Source Leg Team</p> <p>Please include the requested information listed below (as much as you can provide) to help us better understand the nature and scope of the possible issue:</p> <ul> <li>Type of issue (e.g. buffer overflow, SQL injection, cross-site scripting, etc.)</li> <li>Full paths of source file(s) related to the manifestation of the issue</li> <li>The location of the affected source code (tag/branch/commit or direct URL)</li> <li>Any special configuration required to reproduce the issue</li> <li>Environment (e.g. Linux / Windows / macOS)</li> <li>Step-by-step instructions to reproduce the issue</li> <li>Proof-of-concept or exploit code (if possible)</li> <li>Impact of the issue, including how an attacker might exploit the issue</li> </ul> <p>This information will help us triage your report more quickly.</p>"},{"location":"security/#preferred-languages","title":"Preferred Languages","text":"<p>We prefer all communications to be in English.</p>"},{"location":"api/logging/","title":"Logger","text":""},{"location":"api/logging/#opensourceleg.logging.LogLevel","title":"<code>LogLevel</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum for log levels used by the Logger class.</p> <p>Attributes:</p> Name Type Description <code>DEBUG</code> <p>Detailed information, typically of interest only when diagnosing problems.</p> <code>INFO</code> <p>Confirmation that things are working as expected.</p> <code>WARNING</code> <p>An indication that something unexpected happened.</p> <code>ERROR</code> <p>A more serious problem, the software has not been able to perform some function.</p> <code>CRITICAL</code> <p>A serious error, indicating that the program itself may be unable to continue running.</p> Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>class LogLevel(Enum):\n    \"\"\"\n    Enum for log levels used by the Logger class.\n\n    Attributes:\n        DEBUG: Detailed information, typically of interest only when diagnosing problems.\n        INFO: Confirmation that things are working as expected.\n        WARNING: An indication that something unexpected happened.\n        ERROR: A more serious problem, the software has not been able to perform some function.\n        CRITICAL: A serious error, indicating that the program itself may be unable to continue running.\n    \"\"\"\n\n    DEBUG = logging.DEBUG\n    INFO = logging.INFO\n    WARNING = logging.WARNING\n    ERROR = logging.ERROR\n    CRITICAL = logging.CRITICAL\n</code></pre>"},{"location":"api/logging/#opensourceleg.logging.Logger","title":"<code>Logger</code>","text":"<p>               Bases: <code>Logger</code></p> <p>Represents a custom singleton logger class that extends the built-in Python logger. The logger provides additional functionality for tracking and logging variables to a CSV file. It supports different log levels and log formatting options.</p> <p>Parameters:</p> Name Type Description Default <code>log_path</code> <code>str</code> <p>The path to save log files.</p> <code>'./'</code> <code>log_format</code> <code>str</code> <p>The log message format.</p> <code>'[%(asctime)s] %(levelname)s: %(message)s'</code> <code>file_level</code> <code>LogLevel</code> <p>The log level for file output.</p> <code>DEBUG</code> <code>stream_level</code> <code>LogLevel</code> <p>The log level for console output.</p> <code>INFO</code> <code>file_max_bytes</code> <code>int</code> <p>The maximum size of the log file in bytes before rotation.</p> <code>0</code> <code>file_backup_count</code> <code>int</code> <p>The number of backup log files to keep.</p> <code>5</code> <code>file_name</code> <code>Union[str, None]</code> <p>The base name for the log file.</p> <code>None</code> <code>buffer_size</code> <code>int</code> <p>The maximum number of log entries to buffer before writing to the CSV file.</p> <code>1000</code> <code>enable_csv_logging</code> <code>bool</code> <p>Whether to enable CSV logging.</p> <code>True</code> Properties <ul> <li>file_path: The path to the log file.</li> <li>buffer_size: The maximum number of log entries to buffer.</li> <li>file_level: The log level for file output.</li> <li>stream_level: The log level for console output.</li> <li>file_max_bytes: The maximum size of the log file in bytes before rotation.</li> <li>file_backup_count: The number of backup log files to keep.</li> <li>csv_logging_enabled: Whether CSV logging is enabled.</li> <li>tracked_variable_count: The number of currently tracked variables.</li> </ul> <p>Methods:</p> Name Description <code>- **track_function**</code> <p>Track the output of a function for logging.</p> <code>- **track_attributes**</code> <p>Track the attributes of an object for logging.</p> <code>- **flush_buffer**</code> <p>Write the buffered log entries to the CSV file.</p> <code>- **reset**</code> <p>Reset the logger state.</p> <code>- **close**</code> <p>Close the logger and flush any remaining log entries.</p> <code>- **debug**</code> <p>Log a debug message.</p> <code>- **info**</code> <p>Log an info message.</p> <code>- **warning**</code> <p>Log a warning message.</p> <code>- **error**</code> <p>Log an error message.</p> <code>- **critical**</code> <p>Log a critical message.</p> <code>- **log**</code> <p>Log a message at a specific log level.</p> <p>Author: - Senthur Ayyappan senthura@umich.edu - Kevin Best tkbest@umich.edu</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; logger = Logger()\n&gt;&gt;&gt; logger.info(\"This is an info message\")\n[2022-01-01 12:00:00] INFO: This is an info message\n&gt;&gt;&gt; logger.debug(\"This is a debug message\")\n[2022-01-01 12:00:00] DEBUG: This is a debug message\n</code></pre> <pre><code>&gt;&gt;&gt; logger.track_function(lambda: 42, \"answer\")\n&gt;&gt;&gt; logger.update()\n&gt;&gt;&gt; logger.flush_buffer()\n</code></pre> Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>class Logger(logging.Logger):\n    \"\"\"\n    Represents a custom singleton logger class that extends the built-in Python logger. The logger provides additional\n    functionality for tracking and logging variables to a CSV file. It supports different log levels and log formatting\n    options.\n\n    Args:\n        log_path (str): The path to save log files.\n        log_format (str): The log message format.\n        file_level (LogLevel): The log level for file output.\n        stream_level (LogLevel): The log level for console output.\n        file_max_bytes (int): The maximum size of the log file in bytes before rotation.\n        file_backup_count (int): The number of backup log files to keep.\n        file_name (Union[str, None]): The base name for the log file.\n        buffer_size (int): The maximum number of log entries to buffer before writing to the CSV file.\n        enable_csv_logging (bool): Whether to enable CSV logging.\n\n    Properties:\n        - **file_path**: The path to the log file.\n        - **buffer_size**: The maximum number of log entries to buffer.\n        - **file_level**: The log level for file output.\n        - **stream_level**: The log level for console output.\n        - **file_max_bytes**: The maximum size of the log file in bytes before rotation.\n        - **file_backup_count**: The number of backup log files to keep.\n        - **csv_logging_enabled**: Whether CSV logging is enabled.\n        - **tracked_variable_count**: The number of currently tracked variables.\n\n    Methods:\n        - **track_function**: Track the output of a function for logging.\n        - **track_attributes**: Track the attributes of an object for logging.\n        - **flush_buffer**: Write the buffered log entries to the CSV file.\n        - **reset**: Reset the logger state.\n        - **close**: Close the logger and flush any remaining log entries.\n        - **debug**: Log a debug message.\n        - **info**: Log an info message.\n        - **warning**: Log a warning message.\n        - **error**: Log an error message.\n        - **critical**: Log a critical message.\n        - **log**: Log a message at a specific log level.\n\n    Author:\n    - Senthur Ayyappan &lt;senthura@umich.edu&gt;\n    - Kevin Best &lt;tkbest@umich.edu&gt;\n\n    Examples:\n        &gt;&gt;&gt; logger = Logger()\n        &gt;&gt;&gt; logger.info(\"This is an info message\")\n        [2022-01-01 12:00:00] INFO: This is an info message\n        &gt;&gt;&gt; logger.debug(\"This is a debug message\")\n        [2022-01-01 12:00:00] DEBUG: This is a debug message\n\n        &gt;&gt;&gt; logger.track_function(lambda: 42, \"answer\")\n        &gt;&gt;&gt; logger.update()\n        &gt;&gt;&gt; logger.flush_buffer()\n    \"\"\"\n\n    _instance = None\n    _lock = threading.RLock()  # Reentrant lock for thread safety\n\n    def __new__(cls, *args: Any, **kwargs: Any) -&gt; \"Logger\":\n        \"\"\"\n        Ensure that only one instance of Logger is created (singleton pattern).\n\n        Returns:\n            Logger: The singleton Logger instance.\n        \"\"\"\n        with cls._lock:\n            if cls._instance is None:\n                cls._instance = super().__new__(cls)\n            else:\n                logging.debug(f\"Reusing existing Logger instance: {id(cls._instance)}\")\n        return cls._instance\n\n    def __init__(\n        self,\n        log_path: str = \"./\",\n        log_format: str = \"[%(asctime)s] %(levelname)s: %(message)s\",\n        file_level: LogLevel = LogLevel.DEBUG,\n        stream_level: LogLevel = LogLevel.INFO,\n        file_max_bytes: int = 0,\n        file_backup_count: int = 5,\n        file_name: Union[str, None] = None,\n        buffer_size: int = 1000,\n        enable_csv_logging: bool = True,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the Logger instance.\n\n        Sets up logging paths, format, handler levels, and internal buffers for tracking variables.\n\n        Args:\n            log_path (str): Directory path where log files will be stored.\n            log_format (str): Format string for log messages.\n            file_level (LogLevel): Logging level for file handler.\n            stream_level (LogLevel): Logging level for stream (console) handler.\n            file_max_bytes (int): Maximum size (in bytes) for log file rotation.\n            file_backup_count (int): Number of backup log files to keep.\n            file_name (Union[str, None]): Optional user-specified file name prefix.\n            buffer_size (int): Maximum number of log records to buffer before writing to CSV.\n            enable_csv_logging (bool): Whether to enable CSV logging.\n        \"\"\"\n        with self._lock:\n            if not hasattr(self, \"_initialized\"):\n                super().__init__(__name__)\n                self._log_path = log_path\n                self._log_format = log_format\n                self._file_level = file_level\n                self._stream_level = stream_level\n                self._file_max_bytes = file_max_bytes\n                self._file_backup_count = file_backup_count\n                self._user_file_name = file_name\n                self._enable_csv_logging = enable_csv_logging\n\n                self._file_path: str = \"\"\n                self._csv_path: str = \"\"\n                self._file: Optional[Any] = None\n                self._writer = None\n                self._is_logging = False\n                self._header_written = False\n\n                self._tracked_vars: dict[int, Callable[[], Any]] = {}\n                self._var_names: dict[int, str] = {}\n                self._buffer: deque = deque(maxlen=buffer_size)\n                self._buffer_size: int = buffer_size\n                self._error_count: dict[int, int] = {}  # Track errors per variable\n                self._max_errors_before_untrack: int = 5  # Auto-untrack after this many errors\n\n                try:\n                    self._setup_logging()\n                    self._initialized: bool = True\n                except Exception as e:\n                    print(f\"Error initializing logger: {e}\")\n                    raise\n            else:\n                self.set_file_name(file_name)\n                self.set_file_level(file_level)\n                self.set_stream_level(stream_level)\n                self.set_format(log_format)\n                self._file_max_bytes = file_max_bytes\n                self._file_backup_count = file_backup_count\n                self.set_buffer_size(buffer_size)\n                self._enable_csv_logging = enable_csv_logging\n                self._log_path = log_path\n\n    def _setup_logging(self) -&gt; None:\n        \"\"\"\n        Set up the stream logging handler.\n\n        Configures the logger level, formatter, and attaches a stream handler for console output.\n        \"\"\"\n        with self._lock:\n            if not hasattr(self, \"_stream_handler\"):  # Prevent duplicate handlers\n                self.setLevel(level=self._file_level.value)\n                self._std_formatter = logging.Formatter(self._log_format)\n                self._stream_handler = logging.StreamHandler()\n                self._stream_handler.setLevel(level=self._stream_level.value)\n                self._stream_handler.setFormatter(fmt=self._std_formatter)\n                self.addHandler(hdlr=self._stream_handler)\n\n    def set_stream_terminator(self, terminator: str) -&gt; None:\n        \"\"\"\n        Set the terminator for the stream handler.\n        \"\"\"\n        with self._lock:\n            self._stream_handler.terminator = terminator\n\n    def _setup_file_handler(self) -&gt; None:\n        \"\"\"\n        Set up the file logging handler.\n        \"\"\"\n        with self._lock:\n            if not hasattr(self, \"_file_handler\"):  # Ensure file handler is added only once\n                try:\n                    self._generate_file_paths()\n\n                    self._file_handler = RotatingFileHandler(\n                        filename=self._file_path,\n                        mode=\"w\",\n                        maxBytes=self._file_max_bytes,\n                        backupCount=self._file_backup_count,\n                        encoding=\"utf-8\",\n                    )\n                    self._file_handler.setLevel(level=self._file_level.value)\n                    self._file_handler.setFormatter(fmt=self._std_formatter)\n                    self.addHandler(hdlr=self._file_handler)\n                except Exception as e:\n                    self.error(f\"Failed to set up file handler: {e}\")\n                    # Fall back to console-only logging\n                    self.warning(\"Falling back to console-only logging\")\n\n    def _ensure_file_handler(self) -&gt; None:\n        \"\"\"\n        Ensure that the file handler is set up.\n        \"\"\"\n        with self._lock:\n            if not hasattr(self, \"_file_handler\"):\n                self._setup_file_handler()\n\n    def track_function(\n        self, var_func: Union[Callable[[], Any], list[Callable[[], Any]]], name: Union[str, list[str]]\n    ) -&gt; None:\n        \"\"\"\n        Record the value of returned from a function (or multiple functions) and log it to a CSV file.\n\n        Args:\n            var_func: A function (or list of functions) that returns the value(s) of the variable(s).\n            name: The name (or list of names) of the variable(s).\n\n        Raises:\n            ValueError: If the lengths of `var_func` and `name` lists do not match.\n            TypeError: If `var_func` and `name` are not both single values or lists of equal length.\n\n        Examples:\n            # Single variable tracking\n            &gt;&gt;&gt; class MyClass:\n            ...     def __init__(self):\n            ...         self.value = 42\n            &gt;&gt;&gt; obj = MyClass()\n            &gt;&gt;&gt; LOGGER.track_function(lambda: obj.value, \"value\")\n            &gt;&gt;&gt; LOGGER.update()\n            &gt;&gt;&gt; LOGGER.flush_buffer()\n\n            # Multiple variable tracking\n            &gt;&gt;&gt; class MyClass:\n            ...     def __init__(self):\n            ...         self.value1 = 42\n            ...         self.value2 = 84\n            &gt;&gt;&gt; obj = MyClass()\n            &gt;&gt;&gt; LOGGER.track_function(\n            ...     [lambda: obj.value1, lambda: obj.value2],\n            ...     [\"value1\", \"value2\"]\n            ... )\n            &gt;&gt;&gt; LOGGER.update()\n            &gt;&gt;&gt; LOGGER.flush_buffer()\n            &gt;&gt;&gt; LOGGER.update()\n            &gt;&gt;&gt; LOGGER.flush_buffer()\n        \"\"\"\n        with self._lock:\n            if isinstance(var_func, list) and isinstance(name, list):\n                # Ensure the lengths of var_func and name match\n                if len(var_func) != len(name):\n                    raise ValueError(\"The number of variable functions and names must match.\")\n                for func, var_name in zip(var_func, name):\n                    var_id = id(func)\n                    self._tracked_vars[var_id] = func\n                    self._var_names[var_id] = var_name\n                    self._error_count[var_id] = 0  # Initialize error count\n                    self.debug(f\"Started tracking variable: {var_name}\")\n            elif callable(var_func) and isinstance(name, str):\n                # Single variable tracking\n                func = var_func  # Explicitly narrow the type for mypy\n                var_id = id(func)\n                self._tracked_vars[var_id] = func\n                self._var_names[var_id] = name\n                self._error_count[var_id] = 0  # Initialize error count\n                self.debug(f\"Started tracking variable: {name}\")\n            else:\n                raise TypeError(\n                    \"Invalid input: var_func and name must both be either single values or lists of equal length.\"\n                )\n\n    def get_tracked_variables(self) -&gt; list[tuple[str, Any]]:\n        \"\"\"\n        Get a list of currently tracked variables and their current values.\n\n        Returns:\n            List[Tuple[str, Any]]: A list of tuples containing variable names and their current values.\n        \"\"\"\n        with self._lock:\n            result = []\n            for var_id, get_value in self._tracked_vars.items():\n                name = self._var_names.get(var_id, \"unknown\")\n                try:\n                    value = get_value()\n                    result.append((name, value))\n                except Exception as e:\n                    result.append((name, f\"ERROR: {e}\"))\n            return result\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Return a string representation of the Logger instance.\n\n        Returns:\n            str: A string representation including the current file path and tracked variable count.\n        \"\"\"\n        return f\"Logger(file_path={self._file_path}, tracked_vars={len(self._tracked_vars)})\"\n\n    def set_file_name(self, file_name: Union[str, None]) -&gt; None:\n        \"\"\"\n        Set the base name for the log file.\n\n        Args:\n            file_name: The base name for the log file.\n\n        Examples:\n            &gt;&gt;&gt; LOGGER.set_file_name(\"my_log_file\")\n            &gt;&gt;&gt; LOGGER.file_path\n            \"./my_log_file.log\"\n        \"\"\"\n        with self._lock:\n            try:\n                # Ensure log directory exists\n                os.makedirs(self._log_path, exist_ok=True)\n\n                # Handle None file_name case\n                if file_name is None:\n                    # Generate default name if none provided\n                    now = datetime.now()\n                    timestamp = now.strftime(\"%Y%m%d_%H%M%S\")\n                    script_name = os.path.basename(__file__).split(\".\")[0]\n                    file_name = f\"{script_name}_{timestamp}\"\n                elif \".\" in file_name:\n                    # If filename has an extension, remove it\n                    file_name = file_name.split(\".\")[0]\n\n                self._user_file_name = file_name\n                self._file_path = os.path.join(self._log_path, f\"{file_name}.log\")\n                self._csv_path = os.path.join(self._log_path, f\"{file_name}.csv\")\n\n                # If we already have a file handler, we need to recreate it\n                if hasattr(self, \"_file_handler\"):\n                    self.removeHandler(self._file_handler)\n                    self._file_handler.close()\n                    del self._file_handler\n                    self._setup_file_handler()\n\n                # Reset CSV file if it exists\n                if self._file:\n                    self.close()\n            except Exception as e:\n                self.error(f\"Error setting file name: {e}\")\n                raise\n\n    def set_file_level(self, level: LogLevel) -&gt; None:\n        \"\"\"\n        Set the log level for file output.\n\n        Args:\n            level: The log level for file output.\n\n        Examples:\n            &gt;&gt;&gt; LOGGER.set_file_level(LogLevel.INFO)\n            &gt;&gt;&gt; LOGGER.file_level\n            LogLevel.INFO\n            &gt;&gt;&gt; LOGGER.debug(\"This is a debug message and will not be logged\")\n        \"\"\"\n        with self._lock:\n            self._file_level = level\n            if hasattr(self, \"_file_handler\"):\n                self._file_handler.setLevel(level=level.value)\n\n    def set_stream_level(self, level: LogLevel) -&gt; None:\n        \"\"\"\n        Set the log level for console output.\n\n        Args:\n            level: The log level for console output.\n\n        Examples:\n            &gt;&gt;&gt; LOGGER.set_stream_level(LogLevel.INFO)\n            &gt;&gt;&gt; LOGGER.stream_level\n            LogLevel.INFO\n            &gt;&gt;&gt; LOGGER.debug(\"This is a debug message and will not be streamed\")\n        \"\"\"\n        with self._lock:\n            self._stream_level = level\n            self._stream_handler.setLevel(level=level.value)\n\n    def set_format(self, log_format: str) -&gt; None:\n        \"\"\"\n        Set the log message format. The format string uses the same syntax as the built-in Python logging module.\n\n        Args:\n            log_format: The log message format.\n\n        Examples:\n            &gt;&gt;&gt; LOGGER.set_format(\"[%(asctime)s] %(levelname)s: %(message)s\")\n            &gt;&gt;&gt; LOGGER.info(\"This is an info message\")\n            [2022-01-01 12:00:00] INFO: This is an info message\n        \"\"\"\n        with self._lock:\n            self._log_format = log_format\n            self._std_formatter = logging.Formatter(log_format)\n            if hasattr(self, \"_file_handler\"):\n                self._file_handler.setFormatter(fmt=self._std_formatter)\n            self._stream_handler.setFormatter(fmt=self._std_formatter)\n\n    def set_buffer_size(self, buffer_size: int) -&gt; None:\n        \"\"\"\n        Set the maximum number of log entries to buffer before writing to the CSV file.\n\n        Args:\n            buffer_size: The maximum number of log entries to buffer.\n        \"\"\"\n        with self._lock:\n            if buffer_size &lt;= 0:\n                self.warning(f\"Invalid buffer size: {buffer_size}. Using default of 1000.\")\n                buffer_size = 1000\n            self._buffer_size = buffer_size\n            # Create a new buffer with the updated size and copy over existing items\n            old_buffer = list(self._buffer)\n            self._buffer = deque(maxlen=buffer_size)\n            for item in old_buffer:\n                self._buffer.append(item)\n\n    def set_csv_logging(self, enable: bool) -&gt; None:\n        \"\"\"\n        Enable or disable CSV logging.\n\n        Args:\n            enable (bool): Whether to enable CSV logging.\n        \"\"\"\n        with self._lock:\n            if self._enable_csv_logging != enable:\n                self._enable_csv_logging = enable\n                if not enable:\n                    self.flush_buffer()\n                    if self._file:\n                        self._file.close()\n                        self._file = None\n                        self._writer = None\n                self.debug(f\"CSV logging {'enabled' if enable else 'disabled'}\")\n\n    def set_max_errors_before_untrack(self, max_errors: int) -&gt; None:\n        \"\"\"\n        Set the maximum number of errors before a variable is automatically untracked.\n\n        Args:\n            max_errors (int): Maximum number of errors before untracking.\n        \"\"\"\n        with self._lock:\n            if max_errors &lt; 0:\n                self.warning(f\"Invalid max_errors value: {max_errors}. Using default of 5.\")\n                max_errors = 5\n            self._max_errors_before_untrack = max_errors\n\n    def update(self) -&gt; None:\n        \"\"\"\n        Update the logger by logging the current values of tracked variables to the buffer.\n\n        Examples:\n            &gt;&gt;&gt; class MyClass:\n            ...     def __init__(self):\n            ...         self.value = 42\n            &gt;&gt;&gt; obj = MyClass()\n            &gt;&gt;&gt; LOGGER.track_function(lambda: obj.value, \"answer\")\n            &gt;&gt;&gt; LOGGER.update()\n        \"\"\"\n        if not self._tracked_vars or not self._enable_csv_logging:\n            return\n\n        with self._lock:\n            data = []\n            vars_to_untrack = []\n\n            for var_id, get_value in self._tracked_vars.items():\n                try:\n                    value = get_value()\n                    data.append(str(value))\n                    # Reset error count on successful retrieval\n                    self._error_count[var_id] = 0\n                except Exception as e:\n                    var_name = self._var_names.get(var_id, \"unknown\")\n                    self.warning(f\"Error getting value for {var_name}: {e}\")\n                    data.append(\"ERROR\")\n\n                    # Increment error count and check if we should untrack\n                    self._error_count[var_id] = self._error_count.get(var_id, 0) + 1\n                    if self._error_count[var_id] &gt;= self._max_errors_before_untrack:\n                        vars_to_untrack.append((var_id, var_name))\n\n            # Only add data if we have variables to track\n            if data:\n                self._buffer.append(data)\n\n            # Untrack variables with too many errors\n            for var_id, var_name in vars_to_untrack:\n                self._tracked_vars.pop(var_id, None)\n                self._var_names.pop(var_id, None)\n                self._error_count.pop(var_id, None)\n                self.warning(\n                    f\"Auto-untracked variable {var_name} after {self._max_errors_before_untrack} consecutive errors\"\n                )\n\n            if len(self._buffer) &gt;= self._buffer_size:\n                self.flush_buffer()\n\n    def flush_buffer(self) -&gt; None:\n        \"\"\"\n        Flush the buffered log data to the CSV file.\n\n        Ensures that the file handler is available, writes the header if not yet written,\n        writes all buffered rows to the CSV, clears the buffer, and flushes the file.\n        \"\"\"\n        if not self._buffer or not self._enable_csv_logging:\n            return\n\n        with self._lock:\n            try:\n                self._ensure_file_handler()\n\n                if self._file is None:\n                    try:\n                        self._file = open(self._csv_path, \"w\", newline=\"\")\n                        self._writer = csv.writer(self._file)  # type: ignore[assignment]\n                    except Exception as e:\n                        self.error(f\"Failed to open CSV file {self._csv_path}: {e}\")\n                        # Clear buffer to prevent memory buildup\n                        self._buffer.clear()\n                        return\n\n                if not self._header_written:\n                    self._write_header()\n\n                try:\n                    self._writer.writerows(self._buffer)  # type: ignore[attr-defined]\n                    self._buffer.clear()\n                    self._file.flush()\n                except Exception as e:\n                    self.error(f\"Failed to write to CSV file: {e}\")\n                    # Try to recover by reopening the file\n                    if self._file:\n                        with contextlib.suppress(Exception):\n                            self._file.close()\n                    self._file = None\n                    self._writer = None\n                    self._header_written = False\n            except Exception as e:\n                self.error(f\"Unexpected error in flush_buffer: {e}\")\n\n    def _write_header(self) -&gt; None:\n        \"\"\"\n        Write the CSV header based on tracked variable names.\n        This header is written only once per log file.\n        \"\"\"\n        try:\n            header = list(self._var_names.values())\n            if header:  # Only write header if we have variables\n                self._writer.writerow(header)  # type: ignore[attr-defined]\n                self._header_written = True\n        except Exception as e:\n            self.error(f\"Failed to write CSV header: {e}\")\n\n    def _generate_file_paths(self) -&gt; None:\n        \"\"\"\n        Generate file paths for the log and CSV files based on the current settings.\n\n        Creates the log directory if it does not exist, and uses the current timestamp\n        (and optionally a user-specified name) to generate unique file names.\n        \"\"\"\n        try:\n            # Ensure log directory exists\n            os.makedirs(self._log_path, exist_ok=True)\n\n            now = datetime.now()\n            timestamp = now.strftime(\"%Y%m%d_%H%M%S\")\n            script_name = os.path.basename(__file__).split(\".\")[0]\n\n            base_name = self._user_file_name if self._user_file_name else f\"{script_name}_{timestamp}\"\n\n            file_path = os.path.join(self._log_path, base_name)\n            self._file_path = file_path + \".log\"\n            self._csv_path = file_path + \".csv\"\n        except Exception as e:\n            print(f\"Error generating file paths: {e}\")  # Use print as logger might not be ready\n            raise\n\n    def __del__(self) -&gt; None:\n        \"\"\"\n        Destructor for the Logger class.\n        \"\"\"\n        self.close()\n\n    def __enter__(self) -&gt; \"Logger\":\n        \"\"\"\n        Enter the runtime context related to this Logger instance.\n\n        Returns:\n            Logger: The current Logger instance.\n        \"\"\"\n        return self\n\n    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -&gt; None:\n        \"\"\"\n        Exit the runtime context and close the Logger.\n\n        Args:\n            exc_type (Any): The exception type if an exception occurred.\n            exc_val (Any): The exception value if an exception occurred.\n            exc_tb (Any): The traceback if an exception occurred.\n        \"\"\"\n        self.close()\n\n    def reset(self) -&gt; None:\n        \"\"\"\n        Reset the Logger.\n\n        Closes the current file, reinitializes the logging handlers, clears tracked variables,\n        and resets header status.\n        \"\"\"\n        with self._lock:\n            try:\n                self.close()\n\n                # Remove and clean up handlers\n                if hasattr(self, \"_file_handler\"):\n                    self.removeHandler(self._file_handler)\n                    self._file_handler.close()\n                    del self._file_handler\n\n                if hasattr(self, \"_stream_handler\"):\n                    self.removeHandler(self._stream_handler)\n                    self._stream_handler.close()  # Close the stream handler\n                    del self._stream_handler  # Delete the attribute\n\n                # Reinitialize logging\n                self._setup_logging()\n\n                # Reset tracking and state variables\n                self._tracked_vars.clear()\n                self._var_names.clear()\n                self._error_count.clear()\n                self._header_written = False\n                self._file = None\n                self._writer = None\n\n                self.debug(\"Logger reset successfully\")\n            except Exception as e:\n                print(f\"Error resetting logger: {e}\")  # Use print as logger might be in bad state\n\n    def close(self) -&gt; None:\n        \"\"\"\n        Flush any buffered log data and close the CSV file.\n\n        This method should be called before the program exits to ensure all data is written.\n        Close the logger and flush any remaining log entries.\n\n        Examples:\n            &gt;&gt;&gt; LOGGER.close()\n            &gt;&gt;&gt; LOGGER.info(\"This message will not be logged\")\n        \"\"\"\n        with self._lock:\n            try:\n                self.flush_buffer()\n                if self._file:\n                    self._file.close()\n                    self._file = None\n                    self._writer = None\n            except Exception as e:\n                self.error(f\"Error closing logger: {e}\")\n\n    def debug(self, msg: object, *args: object, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Log a debug message.\n\n        Ensures that the file handler is set up before logging.\n\n        Args:\n            msg (object): The message to log.\n            *args (object): Additional arguments.\n            **kwargs (Any): Additional keyword arguments.\n        \"\"\"\n        self._ensure_file_handler()\n        super().debug(msg, *args, **kwargs)\n\n    def info(self, msg: object, *args: object, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Log an info message.\n\n        Ensures that the file handler is set up before logging.\n\n        Args:\n            msg (object): The message to log.\n            *args (object): Additional arguments.\n            **kwargs (Any): Additional keyword arguments.\n        \"\"\"\n        self._ensure_file_handler()\n        super().info(msg, *args, **kwargs)\n\n    def warning(self, msg: object, *args: object, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Log a warning message.\n\n        Ensures that the file handler is set up before logging.\n\n        Args:\n            msg (object): The message to log.\n            *args (object): Additional arguments.\n            **kwargs (Any): Additional keyword arguments.\n        \"\"\"\n        self._ensure_file_handler()\n        super().warning(msg, *args, **kwargs)\n\n    def error(self, msg: object, *args: object, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Log an error message.\n\n        Ensures that the file handler is set up before logging.\n\n        Args:\n            msg (object): The message to log.\n            *args (object): Additional arguments.\n            **kwargs (Any): Additional keyword arguments.\n        \"\"\"\n        self._ensure_file_handler()\n        super().error(msg, *args, **kwargs)\n\n    def critical(self, msg: object, *args: object, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Log a critical message.\n\n        Ensures that the file handler is set up before logging.\n\n        Args:\n            msg (object): The message to log.\n            *args (object): Additional arguments.\n            **kwargs (Any): Additional keyword arguments.\n        \"\"\"\n        self._ensure_file_handler()\n        super().critical(msg, *args, **kwargs)\n\n    def log(self, level: int, msg: object, *args: object, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Log a message with a specific log level.\n\n        Ensures that the file handler is set up before logging.\n\n        Args:\n            level (int): The log level.\n            msg (object): The message to log.\n            *args (object): Additional arguments.\n            **kwargs (Any): Additional keyword arguments.\n        \"\"\"\n        self._ensure_file_handler()\n        super().log(level, msg, *args, **kwargs)\n\n    def track_attributes(self, obj: Any, attributes: Union[str, list[str]]) -&gt; None:\n        \"\"\"\n        Track one or more attributes in an object and log their values to a CSV file.\n\n        Args:\n            obj: The object whose attributes are to be tracked.\n            attributes: A single attribute name (str) or a list of attribute names (list[str]) to track.\n\n        Raises:\n            AttributeError: If any attribute in the list does not exist in the object.\n\n        Examples:\n            &gt;&gt;&gt; class MyClass:\n            ...     def __init__(self):\n            ...         self.value1 = 42\n            ...         self.value2 = 84\n            &gt;&gt;&gt; obj = MyClass()\n            &gt;&gt;&gt; LOGGER.track_attributes(obj, \"value1\")  # Single attribute\n            &gt;&gt;&gt; LOGGER.track_attributes(obj, [\"value1\", \"value2\"])  # Multiple attributes\n            &gt;&gt;&gt; LOGGER.update()\n            &gt;&gt;&gt; LOGGER.flush_buffer()\n        \"\"\"\n        with self._lock:\n            if isinstance(attributes, str):\n                attributes = [attributes]  # Convert single attribute to a list\n\n            obj_str = str(obj)  # Use str(obj) for a user-friendly representation\n            var_funcs = []\n            prefixed_attributes = [f\"{obj_str}.{attr}\" for attr in attributes]  # Prepend str(obj)\n\n            def create_getter(obj: Any, attr: str) -&gt; Callable[[], Any]:\n                \"\"\"Helper function to create a getter for an attribute.\"\"\"\n                return lambda: getattr(obj, attr)\n\n            for attr in attributes:\n                if not hasattr(obj, attr):\n                    raise AttributeError(f\"Object {obj} does not have attribute '{attr}'\")\n                # Use the helper function to create the lambda\n                var_funcs.append(create_getter(obj, attr))\n\n            # Call track_function with the generated functions and prefixed attribute names\n            self.track_function(var_funcs, prefixed_attributes)\n\n    @property\n    def file_path(self) -&gt; Optional[str]:\n        \"\"\"\n        Get the current file path for the log file.\n\n        Returns:\n            Optional[str]: The file path as a string, or None if not set.\n        \"\"\"\n        return self._file_path\n\n    @property\n    def csv_path(self) -&gt; Optional[str]:\n        \"\"\"\n        Get the current file path for the CSV file.\n\n        Returns:\n            Optional[str]: The CSV file path as a string, or None if not set.\n        \"\"\"\n        return self._csv_path\n\n    @property\n    def log_path(self) -&gt; str:\n        \"\"\"\n        Get the log directory path.\n\n        Returns:\n            str: The directory path where log files are stored.\n        \"\"\"\n        return self._log_path\n\n    @property\n    def buffer_size(self) -&gt; int:\n        \"\"\"\n        Get the current buffer size.\n\n        Returns:\n            int: The maximum number of log records held in the buffer.\n        \"\"\"\n        return self._buffer_size\n\n    @property\n    def file_level(self) -&gt; LogLevel:\n        \"\"\"\n        Get the current file logging level.\n\n        Returns:\n            LogLevel: The logging level for the file handler.\n        \"\"\"\n        return self._file_level\n\n    @property\n    def stream_level(self) -&gt; LogLevel:\n        \"\"\"\n        Get the current stream (console) logging level.\n\n        Returns:\n            LogLevel: The logging level for the stream handler.\n        \"\"\"\n        return self._stream_level\n\n    @property\n    def file_max_bytes(self) -&gt; int:\n        \"\"\"\n        Get the maximum number of bytes for the log file before rotation.\n\n        Returns:\n            int: The maximum file size in bytes.\n        \"\"\"\n        return self._file_max_bytes\n\n    @property\n    def file_backup_count(self) -&gt; int:\n        \"\"\"\n        Get the number of backup log files to keep.\n\n        Returns:\n            int: The backup count.\n        \"\"\"\n        return self._file_backup_count\n\n    @property\n    def csv_logging_enabled(self) -&gt; bool:\n        \"\"\"\n        Get whether CSV logging is enabled.\n\n        Returns:\n            bool: Whether CSV logging is enabled.\n        \"\"\"\n        return self._enable_csv_logging\n\n    @property\n    def tracked_variable_count(self) -&gt; int:\n        \"\"\"\n        Get the number of currently tracked variables.\n\n        Returns:\n            int: The number of tracked variables.\n        \"\"\"\n        return len(self._tracked_vars)\n</code></pre>"},{"location":"api/logging/#opensourceleg.logging.Logger.buffer_size","title":"<code>buffer_size</code>  <code>property</code>","text":"<p>Get the current buffer size.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The maximum number of log records held in the buffer.</p>"},{"location":"api/logging/#opensourceleg.logging.Logger.csv_logging_enabled","title":"<code>csv_logging_enabled</code>  <code>property</code>","text":"<p>Get whether CSV logging is enabled.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether CSV logging is enabled.</p>"},{"location":"api/logging/#opensourceleg.logging.Logger.csv_path","title":"<code>csv_path</code>  <code>property</code>","text":"<p>Get the current file path for the CSV file.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The CSV file path as a string, or None if not set.</p>"},{"location":"api/logging/#opensourceleg.logging.Logger.file_backup_count","title":"<code>file_backup_count</code>  <code>property</code>","text":"<p>Get the number of backup log files to keep.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The backup count.</p>"},{"location":"api/logging/#opensourceleg.logging.Logger.file_level","title":"<code>file_level</code>  <code>property</code>","text":"<p>Get the current file logging level.</p> <p>Returns:</p> Name Type Description <code>LogLevel</code> <code>LogLevel</code> <p>The logging level for the file handler.</p>"},{"location":"api/logging/#opensourceleg.logging.Logger.file_max_bytes","title":"<code>file_max_bytes</code>  <code>property</code>","text":"<p>Get the maximum number of bytes for the log file before rotation.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The maximum file size in bytes.</p>"},{"location":"api/logging/#opensourceleg.logging.Logger.file_path","title":"<code>file_path</code>  <code>property</code>","text":"<p>Get the current file path for the log file.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The file path as a string, or None if not set.</p>"},{"location":"api/logging/#opensourceleg.logging.Logger.log_path","title":"<code>log_path</code>  <code>property</code>","text":"<p>Get the log directory path.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The directory path where log files are stored.</p>"},{"location":"api/logging/#opensourceleg.logging.Logger.stream_level","title":"<code>stream_level</code>  <code>property</code>","text":"<p>Get the current stream (console) logging level.</p> <p>Returns:</p> Name Type Description <code>LogLevel</code> <code>LogLevel</code> <p>The logging level for the stream handler.</p>"},{"location":"api/logging/#opensourceleg.logging.Logger.tracked_variable_count","title":"<code>tracked_variable_count</code>  <code>property</code>","text":"<p>Get the number of currently tracked variables.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of tracked variables.</p>"},{"location":"api/logging/#opensourceleg.logging.Logger.__del__","title":"<code>__del__()</code>","text":"<p>Destructor for the Logger class.</p> Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def __del__(self) -&gt; None:\n    \"\"\"\n    Destructor for the Logger class.\n    \"\"\"\n    self.close()\n</code></pre>"},{"location":"api/logging/#opensourceleg.logging.Logger.__enter__","title":"<code>__enter__()</code>","text":"<p>Enter the runtime context related to this Logger instance.</p> <p>Returns:</p> Name Type Description <code>Logger</code> <code>Logger</code> <p>The current Logger instance.</p> Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def __enter__(self) -&gt; \"Logger\":\n    \"\"\"\n    Enter the runtime context related to this Logger instance.\n\n    Returns:\n        Logger: The current Logger instance.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"api/logging/#opensourceleg.logging.Logger.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Exit the runtime context and close the Logger.</p> <p>Parameters:</p> Name Type Description Default <code>exc_type</code> <code>Any</code> <p>The exception type if an exception occurred.</p> required <code>exc_val</code> <code>Any</code> <p>The exception value if an exception occurred.</p> required <code>exc_tb</code> <code>Any</code> <p>The traceback if an exception occurred.</p> required Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -&gt; None:\n    \"\"\"\n    Exit the runtime context and close the Logger.\n\n    Args:\n        exc_type (Any): The exception type if an exception occurred.\n        exc_val (Any): The exception value if an exception occurred.\n        exc_tb (Any): The traceback if an exception occurred.\n    \"\"\"\n    self.close()\n</code></pre>"},{"location":"api/logging/#opensourceleg.logging.Logger.__init__","title":"<code>__init__(log_path='./', log_format='[%(asctime)s] %(levelname)s: %(message)s', file_level=LogLevel.DEBUG, stream_level=LogLevel.INFO, file_max_bytes=0, file_backup_count=5, file_name=None, buffer_size=1000, enable_csv_logging=True)</code>","text":"<p>Initialize the Logger instance.</p> <p>Sets up logging paths, format, handler levels, and internal buffers for tracking variables.</p> <p>Parameters:</p> Name Type Description Default <code>log_path</code> <code>str</code> <p>Directory path where log files will be stored.</p> <code>'./'</code> <code>log_format</code> <code>str</code> <p>Format string for log messages.</p> <code>'[%(asctime)s] %(levelname)s: %(message)s'</code> <code>file_level</code> <code>LogLevel</code> <p>Logging level for file handler.</p> <code>DEBUG</code> <code>stream_level</code> <code>LogLevel</code> <p>Logging level for stream (console) handler.</p> <code>INFO</code> <code>file_max_bytes</code> <code>int</code> <p>Maximum size (in bytes) for log file rotation.</p> <code>0</code> <code>file_backup_count</code> <code>int</code> <p>Number of backup log files to keep.</p> <code>5</code> <code>file_name</code> <code>Union[str, None]</code> <p>Optional user-specified file name prefix.</p> <code>None</code> <code>buffer_size</code> <code>int</code> <p>Maximum number of log records to buffer before writing to CSV.</p> <code>1000</code> <code>enable_csv_logging</code> <code>bool</code> <p>Whether to enable CSV logging.</p> <code>True</code> Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def __init__(\n    self,\n    log_path: str = \"./\",\n    log_format: str = \"[%(asctime)s] %(levelname)s: %(message)s\",\n    file_level: LogLevel = LogLevel.DEBUG,\n    stream_level: LogLevel = LogLevel.INFO,\n    file_max_bytes: int = 0,\n    file_backup_count: int = 5,\n    file_name: Union[str, None] = None,\n    buffer_size: int = 1000,\n    enable_csv_logging: bool = True,\n) -&gt; None:\n    \"\"\"\n    Initialize the Logger instance.\n\n    Sets up logging paths, format, handler levels, and internal buffers for tracking variables.\n\n    Args:\n        log_path (str): Directory path where log files will be stored.\n        log_format (str): Format string for log messages.\n        file_level (LogLevel): Logging level for file handler.\n        stream_level (LogLevel): Logging level for stream (console) handler.\n        file_max_bytes (int): Maximum size (in bytes) for log file rotation.\n        file_backup_count (int): Number of backup log files to keep.\n        file_name (Union[str, None]): Optional user-specified file name prefix.\n        buffer_size (int): Maximum number of log records to buffer before writing to CSV.\n        enable_csv_logging (bool): Whether to enable CSV logging.\n    \"\"\"\n    with self._lock:\n        if not hasattr(self, \"_initialized\"):\n            super().__init__(__name__)\n            self._log_path = log_path\n            self._log_format = log_format\n            self._file_level = file_level\n            self._stream_level = stream_level\n            self._file_max_bytes = file_max_bytes\n            self._file_backup_count = file_backup_count\n            self._user_file_name = file_name\n            self._enable_csv_logging = enable_csv_logging\n\n            self._file_path: str = \"\"\n            self._csv_path: str = \"\"\n            self._file: Optional[Any] = None\n            self._writer = None\n            self._is_logging = False\n            self._header_written = False\n\n            self._tracked_vars: dict[int, Callable[[], Any]] = {}\n            self._var_names: dict[int, str] = {}\n            self._buffer: deque = deque(maxlen=buffer_size)\n            self._buffer_size: int = buffer_size\n            self._error_count: dict[int, int] = {}  # Track errors per variable\n            self._max_errors_before_untrack: int = 5  # Auto-untrack after this many errors\n\n            try:\n                self._setup_logging()\n                self._initialized: bool = True\n            except Exception as e:\n                print(f\"Error initializing logger: {e}\")\n                raise\n        else:\n            self.set_file_name(file_name)\n            self.set_file_level(file_level)\n            self.set_stream_level(stream_level)\n            self.set_format(log_format)\n            self._file_max_bytes = file_max_bytes\n            self._file_backup_count = file_backup_count\n            self.set_buffer_size(buffer_size)\n            self._enable_csv_logging = enable_csv_logging\n            self._log_path = log_path\n</code></pre>"},{"location":"api/logging/#opensourceleg.logging.Logger.__new__","title":"<code>__new__(*args, **kwargs)</code>","text":"<p>Ensure that only one instance of Logger is created (singleton pattern).</p> <p>Returns:</p> Name Type Description <code>Logger</code> <code>Logger</code> <p>The singleton Logger instance.</p> Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def __new__(cls, *args: Any, **kwargs: Any) -&gt; \"Logger\":\n    \"\"\"\n    Ensure that only one instance of Logger is created (singleton pattern).\n\n    Returns:\n        Logger: The singleton Logger instance.\n    \"\"\"\n    with cls._lock:\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n        else:\n            logging.debug(f\"Reusing existing Logger instance: {id(cls._instance)}\")\n    return cls._instance\n</code></pre>"},{"location":"api/logging/#opensourceleg.logging.Logger.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the Logger instance.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string representation including the current file path and tracked variable count.</p> Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Return a string representation of the Logger instance.\n\n    Returns:\n        str: A string representation including the current file path and tracked variable count.\n    \"\"\"\n    return f\"Logger(file_path={self._file_path}, tracked_vars={len(self._tracked_vars)})\"\n</code></pre>"},{"location":"api/logging/#opensourceleg.logging.Logger.close","title":"<code>close()</code>","text":"<p>Flush any buffered log data and close the CSV file.</p> <p>This method should be called before the program exits to ensure all data is written. Close the logger and flush any remaining log entries.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; LOGGER.close()\n&gt;&gt;&gt; LOGGER.info(\"This message will not be logged\")\n</code></pre> Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"\n    Flush any buffered log data and close the CSV file.\n\n    This method should be called before the program exits to ensure all data is written.\n    Close the logger and flush any remaining log entries.\n\n    Examples:\n        &gt;&gt;&gt; LOGGER.close()\n        &gt;&gt;&gt; LOGGER.info(\"This message will not be logged\")\n    \"\"\"\n    with self._lock:\n        try:\n            self.flush_buffer()\n            if self._file:\n                self._file.close()\n                self._file = None\n                self._writer = None\n        except Exception as e:\n            self.error(f\"Error closing logger: {e}\")\n</code></pre>"},{"location":"api/logging/#opensourceleg.logging.Logger.critical","title":"<code>critical(msg, *args, **kwargs)</code>","text":"<p>Log a critical message.</p> <p>Ensures that the file handler is set up before logging.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>object</code> <p>The message to log.</p> required <code>*args</code> <code>object</code> <p>Additional arguments.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def critical(self, msg: object, *args: object, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Log a critical message.\n\n    Ensures that the file handler is set up before logging.\n\n    Args:\n        msg (object): The message to log.\n        *args (object): Additional arguments.\n        **kwargs (Any): Additional keyword arguments.\n    \"\"\"\n    self._ensure_file_handler()\n    super().critical(msg, *args, **kwargs)\n</code></pre>"},{"location":"api/logging/#opensourceleg.logging.Logger.debug","title":"<code>debug(msg, *args, **kwargs)</code>","text":"<p>Log a debug message.</p> <p>Ensures that the file handler is set up before logging.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>object</code> <p>The message to log.</p> required <code>*args</code> <code>object</code> <p>Additional arguments.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def debug(self, msg: object, *args: object, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Log a debug message.\n\n    Ensures that the file handler is set up before logging.\n\n    Args:\n        msg (object): The message to log.\n        *args (object): Additional arguments.\n        **kwargs (Any): Additional keyword arguments.\n    \"\"\"\n    self._ensure_file_handler()\n    super().debug(msg, *args, **kwargs)\n</code></pre>"},{"location":"api/logging/#opensourceleg.logging.Logger.error","title":"<code>error(msg, *args, **kwargs)</code>","text":"<p>Log an error message.</p> <p>Ensures that the file handler is set up before logging.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>object</code> <p>The message to log.</p> required <code>*args</code> <code>object</code> <p>Additional arguments.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def error(self, msg: object, *args: object, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Log an error message.\n\n    Ensures that the file handler is set up before logging.\n\n    Args:\n        msg (object): The message to log.\n        *args (object): Additional arguments.\n        **kwargs (Any): Additional keyword arguments.\n    \"\"\"\n    self._ensure_file_handler()\n    super().error(msg, *args, **kwargs)\n</code></pre>"},{"location":"api/logging/#opensourceleg.logging.Logger.flush_buffer","title":"<code>flush_buffer()</code>","text":"<p>Flush the buffered log data to the CSV file.</p> <p>Ensures that the file handler is available, writes the header if not yet written, writes all buffered rows to the CSV, clears the buffer, and flushes the file.</p> Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def flush_buffer(self) -&gt; None:\n    \"\"\"\n    Flush the buffered log data to the CSV file.\n\n    Ensures that the file handler is available, writes the header if not yet written,\n    writes all buffered rows to the CSV, clears the buffer, and flushes the file.\n    \"\"\"\n    if not self._buffer or not self._enable_csv_logging:\n        return\n\n    with self._lock:\n        try:\n            self._ensure_file_handler()\n\n            if self._file is None:\n                try:\n                    self._file = open(self._csv_path, \"w\", newline=\"\")\n                    self._writer = csv.writer(self._file)  # type: ignore[assignment]\n                except Exception as e:\n                    self.error(f\"Failed to open CSV file {self._csv_path}: {e}\")\n                    # Clear buffer to prevent memory buildup\n                    self._buffer.clear()\n                    return\n\n            if not self._header_written:\n                self._write_header()\n\n            try:\n                self._writer.writerows(self._buffer)  # type: ignore[attr-defined]\n                self._buffer.clear()\n                self._file.flush()\n            except Exception as e:\n                self.error(f\"Failed to write to CSV file: {e}\")\n                # Try to recover by reopening the file\n                if self._file:\n                    with contextlib.suppress(Exception):\n                        self._file.close()\n                self._file = None\n                self._writer = None\n                self._header_written = False\n        except Exception as e:\n            self.error(f\"Unexpected error in flush_buffer: {e}\")\n</code></pre>"},{"location":"api/logging/#opensourceleg.logging.Logger.get_tracked_variables","title":"<code>get_tracked_variables()</code>","text":"<p>Get a list of currently tracked variables and their current values.</p> <p>Returns:</p> Type Description <code>list[tuple[str, Any]]</code> <p>List[Tuple[str, Any]]: A list of tuples containing variable names and their current values.</p> Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def get_tracked_variables(self) -&gt; list[tuple[str, Any]]:\n    \"\"\"\n    Get a list of currently tracked variables and their current values.\n\n    Returns:\n        List[Tuple[str, Any]]: A list of tuples containing variable names and their current values.\n    \"\"\"\n    with self._lock:\n        result = []\n        for var_id, get_value in self._tracked_vars.items():\n            name = self._var_names.get(var_id, \"unknown\")\n            try:\n                value = get_value()\n                result.append((name, value))\n            except Exception as e:\n                result.append((name, f\"ERROR: {e}\"))\n        return result\n</code></pre>"},{"location":"api/logging/#opensourceleg.logging.Logger.info","title":"<code>info(msg, *args, **kwargs)</code>","text":"<p>Log an info message.</p> <p>Ensures that the file handler is set up before logging.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>object</code> <p>The message to log.</p> required <code>*args</code> <code>object</code> <p>Additional arguments.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def info(self, msg: object, *args: object, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Log an info message.\n\n    Ensures that the file handler is set up before logging.\n\n    Args:\n        msg (object): The message to log.\n        *args (object): Additional arguments.\n        **kwargs (Any): Additional keyword arguments.\n    \"\"\"\n    self._ensure_file_handler()\n    super().info(msg, *args, **kwargs)\n</code></pre>"},{"location":"api/logging/#opensourceleg.logging.Logger.log","title":"<code>log(level, msg, *args, **kwargs)</code>","text":"<p>Log a message with a specific log level.</p> <p>Ensures that the file handler is set up before logging.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int</code> <p>The log level.</p> required <code>msg</code> <code>object</code> <p>The message to log.</p> required <code>*args</code> <code>object</code> <p>Additional arguments.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def log(self, level: int, msg: object, *args: object, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Log a message with a specific log level.\n\n    Ensures that the file handler is set up before logging.\n\n    Args:\n        level (int): The log level.\n        msg (object): The message to log.\n        *args (object): Additional arguments.\n        **kwargs (Any): Additional keyword arguments.\n    \"\"\"\n    self._ensure_file_handler()\n    super().log(level, msg, *args, **kwargs)\n</code></pre>"},{"location":"api/logging/#opensourceleg.logging.Logger.reset","title":"<code>reset()</code>","text":"<p>Reset the Logger.</p> <p>Closes the current file, reinitializes the logging handlers, clears tracked variables, and resets header status.</p> Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"\n    Reset the Logger.\n\n    Closes the current file, reinitializes the logging handlers, clears tracked variables,\n    and resets header status.\n    \"\"\"\n    with self._lock:\n        try:\n            self.close()\n\n            # Remove and clean up handlers\n            if hasattr(self, \"_file_handler\"):\n                self.removeHandler(self._file_handler)\n                self._file_handler.close()\n                del self._file_handler\n\n            if hasattr(self, \"_stream_handler\"):\n                self.removeHandler(self._stream_handler)\n                self._stream_handler.close()  # Close the stream handler\n                del self._stream_handler  # Delete the attribute\n\n            # Reinitialize logging\n            self._setup_logging()\n\n            # Reset tracking and state variables\n            self._tracked_vars.clear()\n            self._var_names.clear()\n            self._error_count.clear()\n            self._header_written = False\n            self._file = None\n            self._writer = None\n\n            self.debug(\"Logger reset successfully\")\n        except Exception as e:\n            print(f\"Error resetting logger: {e}\")  # Use print as logger might be in bad state\n</code></pre>"},{"location":"api/logging/#opensourceleg.logging.Logger.set_buffer_size","title":"<code>set_buffer_size(buffer_size)</code>","text":"<p>Set the maximum number of log entries to buffer before writing to the CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>buffer_size</code> <code>int</code> <p>The maximum number of log entries to buffer.</p> required Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def set_buffer_size(self, buffer_size: int) -&gt; None:\n    \"\"\"\n    Set the maximum number of log entries to buffer before writing to the CSV file.\n\n    Args:\n        buffer_size: The maximum number of log entries to buffer.\n    \"\"\"\n    with self._lock:\n        if buffer_size &lt;= 0:\n            self.warning(f\"Invalid buffer size: {buffer_size}. Using default of 1000.\")\n            buffer_size = 1000\n        self._buffer_size = buffer_size\n        # Create a new buffer with the updated size and copy over existing items\n        old_buffer = list(self._buffer)\n        self._buffer = deque(maxlen=buffer_size)\n        for item in old_buffer:\n            self._buffer.append(item)\n</code></pre>"},{"location":"api/logging/#opensourceleg.logging.Logger.set_csv_logging","title":"<code>set_csv_logging(enable)</code>","text":"<p>Enable or disable CSV logging.</p> <p>Parameters:</p> Name Type Description Default <code>enable</code> <code>bool</code> <p>Whether to enable CSV logging.</p> required Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def set_csv_logging(self, enable: bool) -&gt; None:\n    \"\"\"\n    Enable or disable CSV logging.\n\n    Args:\n        enable (bool): Whether to enable CSV logging.\n    \"\"\"\n    with self._lock:\n        if self._enable_csv_logging != enable:\n            self._enable_csv_logging = enable\n            if not enable:\n                self.flush_buffer()\n                if self._file:\n                    self._file.close()\n                    self._file = None\n                    self._writer = None\n            self.debug(f\"CSV logging {'enabled' if enable else 'disabled'}\")\n</code></pre>"},{"location":"api/logging/#opensourceleg.logging.Logger.set_file_level","title":"<code>set_file_level(level)</code>","text":"<p>Set the log level for file output.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>LogLevel</code> <p>The log level for file output.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; LOGGER.set_file_level(LogLevel.INFO)\n&gt;&gt;&gt; LOGGER.file_level\nLogLevel.INFO\n&gt;&gt;&gt; LOGGER.debug(\"This is a debug message and will not be logged\")\n</code></pre> Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def set_file_level(self, level: LogLevel) -&gt; None:\n    \"\"\"\n    Set the log level for file output.\n\n    Args:\n        level: The log level for file output.\n\n    Examples:\n        &gt;&gt;&gt; LOGGER.set_file_level(LogLevel.INFO)\n        &gt;&gt;&gt; LOGGER.file_level\n        LogLevel.INFO\n        &gt;&gt;&gt; LOGGER.debug(\"This is a debug message and will not be logged\")\n    \"\"\"\n    with self._lock:\n        self._file_level = level\n        if hasattr(self, \"_file_handler\"):\n            self._file_handler.setLevel(level=level.value)\n</code></pre>"},{"location":"api/logging/#opensourceleg.logging.Logger.set_file_name","title":"<code>set_file_name(file_name)</code>","text":"<p>Set the base name for the log file.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>Union[str, None]</code> <p>The base name for the log file.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; LOGGER.set_file_name(\"my_log_file\")\n&gt;&gt;&gt; LOGGER.file_path\n\"./my_log_file.log\"\n</code></pre> Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def set_file_name(self, file_name: Union[str, None]) -&gt; None:\n    \"\"\"\n    Set the base name for the log file.\n\n    Args:\n        file_name: The base name for the log file.\n\n    Examples:\n        &gt;&gt;&gt; LOGGER.set_file_name(\"my_log_file\")\n        &gt;&gt;&gt; LOGGER.file_path\n        \"./my_log_file.log\"\n    \"\"\"\n    with self._lock:\n        try:\n            # Ensure log directory exists\n            os.makedirs(self._log_path, exist_ok=True)\n\n            # Handle None file_name case\n            if file_name is None:\n                # Generate default name if none provided\n                now = datetime.now()\n                timestamp = now.strftime(\"%Y%m%d_%H%M%S\")\n                script_name = os.path.basename(__file__).split(\".\")[0]\n                file_name = f\"{script_name}_{timestamp}\"\n            elif \".\" in file_name:\n                # If filename has an extension, remove it\n                file_name = file_name.split(\".\")[0]\n\n            self._user_file_name = file_name\n            self._file_path = os.path.join(self._log_path, f\"{file_name}.log\")\n            self._csv_path = os.path.join(self._log_path, f\"{file_name}.csv\")\n\n            # If we already have a file handler, we need to recreate it\n            if hasattr(self, \"_file_handler\"):\n                self.removeHandler(self._file_handler)\n                self._file_handler.close()\n                del self._file_handler\n                self._setup_file_handler()\n\n            # Reset CSV file if it exists\n            if self._file:\n                self.close()\n        except Exception as e:\n            self.error(f\"Error setting file name: {e}\")\n            raise\n</code></pre>"},{"location":"api/logging/#opensourceleg.logging.Logger.set_format","title":"<code>set_format(log_format)</code>","text":"<p>Set the log message format. The format string uses the same syntax as the built-in Python logging module.</p> <p>Parameters:</p> Name Type Description Default <code>log_format</code> <code>str</code> <p>The log message format.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; LOGGER.set_format(\"[%(asctime)s] %(levelname)s: %(message)s\")\n&gt;&gt;&gt; LOGGER.info(\"This is an info message\")\n[2022-01-01 12:00:00] INFO: This is an info message\n</code></pre> Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def set_format(self, log_format: str) -&gt; None:\n    \"\"\"\n    Set the log message format. The format string uses the same syntax as the built-in Python logging module.\n\n    Args:\n        log_format: The log message format.\n\n    Examples:\n        &gt;&gt;&gt; LOGGER.set_format(\"[%(asctime)s] %(levelname)s: %(message)s\")\n        &gt;&gt;&gt; LOGGER.info(\"This is an info message\")\n        [2022-01-01 12:00:00] INFO: This is an info message\n    \"\"\"\n    with self._lock:\n        self._log_format = log_format\n        self._std_formatter = logging.Formatter(log_format)\n        if hasattr(self, \"_file_handler\"):\n            self._file_handler.setFormatter(fmt=self._std_formatter)\n        self._stream_handler.setFormatter(fmt=self._std_formatter)\n</code></pre>"},{"location":"api/logging/#opensourceleg.logging.Logger.set_max_errors_before_untrack","title":"<code>set_max_errors_before_untrack(max_errors)</code>","text":"<p>Set the maximum number of errors before a variable is automatically untracked.</p> <p>Parameters:</p> Name Type Description Default <code>max_errors</code> <code>int</code> <p>Maximum number of errors before untracking.</p> required Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def set_max_errors_before_untrack(self, max_errors: int) -&gt; None:\n    \"\"\"\n    Set the maximum number of errors before a variable is automatically untracked.\n\n    Args:\n        max_errors (int): Maximum number of errors before untracking.\n    \"\"\"\n    with self._lock:\n        if max_errors &lt; 0:\n            self.warning(f\"Invalid max_errors value: {max_errors}. Using default of 5.\")\n            max_errors = 5\n        self._max_errors_before_untrack = max_errors\n</code></pre>"},{"location":"api/logging/#opensourceleg.logging.Logger.set_stream_level","title":"<code>set_stream_level(level)</code>","text":"<p>Set the log level for console output.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>LogLevel</code> <p>The log level for console output.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; LOGGER.set_stream_level(LogLevel.INFO)\n&gt;&gt;&gt; LOGGER.stream_level\nLogLevel.INFO\n&gt;&gt;&gt; LOGGER.debug(\"This is a debug message and will not be streamed\")\n</code></pre> Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def set_stream_level(self, level: LogLevel) -&gt; None:\n    \"\"\"\n    Set the log level for console output.\n\n    Args:\n        level: The log level for console output.\n\n    Examples:\n        &gt;&gt;&gt; LOGGER.set_stream_level(LogLevel.INFO)\n        &gt;&gt;&gt; LOGGER.stream_level\n        LogLevel.INFO\n        &gt;&gt;&gt; LOGGER.debug(\"This is a debug message and will not be streamed\")\n    \"\"\"\n    with self._lock:\n        self._stream_level = level\n        self._stream_handler.setLevel(level=level.value)\n</code></pre>"},{"location":"api/logging/#opensourceleg.logging.Logger.set_stream_terminator","title":"<code>set_stream_terminator(terminator)</code>","text":"<p>Set the terminator for the stream handler.</p> Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def set_stream_terminator(self, terminator: str) -&gt; None:\n    \"\"\"\n    Set the terminator for the stream handler.\n    \"\"\"\n    with self._lock:\n        self._stream_handler.terminator = terminator\n</code></pre>"},{"location":"api/logging/#opensourceleg.logging.Logger.track_attributes","title":"<code>track_attributes(obj, attributes)</code>","text":"<p>Track one or more attributes in an object and log their values to a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The object whose attributes are to be tracked.</p> required <code>attributes</code> <code>Union[str, list[str]]</code> <p>A single attribute name (str) or a list of attribute names (list[str]) to track.</p> required <p>Raises:</p> Type Description <code>AttributeError</code> <p>If any attribute in the list does not exist in the object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class MyClass:\n...     def __init__(self):\n...         self.value1 = 42\n...         self.value2 = 84\n&gt;&gt;&gt; obj = MyClass()\n&gt;&gt;&gt; LOGGER.track_attributes(obj, \"value1\")  # Single attribute\n&gt;&gt;&gt; LOGGER.track_attributes(obj, [\"value1\", \"value2\"])  # Multiple attributes\n&gt;&gt;&gt; LOGGER.update()\n&gt;&gt;&gt; LOGGER.flush_buffer()\n</code></pre> Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def track_attributes(self, obj: Any, attributes: Union[str, list[str]]) -&gt; None:\n    \"\"\"\n    Track one or more attributes in an object and log their values to a CSV file.\n\n    Args:\n        obj: The object whose attributes are to be tracked.\n        attributes: A single attribute name (str) or a list of attribute names (list[str]) to track.\n\n    Raises:\n        AttributeError: If any attribute in the list does not exist in the object.\n\n    Examples:\n        &gt;&gt;&gt; class MyClass:\n        ...     def __init__(self):\n        ...         self.value1 = 42\n        ...         self.value2 = 84\n        &gt;&gt;&gt; obj = MyClass()\n        &gt;&gt;&gt; LOGGER.track_attributes(obj, \"value1\")  # Single attribute\n        &gt;&gt;&gt; LOGGER.track_attributes(obj, [\"value1\", \"value2\"])  # Multiple attributes\n        &gt;&gt;&gt; LOGGER.update()\n        &gt;&gt;&gt; LOGGER.flush_buffer()\n    \"\"\"\n    with self._lock:\n        if isinstance(attributes, str):\n            attributes = [attributes]  # Convert single attribute to a list\n\n        obj_str = str(obj)  # Use str(obj) for a user-friendly representation\n        var_funcs = []\n        prefixed_attributes = [f\"{obj_str}.{attr}\" for attr in attributes]  # Prepend str(obj)\n\n        def create_getter(obj: Any, attr: str) -&gt; Callable[[], Any]:\n            \"\"\"Helper function to create a getter for an attribute.\"\"\"\n            return lambda: getattr(obj, attr)\n\n        for attr in attributes:\n            if not hasattr(obj, attr):\n                raise AttributeError(f\"Object {obj} does not have attribute '{attr}'\")\n            # Use the helper function to create the lambda\n            var_funcs.append(create_getter(obj, attr))\n\n        # Call track_function with the generated functions and prefixed attribute names\n        self.track_function(var_funcs, prefixed_attributes)\n</code></pre>"},{"location":"api/logging/#opensourceleg.logging.Logger.track_function","title":"<code>track_function(var_func, name)</code>","text":"<p>Record the value of returned from a function (or multiple functions) and log it to a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>var_func</code> <code>Union[Callable[[], Any], list[Callable[[], Any]]]</code> <p>A function (or list of functions) that returns the value(s) of the variable(s).</p> required <code>name</code> <code>Union[str, list[str]]</code> <p>The name (or list of names) of the variable(s).</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the lengths of <code>var_func</code> and <code>name</code> lists do not match.</p> <code>TypeError</code> <p>If <code>var_func</code> and <code>name</code> are not both single values or lists of equal length.</p> <p>Examples:</p>"},{"location":"api/logging/#opensourceleg.logging.Logger.track_function--single-variable-tracking","title":"Single variable tracking","text":"<pre><code>&gt;&gt;&gt; class MyClass:\n...     def __init__(self):\n...         self.value = 42\n&gt;&gt;&gt; obj = MyClass()\n&gt;&gt;&gt; LOGGER.track_function(lambda: obj.value, \"value\")\n&gt;&gt;&gt; LOGGER.update()\n&gt;&gt;&gt; LOGGER.flush_buffer()\n</code></pre>"},{"location":"api/logging/#opensourceleg.logging.Logger.track_function--multiple-variable-tracking","title":"Multiple variable tracking","text":"<pre><code>&gt;&gt;&gt; class MyClass:\n...     def __init__(self):\n...         self.value1 = 42\n...         self.value2 = 84\n&gt;&gt;&gt; obj = MyClass()\n&gt;&gt;&gt; LOGGER.track_function(\n...     [lambda: obj.value1, lambda: obj.value2],\n...     [\"value1\", \"value2\"]\n... )\n&gt;&gt;&gt; LOGGER.update()\n&gt;&gt;&gt; LOGGER.flush_buffer()\n&gt;&gt;&gt; LOGGER.update()\n&gt;&gt;&gt; LOGGER.flush_buffer()\n</code></pre> Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def track_function(\n    self, var_func: Union[Callable[[], Any], list[Callable[[], Any]]], name: Union[str, list[str]]\n) -&gt; None:\n    \"\"\"\n    Record the value of returned from a function (or multiple functions) and log it to a CSV file.\n\n    Args:\n        var_func: A function (or list of functions) that returns the value(s) of the variable(s).\n        name: The name (or list of names) of the variable(s).\n\n    Raises:\n        ValueError: If the lengths of `var_func` and `name` lists do not match.\n        TypeError: If `var_func` and `name` are not both single values or lists of equal length.\n\n    Examples:\n        # Single variable tracking\n        &gt;&gt;&gt; class MyClass:\n        ...     def __init__(self):\n        ...         self.value = 42\n        &gt;&gt;&gt; obj = MyClass()\n        &gt;&gt;&gt; LOGGER.track_function(lambda: obj.value, \"value\")\n        &gt;&gt;&gt; LOGGER.update()\n        &gt;&gt;&gt; LOGGER.flush_buffer()\n\n        # Multiple variable tracking\n        &gt;&gt;&gt; class MyClass:\n        ...     def __init__(self):\n        ...         self.value1 = 42\n        ...         self.value2 = 84\n        &gt;&gt;&gt; obj = MyClass()\n        &gt;&gt;&gt; LOGGER.track_function(\n        ...     [lambda: obj.value1, lambda: obj.value2],\n        ...     [\"value1\", \"value2\"]\n        ... )\n        &gt;&gt;&gt; LOGGER.update()\n        &gt;&gt;&gt; LOGGER.flush_buffer()\n        &gt;&gt;&gt; LOGGER.update()\n        &gt;&gt;&gt; LOGGER.flush_buffer()\n    \"\"\"\n    with self._lock:\n        if isinstance(var_func, list) and isinstance(name, list):\n            # Ensure the lengths of var_func and name match\n            if len(var_func) != len(name):\n                raise ValueError(\"The number of variable functions and names must match.\")\n            for func, var_name in zip(var_func, name):\n                var_id = id(func)\n                self._tracked_vars[var_id] = func\n                self._var_names[var_id] = var_name\n                self._error_count[var_id] = 0  # Initialize error count\n                self.debug(f\"Started tracking variable: {var_name}\")\n        elif callable(var_func) and isinstance(name, str):\n            # Single variable tracking\n            func = var_func  # Explicitly narrow the type for mypy\n            var_id = id(func)\n            self._tracked_vars[var_id] = func\n            self._var_names[var_id] = name\n            self._error_count[var_id] = 0  # Initialize error count\n            self.debug(f\"Started tracking variable: {name}\")\n        else:\n            raise TypeError(\n                \"Invalid input: var_func and name must both be either single values or lists of equal length.\"\n            )\n</code></pre>"},{"location":"api/logging/#opensourceleg.logging.Logger.update","title":"<code>update()</code>","text":"<p>Update the logger by logging the current values of tracked variables to the buffer.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class MyClass:\n...     def __init__(self):\n...         self.value = 42\n&gt;&gt;&gt; obj = MyClass()\n&gt;&gt;&gt; LOGGER.track_function(lambda: obj.value, \"answer\")\n&gt;&gt;&gt; LOGGER.update()\n</code></pre> Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def update(self) -&gt; None:\n    \"\"\"\n    Update the logger by logging the current values of tracked variables to the buffer.\n\n    Examples:\n        &gt;&gt;&gt; class MyClass:\n        ...     def __init__(self):\n        ...         self.value = 42\n        &gt;&gt;&gt; obj = MyClass()\n        &gt;&gt;&gt; LOGGER.track_function(lambda: obj.value, \"answer\")\n        &gt;&gt;&gt; LOGGER.update()\n    \"\"\"\n    if not self._tracked_vars or not self._enable_csv_logging:\n        return\n\n    with self._lock:\n        data = []\n        vars_to_untrack = []\n\n        for var_id, get_value in self._tracked_vars.items():\n            try:\n                value = get_value()\n                data.append(str(value))\n                # Reset error count on successful retrieval\n                self._error_count[var_id] = 0\n            except Exception as e:\n                var_name = self._var_names.get(var_id, \"unknown\")\n                self.warning(f\"Error getting value for {var_name}: {e}\")\n                data.append(\"ERROR\")\n\n                # Increment error count and check if we should untrack\n                self._error_count[var_id] = self._error_count.get(var_id, 0) + 1\n                if self._error_count[var_id] &gt;= self._max_errors_before_untrack:\n                    vars_to_untrack.append((var_id, var_name))\n\n        # Only add data if we have variables to track\n        if data:\n            self._buffer.append(data)\n\n        # Untrack variables with too many errors\n        for var_id, var_name in vars_to_untrack:\n            self._tracked_vars.pop(var_id, None)\n            self._var_names.pop(var_id, None)\n            self._error_count.pop(var_id, None)\n            self.warning(\n                f\"Auto-untracked variable {var_name} after {self._max_errors_before_untrack} consecutive errors\"\n            )\n\n        if len(self._buffer) &gt;= self._buffer_size:\n            self.flush_buffer()\n</code></pre>"},{"location":"api/logging/#opensourceleg.logging.Logger.warning","title":"<code>warning(msg, *args, **kwargs)</code>","text":"<p>Log a warning message.</p> <p>Ensures that the file handler is set up before logging.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>object</code> <p>The message to log.</p> required <code>*args</code> <code>object</code> <p>Additional arguments.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> Source code in <code>opensourceleg/logging/logger.py</code> <pre><code>def warning(self, msg: object, *args: object, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Log a warning message.\n\n    Ensures that the file handler is set up before logging.\n\n    Args:\n        msg (object): The message to log.\n        *args (object): Additional arguments.\n        **kwargs (Any): Additional keyword arguments.\n    \"\"\"\n    self._ensure_file_handler()\n    super().warning(msg, *args, **kwargs)\n</code></pre>"},{"location":"api/actuators/actuators/","title":"Base","text":""},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase","title":"<code>ActuatorBase</code>","text":"<p>               Bases: <code>OfflineMixin</code>, <code>ABC</code></p> <p>Base class defining the structure and interface for an actuator.</p> <p>This abstract class provides common functionality for controlling an actuator, including managing control mode transitions, restricting method calls based on mode, and exposing actuator properties.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class DummyActuator(ActuatorBase):\n...     @property\n...     def _CONTROL_MODE_CONFIGS(self):\n...         return CONTROL_MODE_CONFIGS()\n...     def start(self):\n...         print(\"Started\")\n...     def stop(self):\n...         print(\"Stopped\")\n...     def update(self):\n...         print(\"Updated\")\n...     def set_motor_voltage(self, value: float) -&gt; None:\n...         print(f\"Motor voltage set to {value}\")\n...     def set_motor_current(self, value: float) -&gt; None:\n...         print(f\"Motor current set to {value}\")\n...     def set_motor_position(self, value: float) -&gt; None:\n...         print(f\"Motor position set to {value}\")\n...     def set_motor_torque(self, value: float) -&gt; None:\n...         print(f\"Motor torque set to {value}\")\n...     def set_output_torque(self, value: float) -&gt; None:\n...         print(f\"Output torque set to {value}\")\n...     def set_current_gains(self, kp: float, ki: float, kd: float, ff: float) -&gt; None:\n...         print(\"Current gains set\")\n...     def set_position_gains(self, kp: float, ki: float, kd: float, ff: float) -&gt; None:\n...         print(\"Position gains set\")\n...     def _set_impedance_gains(self, k: float, b: float) -&gt; None:\n...         print(\"Impedance gains set\")\n...     def home(self) -&gt; None:\n...         print(\"Homed\")\n...     @property\n...     def motor_position(self) -&gt; float:\n...         return 100.0\n...     @property\n...     def motor_velocity(self) -&gt; float:\n...         return 10.0\n...     @property\n...     def motor_voltage(self) -&gt; float:\n...         return 24.0\n...     @property\n...     def motor_current(self) -&gt; float:\n...         return 0.5\n...     @property\n...     def motor_torque(self) -&gt; float:\n...         return 2.0\n...     @property\n...     def case_temperature(self) -&gt; float:\n...         return 70.0\n...     @property\n...     def winding_temperature(self) -&gt; float:\n...         return 90.0\n&gt;&gt;&gt; actuator = DummyActuator(\n...     tag=\"act1\",\n...     gear_ratio=100,\n...     motor_constants=MOTOR_CONSTANTS(2048, 0.02, 0.001, 0.0001, 80.0, 120.0)\n... )\n&gt;&gt;&gt; actuator.start()\nStarted\n</code></pre> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>class ActuatorBase(OfflineMixin, ABC):\n    \"\"\"\n    Base class defining the structure and interface for an actuator.\n\n    This abstract class provides common functionality for controlling an actuator,\n    including managing control mode transitions, restricting method calls based on mode,\n    and exposing actuator properties.\n\n    Examples:\n        &gt;&gt;&gt; class DummyActuator(ActuatorBase):\n        ...     @property\n        ...     def _CONTROL_MODE_CONFIGS(self):\n        ...         return CONTROL_MODE_CONFIGS()\n        ...     def start(self):\n        ...         print(\"Started\")\n        ...     def stop(self):\n        ...         print(\"Stopped\")\n        ...     def update(self):\n        ...         print(\"Updated\")\n        ...     def set_motor_voltage(self, value: float) -&gt; None:\n        ...         print(f\"Motor voltage set to {value}\")\n        ...     def set_motor_current(self, value: float) -&gt; None:\n        ...         print(f\"Motor current set to {value}\")\n        ...     def set_motor_position(self, value: float) -&gt; None:\n        ...         print(f\"Motor position set to {value}\")\n        ...     def set_motor_torque(self, value: float) -&gt; None:\n        ...         print(f\"Motor torque set to {value}\")\n        ...     def set_output_torque(self, value: float) -&gt; None:\n        ...         print(f\"Output torque set to {value}\")\n        ...     def set_current_gains(self, kp: float, ki: float, kd: float, ff: float) -&gt; None:\n        ...         print(\"Current gains set\")\n        ...     def set_position_gains(self, kp: float, ki: float, kd: float, ff: float) -&gt; None:\n        ...         print(\"Position gains set\")\n        ...     def _set_impedance_gains(self, k: float, b: float) -&gt; None:\n        ...         print(\"Impedance gains set\")\n        ...     def home(self) -&gt; None:\n        ...         print(\"Homed\")\n        ...     @property\n        ...     def motor_position(self) -&gt; float:\n        ...         return 100.0\n        ...     @property\n        ...     def motor_velocity(self) -&gt; float:\n        ...         return 10.0\n        ...     @property\n        ...     def motor_voltage(self) -&gt; float:\n        ...         return 24.0\n        ...     @property\n        ...     def motor_current(self) -&gt; float:\n        ...         return 0.5\n        ...     @property\n        ...     def motor_torque(self) -&gt; float:\n        ...         return 2.0\n        ...     @property\n        ...     def case_temperature(self) -&gt; float:\n        ...         return 70.0\n        ...     @property\n        ...     def winding_temperature(self) -&gt; float:\n        ...         return 90.0\n        &gt;&gt;&gt; actuator = DummyActuator(\n        ...     tag=\"act1\",\n        ...     gear_ratio=100,\n        ...     motor_constants=MOTOR_CONSTANTS(2048, 0.02, 0.001, 0.0001, 80.0, 120.0)\n        ... )\n        &gt;&gt;&gt; actuator.start()\n        Started\n    \"\"\"\n\n    # Class-level mapping of methods to their required control modes\n    _METHOD_REQUIRED_MODES: ClassVar[dict[str, set[CONTROL_MODES]]] = {\n        \"set_motor_voltage\": {CONTROL_MODES.VOLTAGE},\n        \"set_motor_current\": {CONTROL_MODES.CURRENT},\n        \"set_motor_position\": {CONTROL_MODES.POSITION, CONTROL_MODES.IMPEDANCE},\n        \"set_output_position\": {CONTROL_MODES.POSITION, CONTROL_MODES.IMPEDANCE},\n        \"set_motor_impedance\": {CONTROL_MODES.IMPEDANCE},\n        \"set_output_impedance\": {CONTROL_MODES.IMPEDANCE},\n        \"set_motor_torque\": {CONTROL_MODES.CURRENT, CONTROL_MODES.TORQUE},\n        \"set_output_torque\": {CONTROL_MODES.CURRENT, CONTROL_MODES.TORQUE},\n        \"set_current_gains\": {CONTROL_MODES.CURRENT, CONTROL_MODES.TORQUE},\n        \"set_position_gains\": {CONTROL_MODES.POSITION},\n    }\n\n    # Offline mode configuration for OfflineMixin\n    _OFFLINE_METHODS: ClassVar[list[str]] = HARDWARE_REQUIRED_METHODS\n    _OFFLINE_PROPERTIES: ClassVar[list[str]] = HARDWARE_REQUIRED_PROPERTIES\n    _OFFLINE_PROPERTY_DEFAULTS: ClassVar[dict[str, Any]] = {\n        \"motor_position\": 0.0,\n        \"motor_velocity\": 0.0,\n        \"motor_voltage\": 0.0,\n        \"motor_current\": 0.0,\n        \"motor_torque\": 0.0,\n        \"case_temperature\": 25.0,  # Room temperature\n        \"winding_temperature\": 25.0,  # Room temperature\n    }\n\n    def __init__(\n        self,\n        tag: str,\n        gear_ratio: float,\n        motor_constants: MOTOR_CONSTANTS,\n        frequency: int = 1000,\n        offline: bool = False,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        Initialize an actuator.\n\n        Args:\n            tag (str): A unique identifier for the actuator.\n            gear_ratio (float): The gear ratio of the actuator.\n            motor_constants (MOTOR_CONSTANTS): Motor constant configuration parameters.\n            frequency (int, optional): Control frequency in Hz. Defaults to 1000.\n            offline (bool, optional): Flag indicating if the actuator operates in offline mode. Defaults to False.\n            **kwargs (Any): Additional keyword arguments.\n\n        Examples:\n            &gt;&gt;&gt; actuator = DummyActuator(\n            ...     tag=\"act1\",\n            ...     gear_ratio=100,\n            ...     motor_constants=MOTOR_CONSTANTS(2048, 0.02, 0.001, 0.0001, 80.0, 120.0)\n            ... )\n        \"\"\"\n        self._MOTOR_CONSTANTS: MOTOR_CONSTANTS = motor_constants\n        self._gear_ratio: float = gear_ratio\n        self._tag: str = tag\n        self._frequency: int = frequency\n        self._data: Any = None\n        self._is_homed: bool = False\n\n        self._mode: CONTROL_MODES = CONTROL_MODES.IDLE\n\n        self._motor_zero_position: float = 0.0\n\n        self._is_open: bool = False\n        self._is_streaming: bool = False\n\n        self._original_methods: dict[str, MethodWithRequiredModes] = {}\n\n        # Initialize OfflineMixin first so _is_offline is available\n        super().__init__(offline=offline, **kwargs)\n\n        self._set_original_methods()\n        self._set_mutated_methods()\n\n    def __enter__(self) -&gt; \"ActuatorBase\":\n        \"\"\"\n        Enter the runtime context related to this actuator.\n\n        Starts the actuator and returns the instance.\n\n        Returns:\n            ActuatorBase: The actuator instance.\n\n        Examples:\n            &gt;&gt;&gt; with actuator as a:\n            ...     print(\"Inside context\")\n            Started\n            Inside context\n            Stopped\n        \"\"\"\n        self.start()\n        return self\n\n    def __exit__(self, exc_type: Any, exc_value: Any, exc_traceback: Any) -&gt; None:\n        \"\"\"\n        Exit the runtime context and stop the actuator.\n\n        Args:\n            exc_type (Any): Exception type, if any.\n            exc_value (Any): Exception value, if any.\n            exc_traceback (Any): Exception traceback, if any.\n\n        Examples:\n            &gt;&gt;&gt; try:\n            ...     with actuator:\n            ...         raise ValueError(\"Test error\")\n            ... except ValueError:\n            ...     pass  # actuator.stop() was automatically called\n        \"\"\"\n        self.stop()\n\n    def _restricted_method(self, method_name: str, *args: Any, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Fallback method for restricted operations.\n\n        Logs an error indicating that the requested method is not available\n        in the current control mode.\n\n        Args:\n            method_name (str): Name of the restricted method.\n            *args (Any): Positional arguments passed to the method.\n            **kwargs (Any): Keyword arguments passed to the method.\n\n        Examples:\n            &gt;&gt;&gt; actuator._restricted_method(\"set_motor_voltage\")\n            # (Logs an error message and returns None)\n        \"\"\"\n        raise ControlModeException(tag=self._tag, attribute=method_name, mode=self._mode.name)\n\n    def _set_original_methods(self) -&gt; None:\n        \"\"\"\n        Store the original methods that require specific control modes.\n\n        Uses a class-level mapping of methods to their required control modes\n        to ensure proper inheritance of restrictions in derived classes.\n\n        Examples:\n            &gt;&gt;&gt; print(actuator._original_methods)  # Dictionary of method names to methods\n        \"\"\"\n        # Get the method-to-required-modes mapping for this class\n        method_modes_map = getattr(self.__class__, \"_METHOD_REQUIRED_MODES\", {})\n\n        for method_name, _required_modes in method_modes_map.items():\n            try:\n                method = getattr(self, method_name)\n                if callable(method):\n                    self._original_methods[method_name] = method\n                    # LOGGER.debug(\n                    #     msg=f\"[{self.tag}] {method_name}() is available in modes: \"\n                    #     f\"{[mode.name for mode in required_modes]}\"\n                    # )\n            except AttributeError:\n                LOGGER.debug(msg=f\"[{self.tag}] {method_name}() is not implemented in {self.__class__.__name__}.\")\n\n    def _set_mutated_methods(self) -&gt; None:\n        \"\"\"\n        Update actuator methods based on the current control mode.\n\n        For each method stored in `_original_methods`, if the current control mode\n        is permitted, the original method is used; otherwise, a restricted version\n        that logs an error is assigned.\n\n        Examples:\n            &gt;&gt;&gt; actuator._set_mutated_methods()\n        \"\"\"\n        for method_name, method in self._original_methods.items():\n            # In offline mode, hardware methods are already stubbed by OfflineMixin\n            if self._is_offline and method_name in HARDWARE_REQUIRED_METHODS:\n                # Skip - method is already patched by OfflineMixin\n                continue\n            elif self._mode in self._METHOD_REQUIRED_MODES[method_name]:\n                setattr(self, method_name, method)\n            else:\n                setattr(self, method_name, partial(self._restricted_method, method_name))\n\n    @property\n    @abstractmethod\n    def _CONTROL_MODE_CONFIGS(self) -&gt; CONTROL_MODE_CONFIGS:\n        \"\"\"\n        Abstract property to obtain control mode configurations.\n\n        Returns:\n            CONTROL_MODE_CONFIGS: The configuration settings for each control mode.\n\n        Examples:\n            &gt;&gt;&gt; config = actuator._CONTROL_MODE_CONFIGS  # Implemented in subclass\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def start(self) -&gt; None:\n        \"\"\"\n        Start the actuator.\n\n        Must be implemented by subclasses to initialize and activate the actuator.\n\n        Examples:\n            &gt;&gt;&gt; actuator.start()\n            Started\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def stop(self) -&gt; None:\n        \"\"\"\n        Stop the actuator.\n\n        Must be implemented by subclasses to safely deactivate the actuator.\n\n        Examples:\n            &gt;&gt;&gt; actuator.stop()\n            Stopped\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def update(self) -&gt; None:\n        \"\"\"\n        Update the actuator's state.\n\n        Must be implemented by subclasses to refresh or recalculate state values.\n\n        Examples:\n            &gt;&gt;&gt; actuator.update()\n            Updated\n        \"\"\"\n        pass\n\n    def _get_control_mode_config(self, mode: CONTROL_MODES) -&gt; Optional[ControlModeConfig]:\n        \"\"\"\n        Retrieve the control mode configuration for a specified mode.\n\n        Args:\n            mode (CONTROL_MODES): The control mode for which to retrieve the configuration.\n\n        Returns:\n            Optional[ControlModeConfig]: The configuration if it exists; otherwise, None.\n\n        Examples:\n            &gt;&gt;&gt; config = actuator._get_control_mode_config(CONTROL_MODES.IDLE)\n            &gt;&gt;&gt; print(config)\n            None\n        \"\"\"\n        return cast(\n            Optional[ControlModeConfig],\n            getattr(self._CONTROL_MODE_CONFIGS, mode.name),\n        )\n\n    def set_control_mode(self, mode: CONTROL_MODES) -&gt; None:\n        \"\"\"\n        Set the actuator's control mode.\n\n        If the mode is changing, the exit callback for the current mode and\n        the entry callback for the new mode are executed, and methods are updated\n        to reflect any restrictions imposed by the new mode.\n\n        Args:\n            mode (CONTROL_MODES): The new control mode to be set.\n\n        Examples:\n            &gt;&gt;&gt; actuator.set_control_mode(CONTROL_MODES.POSITION)\n        \"\"\"\n        if self.mode == mode:\n            LOGGER.debug(msg=f\"[{self.tag}] Already in {self.mode.name} control mode.\")\n            return\n\n        current_config = self._get_control_mode_config(self.mode)\n        if current_config:\n            current_config.exit_callback(self)\n\n        self._mode = mode\n\n        new_config = self._get_control_mode_config(self.mode)\n        if new_config:\n            new_config.entry_callback(self)\n\n        self._set_mutated_methods()\n\n    @abstractmethod\n    def set_motor_voltage(self, value: float) -&gt; None:\n        \"\"\"\n        Set the motor voltage.\n\n        Args:\n            value (float): The voltage value to be applied to the motor.\n\n        Must be implemented by subclasses.\n\n        Examples:\n            &gt;&gt;&gt; actuator.set_motor_voltage(12.0)\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def set_motor_current(self, value: float) -&gt; None:\n        \"\"\"\n        Set the motor current.\n\n        Args:\n            value (float): The current value to be applied to the motor.\n\n        Must be implemented by subclasses.\n\n        Examples:\n            &gt;&gt;&gt; actuator.set_motor_current(1.5)\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def set_motor_position(self, value: float) -&gt; None:\n        \"\"\"\n        Set the motor position.\n\n        Args:\n            value (float): The target motor position in radians.\n\n        Must be implemented by subclasses.\n\n        Examples:\n            &gt;&gt;&gt; actuator.set_motor_position(0.5)\n        \"\"\"\n        pass\n\n    def set_output_position(self, value: float) -&gt; None:\n        \"\"\"\n        Set the output position of the actuator.\n\n        Converts the desired output position (in radians) to a motor position by\n        applying the gear ratio, then delegates to `set_motor_position`.\n\n        Args:\n            value (float): The desired output position in radians.\n\n        Examples:\n            &gt;&gt;&gt; # Assuming gear_ratio is 100, this will set the motor position to 100 * value.\n            &gt;&gt;&gt; actuator.set_motor_position = lambda value: print(f\"Motor position set to {value}\")\n            &gt;&gt;&gt; actuator.set_output_position(1.0)\n            Motor position set to 100.0\n        \"\"\"\n        self.set_motor_position(value=value * self.gear_ratio)\n\n    @abstractmethod\n    def set_motor_torque(self, value: float) -&gt; None:\n        \"\"\"\n        Set the motor torque.\n\n        Args:\n            value (float): The torque value to be applied to the motor.\n\n        Must be implemented by subclasses.\n\n        Examples:\n            &gt;&gt;&gt; actuator.set_motor_torque(5.0)\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def set_output_torque(self, value: float) -&gt; None:\n        \"\"\"\n        Set the output torque.\n\n        Args:\n            value (float): The torque value to be applied to the joint.\n\n        Must be implemented by subclasses.\n\n        Examples:\n            &gt;&gt;&gt; actuator.set_output_torque(5.0)\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def set_current_gains(self, kp: float, ki: float, kd: float, ff: float) -&gt; None:\n        \"\"\"\n        Set the current control gains.\n\n        Args:\n            kp (float): Proportional gain.\n            ki (float): Integral gain.\n            kd (float): Derivative gain.\n            ff (float): Feed-forward gain.\n\n        Must be implemented by subclasses.\n\n        Examples:\n            &gt;&gt;&gt; actuator.set_current_gains(1.0, 0.1, 0.01, 0.0)\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def set_position_gains(self, kp: float, ki: float, kd: float, ff: float) -&gt; None:\n        \"\"\"\n        Set the position control gains.\n\n        Args:\n            kp (float): Proportional gain.\n            ki (float): Integral gain.\n            kd (float): Derivative gain.\n            ff (float): Feed-forward gain.\n\n        Must be implemented by subclasses.\n\n        Examples:\n            &gt;&gt;&gt; actuator.set_position_gains(1.0, 0.1, 0.01, 0.0)\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def _set_impedance_gains(self, k: float, b: float) -&gt; None:\n        \"\"\"\n        Set the impedance control gains.\n\n        Args:\n            k (float): Stiffness coefficient.\n            b (float): Damping coefficient.\n\n        Must be implemented by subclasses.\n\n        Examples:\n            &gt;&gt;&gt; actuator._set_impedance_gains(0.5, 0.05)\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def home(\n        self,\n        homing_voltage: int = 2000,\n        homing_frequency: Optional[int] = None,\n        homing_direction: int = -1,\n        output_position_offset: float = 0.0,\n        current_threshold: int = 5000,\n        velocity_threshold: float = 0.001,\n        callback: Optional[Callable[[], None]] = None,\n    ) -&gt; None:\n        \"\"\"\n        Home the actuator.\n\n        Aligns the actuator to a known reference position.\n        Must be implemented by subclasses.\n\n        Args:\n            homing_voltage (int): Voltage to use for homing.\n            homing_frequency (Optional[int]): Frequency to use for homing.\n            homing_direction (int): Direction to move the actuator during homing.\n            output_position_offset (float): Offset to add to the output position.\n            current_threshold (int): Current threshold to stop homing.\n            velocity_threshold (float): Velocity threshold to stop homing.\n            callback (Optional[Callable[[], None]]): Optional callback function to be\n                        called when homing completes. The function should take no arguments and return None.\n\n        Examples:\n            &gt;&gt;&gt; actuator.home()\n            Homed\n        \"\"\"\n        pass\n\n    def set_motor_zero_position(self, value: float) -&gt; None:\n        \"\"\"\n        Set the motor zero position.\n\n        Args:\n            value (float): The motor zero position in radians.\n\n        Examples:\n            &gt;&gt;&gt; actuator.set_motor_zero_position(0.0)\n            &gt;&gt;&gt; actuator.motor_zero_position\n            0.0\n        \"\"\"\n        self._motor_zero_position = value\n\n    @property\n    @abstractmethod\n    def motor_position(self) -&gt; float:\n        \"\"\"\n        Get the motor position.\n\n        Returns:\n            float: The current motor position in radians.\n\n        Must be implemented by subclasses.\n\n        Examples:\n            &gt;&gt;&gt; pos = actuator.motor_position\n            &gt;&gt;&gt; print(pos)\n            100.0\n        \"\"\"\n        pass\n\n    @property\n    def output_position(self) -&gt; float:\n        \"\"\"\n        Get the output position.\n\n        Returns:\n            float: The output position in radians, calculated by dividing the motor\n                   position by the gear ratio. Note that this does not account for SEA compliance.\n\n        Examples:\n            &gt;&gt;&gt; # If motor_position is 100.0 and gear_ratio is 100, output_position will be 1.0\n            &gt;&gt;&gt; actuator.output_position\n            1.0\n        \"\"\"\n        return self.motor_position / self.gear_ratio\n\n    @property\n    @abstractmethod\n    def motor_velocity(self) -&gt; float:\n        \"\"\"\n        Get the motor velocity.\n\n        Returns:\n            float: The current motor velocity in radians per second.\n\n        Must be implemented by subclasses.\n\n        Examples:\n            &gt;&gt;&gt; velocity = actuator.motor_velocity\n            &gt;&gt;&gt; print(velocity)\n            10.0\n        \"\"\"\n        pass\n\n    @property\n    def output_velocity(self) -&gt; float:\n        \"\"\"\n        Get the output velocity.\n\n        Returns:\n            float: The output velocity in radians per second, calculated by dividing the motor\n                   velocity by the gear ratio. Note that this does not account for SEA compliance.\n\n        Examples:\n            &gt;&gt;&gt; # If motor_velocity is 10.0 and gear_ratio is 100, output_velocity will be 0.1\n            &gt;&gt;&gt; actuator.output_velocity\n            0.1\n        \"\"\"\n        return self.motor_velocity / self.gear_ratio\n\n    @property\n    @abstractmethod\n    def motor_voltage(self) -&gt; float:\n        \"\"\"\n        Get the motor voltage.\n\n        Returns:\n            float: The current motor voltage.\n\n        Must be implemented by subclasses.\n\n        Examples:\n            &gt;&gt;&gt; voltage = actuator.motor_voltage\n            &gt;&gt;&gt; print(voltage)\n            24.0\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def motor_current(self) -&gt; float:\n        \"\"\"\n        Get the motor current.\n\n        Returns:\n            float: The current motor current.\n\n        Must be implemented by subclasses.\n\n        Examples:\n            &gt;&gt;&gt; current = actuator.motor_current\n            &gt;&gt;&gt; print(current)\n            0.5\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def motor_torque(self) -&gt; float:\n        \"\"\"\n        Get the motor torque.\n\n        Returns:\n            float: The current motor torque.\n\n        Must be implemented by subclasses.\n\n        Examples:\n            &gt;&gt;&gt; torque = actuator.motor_torque\n            &gt;&gt;&gt; print(torque)\n            2.0\n        \"\"\"\n        pass\n\n    @property\n    def MOTOR_CONSTANTS(self) -&gt; MOTOR_CONSTANTS:\n        \"\"\"\n        Get the motor constants configuration.\n\n        Returns:\n            MOTOR_CONSTANTS: The motor constants.\n\n        Examples:\n            &gt;&gt;&gt; constants = actuator.MOTOR_CONSTANTS\n            &gt;&gt;&gt; constants.MAX_CASE_TEMPERATURE\n            80.0\n        \"\"\"\n        return self._MOTOR_CONSTANTS\n\n    @MOTOR_CONSTANTS.setter\n    def MOTOR_CONSTANTS(self, value: MOTOR_CONSTANTS) -&gt; None:\n        \"\"\"\n        Set the motor constants configuration.\n\n        Args:\n            value (MOTOR_CONSTANTS): The new motor constants to set.\n\n        Examples:\n            &gt;&gt;&gt; new_constants = MOTOR_CONSTANTS(2048, 0.03, 0.001, 0.0001, 85.0, 125.0)\n            &gt;&gt;&gt; actuator.MOTOR_CONSTANTS = new_constants\n            &gt;&gt;&gt; actuator.MOTOR_CONSTANTS.MAX_CASE_TEMPERATURE\n            85.0\n        \"\"\"\n        self._MOTOR_CONSTANTS = value\n\n    @property\n    def mode(self) -&gt; CONTROL_MODES:\n        \"\"\"\n        Get the current control mode.\n\n        Returns:\n            CONTROL_MODES: The actuator's current control mode.\n\n        Examples:\n            &gt;&gt;&gt; actuator.mode\n            &lt;CONTROL_MODES.IDLE: -1&gt;\n        \"\"\"\n        return self._mode\n\n    @property\n    def tag(self) -&gt; str:\n        \"\"\"\n        Get the actuator tag.\n\n        Returns:\n            str: The unique identifier for the actuator.\n\n        Examples:\n            &gt;&gt;&gt; actuator.tag\n            \"act1\"\n        \"\"\"\n        return self._tag\n\n    @property\n    def is_homed(self) -&gt; bool:\n        \"\"\"\n        Check if the actuator has been homed.\n\n        Returns:\n            bool: True if the actuator is homed; otherwise, False.\n\n        Examples:\n            &gt;&gt;&gt; actuator.is_homed\n            False\n        \"\"\"\n        return self._is_homed\n\n    @property\n    def frequency(self) -&gt; int:\n        \"\"\"\n        Get the actuator's control frequency.\n\n        Returns:\n            int: The control frequency in Hz.\n\n        Examples:\n            &gt;&gt;&gt; actuator.frequency\n            1000\n        \"\"\"\n        return self._frequency\n\n    @property\n    def gear_ratio(self) -&gt; float:\n        \"\"\"\n        Get the gear ratio.\n\n        Returns:\n            float: The gear ratio of the actuator.\n\n        Examples:\n            &gt;&gt;&gt; actuator.gear_ratio\n            100\n        \"\"\"\n        return self._gear_ratio\n\n    @property\n    def max_case_temperature(self) -&gt; float:\n        \"\"\"\n        Get the maximum allowed case temperature.\n\n        Returns:\n            float: The maximum case temperature defined in motor constants.\n\n        Examples:\n            &gt;&gt;&gt; actuator.max_case_temperature\n            80.0\n        \"\"\"\n        return self._MOTOR_CONSTANTS.MAX_CASE_TEMPERATURE\n\n    @property\n    @abstractmethod\n    def case_temperature(self) -&gt; float:\n        \"\"\"\n        Get the current case temperature.\n\n        Returns:\n            float: The current case temperature.\n\n        Must be implemented by subclasses.\n\n        Examples:\n            &gt;&gt;&gt; temp = actuator.case_temperature\n            &gt;&gt;&gt; print(temp)\n            70.0\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def winding_temperature(self) -&gt; float:\n        \"\"\"\n        Get the current winding temperature.\n\n        Returns:\n            float: The current winding temperature.\n\n        Must be implemented by subclasses.\n\n        Examples:\n            &gt;&gt;&gt; temp = actuator.winding_temperature\n            &gt;&gt;&gt; print(temp)\n            90.0\n        \"\"\"\n        pass\n\n    @property\n    def max_winding_temperature(self) -&gt; float:\n        \"\"\"\n        Get the maximum allowed winding temperature.\n\n        Returns:\n            float: The maximum winding temperature defined in motor constants.\n\n        Examples:\n            &gt;&gt;&gt; actuator.max_winding_temperature\n            120.0\n        \"\"\"\n        return self._MOTOR_CONSTANTS.MAX_WINDING_TEMPERATURE\n\n    @property\n    def motor_zero_position(self) -&gt; float:\n        \"\"\"\n        Get the motor zero position.\n\n        Returns:\n            float: The motor zero position in radians.\n\n        Examples:\n            &gt;&gt;&gt; actuator.set_motor_zero_position(0.0)\n            &gt;&gt;&gt; actuator.motor_zero_position\n            0.0\n        \"\"\"\n        return self._motor_zero_position\n\n    @property\n    def is_open(self) -&gt; bool:\n        \"\"\"\n        Check if the actuator is open.\n\n        Returns:\n            bool: True if open; otherwise, False.\n\n        Examples:\n            &gt;&gt;&gt; actuator._is_open = True\n            &gt;&gt;&gt; actuator.is_open\n            True\n        \"\"\"\n        return self._is_open\n\n    @property\n    def is_streaming(self) -&gt; bool:\n        \"\"\"\n        Check if the actuator is streaming data.\n\n        Returns:\n            bool: True if streaming; otherwise, False.\n\n        Examples:\n            &gt;&gt;&gt; actuator._is_streaming = True\n            &gt;&gt;&gt; actuator.is_streaming\n            True\n        \"\"\"\n        return self._is_streaming\n</code></pre>"},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.MOTOR_CONSTANTS","title":"<code>MOTOR_CONSTANTS</code>  <code>property</code> <code>writable</code>","text":"<p>Get the motor constants configuration.</p> <p>Returns:</p> Name Type Description <code>MOTOR_CONSTANTS</code> <code>MOTOR_CONSTANTS</code> <p>The motor constants.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; constants = actuator.MOTOR_CONSTANTS\n&gt;&gt;&gt; constants.MAX_CASE_TEMPERATURE\n80.0\n</code></pre>"},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.case_temperature","title":"<code>case_temperature</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the current case temperature.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The current case temperature.</p> <p>Must be implemented by subclasses.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; temp = actuator.case_temperature\n&gt;&gt;&gt; print(temp)\n70.0\n</code></pre>"},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.frequency","title":"<code>frequency</code>  <code>property</code>","text":"<p>Get the actuator's control frequency.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The control frequency in Hz.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator.frequency\n1000\n</code></pre>"},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.gear_ratio","title":"<code>gear_ratio</code>  <code>property</code>","text":"<p>Get the gear ratio.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The gear ratio of the actuator.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator.gear_ratio\n100\n</code></pre>"},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.is_homed","title":"<code>is_homed</code>  <code>property</code>","text":"<p>Check if the actuator has been homed.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the actuator is homed; otherwise, False.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator.is_homed\nFalse\n</code></pre>"},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.is_open","title":"<code>is_open</code>  <code>property</code>","text":"<p>Check if the actuator is open.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if open; otherwise, False.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator._is_open = True\n&gt;&gt;&gt; actuator.is_open\nTrue\n</code></pre>"},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.is_streaming","title":"<code>is_streaming</code>  <code>property</code>","text":"<p>Check if the actuator is streaming data.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if streaming; otherwise, False.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator._is_streaming = True\n&gt;&gt;&gt; actuator.is_streaming\nTrue\n</code></pre>"},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.max_case_temperature","title":"<code>max_case_temperature</code>  <code>property</code>","text":"<p>Get the maximum allowed case temperature.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The maximum case temperature defined in motor constants.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator.max_case_temperature\n80.0\n</code></pre>"},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.max_winding_temperature","title":"<code>max_winding_temperature</code>  <code>property</code>","text":"<p>Get the maximum allowed winding temperature.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The maximum winding temperature defined in motor constants.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator.max_winding_temperature\n120.0\n</code></pre>"},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.mode","title":"<code>mode</code>  <code>property</code>","text":"<p>Get the current control mode.</p> <p>Returns:</p> Name Type Description <code>CONTROL_MODES</code> <code>CONTROL_MODES</code> <p>The actuator's current control mode.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator.mode\n&lt;CONTROL_MODES.IDLE: -1&gt;\n</code></pre>"},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.motor_current","title":"<code>motor_current</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the motor current.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The current motor current.</p> <p>Must be implemented by subclasses.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; current = actuator.motor_current\n&gt;&gt;&gt; print(current)\n0.5\n</code></pre>"},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.motor_position","title":"<code>motor_position</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the motor position.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The current motor position in radians.</p> <p>Must be implemented by subclasses.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pos = actuator.motor_position\n&gt;&gt;&gt; print(pos)\n100.0\n</code></pre>"},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.motor_torque","title":"<code>motor_torque</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the motor torque.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The current motor torque.</p> <p>Must be implemented by subclasses.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; torque = actuator.motor_torque\n&gt;&gt;&gt; print(torque)\n2.0\n</code></pre>"},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.motor_velocity","title":"<code>motor_velocity</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the motor velocity.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The current motor velocity in radians per second.</p> <p>Must be implemented by subclasses.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; velocity = actuator.motor_velocity\n&gt;&gt;&gt; print(velocity)\n10.0\n</code></pre>"},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.motor_voltage","title":"<code>motor_voltage</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the motor voltage.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The current motor voltage.</p> <p>Must be implemented by subclasses.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; voltage = actuator.motor_voltage\n&gt;&gt;&gt; print(voltage)\n24.0\n</code></pre>"},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.motor_zero_position","title":"<code>motor_zero_position</code>  <code>property</code>","text":"<p>Get the motor zero position.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The motor zero position in radians.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator.set_motor_zero_position(0.0)\n&gt;&gt;&gt; actuator.motor_zero_position\n0.0\n</code></pre>"},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.output_position","title":"<code>output_position</code>  <code>property</code>","text":"<p>Get the output position.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The output position in radians, calculated by dividing the motor    position by the gear ratio. Note that this does not account for SEA compliance.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # If motor_position is 100.0 and gear_ratio is 100, output_position will be 1.0\n&gt;&gt;&gt; actuator.output_position\n1.0\n</code></pre>"},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.output_velocity","title":"<code>output_velocity</code>  <code>property</code>","text":"<p>Get the output velocity.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The output velocity in radians per second, calculated by dividing the motor    velocity by the gear ratio. Note that this does not account for SEA compliance.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # If motor_velocity is 10.0 and gear_ratio is 100, output_velocity will be 0.1\n&gt;&gt;&gt; actuator.output_velocity\n0.1\n</code></pre>"},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.tag","title":"<code>tag</code>  <code>property</code>","text":"<p>Get the actuator tag.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The unique identifier for the actuator.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator.tag\n\"act1\"\n</code></pre>"},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.winding_temperature","title":"<code>winding_temperature</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the current winding temperature.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The current winding temperature.</p> <p>Must be implemented by subclasses.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; temp = actuator.winding_temperature\n&gt;&gt;&gt; print(temp)\n90.0\n</code></pre>"},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.__enter__","title":"<code>__enter__()</code>","text":"<p>Enter the runtime context related to this actuator.</p> <p>Starts the actuator and returns the instance.</p> <p>Returns:</p> Name Type Description <code>ActuatorBase</code> <code>ActuatorBase</code> <p>The actuator instance.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; with actuator as a:\n...     print(\"Inside context\")\nStarted\nInside context\nStopped\n</code></pre> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>def __enter__(self) -&gt; \"ActuatorBase\":\n    \"\"\"\n    Enter the runtime context related to this actuator.\n\n    Starts the actuator and returns the instance.\n\n    Returns:\n        ActuatorBase: The actuator instance.\n\n    Examples:\n        &gt;&gt;&gt; with actuator as a:\n        ...     print(\"Inside context\")\n        Started\n        Inside context\n        Stopped\n    \"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.__exit__","title":"<code>__exit__(exc_type, exc_value, exc_traceback)</code>","text":"<p>Exit the runtime context and stop the actuator.</p> <p>Parameters:</p> Name Type Description Default <code>exc_type</code> <code>Any</code> <p>Exception type, if any.</p> required <code>exc_value</code> <code>Any</code> <p>Exception value, if any.</p> required <code>exc_traceback</code> <code>Any</code> <p>Exception traceback, if any.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; try:\n...     with actuator:\n...         raise ValueError(\"Test error\")\n... except ValueError:\n...     pass  # actuator.stop() was automatically called\n</code></pre> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>def __exit__(self, exc_type: Any, exc_value: Any, exc_traceback: Any) -&gt; None:\n    \"\"\"\n    Exit the runtime context and stop the actuator.\n\n    Args:\n        exc_type (Any): Exception type, if any.\n        exc_value (Any): Exception value, if any.\n        exc_traceback (Any): Exception traceback, if any.\n\n    Examples:\n        &gt;&gt;&gt; try:\n        ...     with actuator:\n        ...         raise ValueError(\"Test error\")\n        ... except ValueError:\n        ...     pass  # actuator.stop() was automatically called\n    \"\"\"\n    self.stop()\n</code></pre>"},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.__init__","title":"<code>__init__(tag, gear_ratio, motor_constants, frequency=1000, offline=False, **kwargs)</code>","text":"<p>Initialize an actuator.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>A unique identifier for the actuator.</p> required <code>gear_ratio</code> <code>float</code> <p>The gear ratio of the actuator.</p> required <code>motor_constants</code> <code>MOTOR_CONSTANTS</code> <p>Motor constant configuration parameters.</p> required <code>frequency</code> <code>int</code> <p>Control frequency in Hz. Defaults to 1000.</p> <code>1000</code> <code>offline</code> <code>bool</code> <p>Flag indicating if the actuator operates in offline mode. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DummyActuator(\n...     tag=\"act1\",\n...     gear_ratio=100,\n...     motor_constants=MOTOR_CONSTANTS(2048, 0.02, 0.001, 0.0001, 80.0, 120.0)\n... )\n</code></pre> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>def __init__(\n    self,\n    tag: str,\n    gear_ratio: float,\n    motor_constants: MOTOR_CONSTANTS,\n    frequency: int = 1000,\n    offline: bool = False,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Initialize an actuator.\n\n    Args:\n        tag (str): A unique identifier for the actuator.\n        gear_ratio (float): The gear ratio of the actuator.\n        motor_constants (MOTOR_CONSTANTS): Motor constant configuration parameters.\n        frequency (int, optional): Control frequency in Hz. Defaults to 1000.\n        offline (bool, optional): Flag indicating if the actuator operates in offline mode. Defaults to False.\n        **kwargs (Any): Additional keyword arguments.\n\n    Examples:\n        &gt;&gt;&gt; actuator = DummyActuator(\n        ...     tag=\"act1\",\n        ...     gear_ratio=100,\n        ...     motor_constants=MOTOR_CONSTANTS(2048, 0.02, 0.001, 0.0001, 80.0, 120.0)\n        ... )\n    \"\"\"\n    self._MOTOR_CONSTANTS: MOTOR_CONSTANTS = motor_constants\n    self._gear_ratio: float = gear_ratio\n    self._tag: str = tag\n    self._frequency: int = frequency\n    self._data: Any = None\n    self._is_homed: bool = False\n\n    self._mode: CONTROL_MODES = CONTROL_MODES.IDLE\n\n    self._motor_zero_position: float = 0.0\n\n    self._is_open: bool = False\n    self._is_streaming: bool = False\n\n    self._original_methods: dict[str, MethodWithRequiredModes] = {}\n\n    # Initialize OfflineMixin first so _is_offline is available\n    super().__init__(offline=offline, **kwargs)\n\n    self._set_original_methods()\n    self._set_mutated_methods()\n</code></pre>"},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.home","title":"<code>home(homing_voltage=2000, homing_frequency=None, homing_direction=-1, output_position_offset=0.0, current_threshold=5000, velocity_threshold=0.001, callback=None)</code>  <code>abstractmethod</code>","text":"<p>Home the actuator.</p> <p>Aligns the actuator to a known reference position. Must be implemented by subclasses.</p> <p>Parameters:</p> Name Type Description Default <code>homing_voltage</code> <code>int</code> <p>Voltage to use for homing.</p> <code>2000</code> <code>homing_frequency</code> <code>Optional[int]</code> <p>Frequency to use for homing.</p> <code>None</code> <code>homing_direction</code> <code>int</code> <p>Direction to move the actuator during homing.</p> <code>-1</code> <code>output_position_offset</code> <code>float</code> <p>Offset to add to the output position.</p> <code>0.0</code> <code>current_threshold</code> <code>int</code> <p>Current threshold to stop homing.</p> <code>5000</code> <code>velocity_threshold</code> <code>float</code> <p>Velocity threshold to stop homing.</p> <code>0.001</code> <code>callback</code> <code>Optional[Callable[[], None]]</code> <p>Optional callback function to be         called when homing completes. The function should take no arguments and return None.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator.home()\nHomed\n</code></pre> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>@abstractmethod\ndef home(\n    self,\n    homing_voltage: int = 2000,\n    homing_frequency: Optional[int] = None,\n    homing_direction: int = -1,\n    output_position_offset: float = 0.0,\n    current_threshold: int = 5000,\n    velocity_threshold: float = 0.001,\n    callback: Optional[Callable[[], None]] = None,\n) -&gt; None:\n    \"\"\"\n    Home the actuator.\n\n    Aligns the actuator to a known reference position.\n    Must be implemented by subclasses.\n\n    Args:\n        homing_voltage (int): Voltage to use for homing.\n        homing_frequency (Optional[int]): Frequency to use for homing.\n        homing_direction (int): Direction to move the actuator during homing.\n        output_position_offset (float): Offset to add to the output position.\n        current_threshold (int): Current threshold to stop homing.\n        velocity_threshold (float): Velocity threshold to stop homing.\n        callback (Optional[Callable[[], None]]): Optional callback function to be\n                    called when homing completes. The function should take no arguments and return None.\n\n    Examples:\n        &gt;&gt;&gt; actuator.home()\n        Homed\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.set_control_mode","title":"<code>set_control_mode(mode)</code>","text":"<p>Set the actuator's control mode.</p> <p>If the mode is changing, the exit callback for the current mode and the entry callback for the new mode are executed, and methods are updated to reflect any restrictions imposed by the new mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>CONTROL_MODES</code> <p>The new control mode to be set.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator.set_control_mode(CONTROL_MODES.POSITION)\n</code></pre> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>def set_control_mode(self, mode: CONTROL_MODES) -&gt; None:\n    \"\"\"\n    Set the actuator's control mode.\n\n    If the mode is changing, the exit callback for the current mode and\n    the entry callback for the new mode are executed, and methods are updated\n    to reflect any restrictions imposed by the new mode.\n\n    Args:\n        mode (CONTROL_MODES): The new control mode to be set.\n\n    Examples:\n        &gt;&gt;&gt; actuator.set_control_mode(CONTROL_MODES.POSITION)\n    \"\"\"\n    if self.mode == mode:\n        LOGGER.debug(msg=f\"[{self.tag}] Already in {self.mode.name} control mode.\")\n        return\n\n    current_config = self._get_control_mode_config(self.mode)\n    if current_config:\n        current_config.exit_callback(self)\n\n    self._mode = mode\n\n    new_config = self._get_control_mode_config(self.mode)\n    if new_config:\n        new_config.entry_callback(self)\n\n    self._set_mutated_methods()\n</code></pre>"},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.set_current_gains","title":"<code>set_current_gains(kp, ki, kd, ff)</code>  <code>abstractmethod</code>","text":"<p>Set the current control gains.</p> <p>Parameters:</p> Name Type Description Default <code>kp</code> <code>float</code> <p>Proportional gain.</p> required <code>ki</code> <code>float</code> <p>Integral gain.</p> required <code>kd</code> <code>float</code> <p>Derivative gain.</p> required <code>ff</code> <code>float</code> <p>Feed-forward gain.</p> required <p>Must be implemented by subclasses.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator.set_current_gains(1.0, 0.1, 0.01, 0.0)\n</code></pre> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>@abstractmethod\ndef set_current_gains(self, kp: float, ki: float, kd: float, ff: float) -&gt; None:\n    \"\"\"\n    Set the current control gains.\n\n    Args:\n        kp (float): Proportional gain.\n        ki (float): Integral gain.\n        kd (float): Derivative gain.\n        ff (float): Feed-forward gain.\n\n    Must be implemented by subclasses.\n\n    Examples:\n        &gt;&gt;&gt; actuator.set_current_gains(1.0, 0.1, 0.01, 0.0)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.set_motor_current","title":"<code>set_motor_current(value)</code>  <code>abstractmethod</code>","text":"<p>Set the motor current.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The current value to be applied to the motor.</p> required <p>Must be implemented by subclasses.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator.set_motor_current(1.5)\n</code></pre> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>@abstractmethod\ndef set_motor_current(self, value: float) -&gt; None:\n    \"\"\"\n    Set the motor current.\n\n    Args:\n        value (float): The current value to be applied to the motor.\n\n    Must be implemented by subclasses.\n\n    Examples:\n        &gt;&gt;&gt; actuator.set_motor_current(1.5)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.set_motor_position","title":"<code>set_motor_position(value)</code>  <code>abstractmethod</code>","text":"<p>Set the motor position.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The target motor position in radians.</p> required <p>Must be implemented by subclasses.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator.set_motor_position(0.5)\n</code></pre> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>@abstractmethod\ndef set_motor_position(self, value: float) -&gt; None:\n    \"\"\"\n    Set the motor position.\n\n    Args:\n        value (float): The target motor position in radians.\n\n    Must be implemented by subclasses.\n\n    Examples:\n        &gt;&gt;&gt; actuator.set_motor_position(0.5)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.set_motor_torque","title":"<code>set_motor_torque(value)</code>  <code>abstractmethod</code>","text":"<p>Set the motor torque.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The torque value to be applied to the motor.</p> required <p>Must be implemented by subclasses.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator.set_motor_torque(5.0)\n</code></pre> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>@abstractmethod\ndef set_motor_torque(self, value: float) -&gt; None:\n    \"\"\"\n    Set the motor torque.\n\n    Args:\n        value (float): The torque value to be applied to the motor.\n\n    Must be implemented by subclasses.\n\n    Examples:\n        &gt;&gt;&gt; actuator.set_motor_torque(5.0)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.set_motor_voltage","title":"<code>set_motor_voltage(value)</code>  <code>abstractmethod</code>","text":"<p>Set the motor voltage.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The voltage value to be applied to the motor.</p> required <p>Must be implemented by subclasses.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator.set_motor_voltage(12.0)\n</code></pre> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>@abstractmethod\ndef set_motor_voltage(self, value: float) -&gt; None:\n    \"\"\"\n    Set the motor voltage.\n\n    Args:\n        value (float): The voltage value to be applied to the motor.\n\n    Must be implemented by subclasses.\n\n    Examples:\n        &gt;&gt;&gt; actuator.set_motor_voltage(12.0)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.set_motor_zero_position","title":"<code>set_motor_zero_position(value)</code>","text":"<p>Set the motor zero position.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The motor zero position in radians.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator.set_motor_zero_position(0.0)\n&gt;&gt;&gt; actuator.motor_zero_position\n0.0\n</code></pre> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>def set_motor_zero_position(self, value: float) -&gt; None:\n    \"\"\"\n    Set the motor zero position.\n\n    Args:\n        value (float): The motor zero position in radians.\n\n    Examples:\n        &gt;&gt;&gt; actuator.set_motor_zero_position(0.0)\n        &gt;&gt;&gt; actuator.motor_zero_position\n        0.0\n    \"\"\"\n    self._motor_zero_position = value\n</code></pre>"},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.set_output_position","title":"<code>set_output_position(value)</code>","text":"<p>Set the output position of the actuator.</p> <p>Converts the desired output position (in radians) to a motor position by applying the gear ratio, then delegates to <code>set_motor_position</code>.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The desired output position in radians.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Assuming gear_ratio is 100, this will set the motor position to 100 * value.\n&gt;&gt;&gt; actuator.set_motor_position = lambda value: print(f\"Motor position set to {value}\")\n&gt;&gt;&gt; actuator.set_output_position(1.0)\nMotor position set to 100.0\n</code></pre> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>def set_output_position(self, value: float) -&gt; None:\n    \"\"\"\n    Set the output position of the actuator.\n\n    Converts the desired output position (in radians) to a motor position by\n    applying the gear ratio, then delegates to `set_motor_position`.\n\n    Args:\n        value (float): The desired output position in radians.\n\n    Examples:\n        &gt;&gt;&gt; # Assuming gear_ratio is 100, this will set the motor position to 100 * value.\n        &gt;&gt;&gt; actuator.set_motor_position = lambda value: print(f\"Motor position set to {value}\")\n        &gt;&gt;&gt; actuator.set_output_position(1.0)\n        Motor position set to 100.0\n    \"\"\"\n    self.set_motor_position(value=value * self.gear_ratio)\n</code></pre>"},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.set_output_torque","title":"<code>set_output_torque(value)</code>  <code>abstractmethod</code>","text":"<p>Set the output torque.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The torque value to be applied to the joint.</p> required <p>Must be implemented by subclasses.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator.set_output_torque(5.0)\n</code></pre> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>@abstractmethod\ndef set_output_torque(self, value: float) -&gt; None:\n    \"\"\"\n    Set the output torque.\n\n    Args:\n        value (float): The torque value to be applied to the joint.\n\n    Must be implemented by subclasses.\n\n    Examples:\n        &gt;&gt;&gt; actuator.set_output_torque(5.0)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.set_position_gains","title":"<code>set_position_gains(kp, ki, kd, ff)</code>  <code>abstractmethod</code>","text":"<p>Set the position control gains.</p> <p>Parameters:</p> Name Type Description Default <code>kp</code> <code>float</code> <p>Proportional gain.</p> required <code>ki</code> <code>float</code> <p>Integral gain.</p> required <code>kd</code> <code>float</code> <p>Derivative gain.</p> required <code>ff</code> <code>float</code> <p>Feed-forward gain.</p> required <p>Must be implemented by subclasses.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator.set_position_gains(1.0, 0.1, 0.01, 0.0)\n</code></pre> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>@abstractmethod\ndef set_position_gains(self, kp: float, ki: float, kd: float, ff: float) -&gt; None:\n    \"\"\"\n    Set the position control gains.\n\n    Args:\n        kp (float): Proportional gain.\n        ki (float): Integral gain.\n        kd (float): Derivative gain.\n        ff (float): Feed-forward gain.\n\n    Must be implemented by subclasses.\n\n    Examples:\n        &gt;&gt;&gt; actuator.set_position_gains(1.0, 0.1, 0.01, 0.0)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.start","title":"<code>start()</code>  <code>abstractmethod</code>","text":"<p>Start the actuator.</p> <p>Must be implemented by subclasses to initialize and activate the actuator.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator.start()\nStarted\n</code></pre> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>@abstractmethod\ndef start(self) -&gt; None:\n    \"\"\"\n    Start the actuator.\n\n    Must be implemented by subclasses to initialize and activate the actuator.\n\n    Examples:\n        &gt;&gt;&gt; actuator.start()\n        Started\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.stop","title":"<code>stop()</code>  <code>abstractmethod</code>","text":"<p>Stop the actuator.</p> <p>Must be implemented by subclasses to safely deactivate the actuator.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator.stop()\nStopped\n</code></pre> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>@abstractmethod\ndef stop(self) -&gt; None:\n    \"\"\"\n    Stop the actuator.\n\n    Must be implemented by subclasses to safely deactivate the actuator.\n\n    Examples:\n        &gt;&gt;&gt; actuator.stop()\n        Stopped\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.ActuatorBase.update","title":"<code>update()</code>  <code>abstractmethod</code>","text":"<p>Update the actuator's state.</p> <p>Must be implemented by subclasses to refresh or recalculate state values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator.update()\nUpdated\n</code></pre> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>@abstractmethod\ndef update(self) -&gt; None:\n    \"\"\"\n    Update the actuator's state.\n\n    Must be implemented by subclasses to refresh or recalculate state values.\n\n    Examples:\n        &gt;&gt;&gt; actuator.update()\n        Updated\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.CONTROL_MODES","title":"<code>CONTROL_MODES</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum to define various control modes.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; CONTROL_MODES.POSITION\n&lt;CONTROL_MODES.POSITION: 0&gt;\n</code></pre> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>class CONTROL_MODES(Enum):\n    \"\"\"\n    Enum to define various control modes.\n\n    Examples:\n        &gt;&gt;&gt; CONTROL_MODES.POSITION\n        &lt;CONTROL_MODES.POSITION: 0&gt;\n    \"\"\"\n\n    IDLE = -1\n    POSITION = 0\n    VOLTAGE = 1\n    CURRENT = 2\n    IMPEDANCE = 3\n    VELOCITY = 4\n    TORQUE = 5\n</code></pre>"},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.CONTROL_MODE_CONFIGS","title":"<code>CONTROL_MODE_CONFIGS</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Named tuple containing control mode configurations.</p> <p>Attributes:</p> Name Type Description <code>IDLE</code> <code>Optional[ControlModeConfig]</code> <p>Configuration for IDLE mode.</p> <code>POSITION</code> <code>Optional[ControlModeConfig]</code> <p>Configuration for POSITION mode.</p> <code>CURRENT</code> <code>Optional[ControlModeConfig]</code> <p>Configuration for CURRENT mode.</p> <code>VOLTAGE</code> <code>Optional[ControlModeConfig]</code> <p>Configuration for VOLTAGE mode.</p> <code>IMPEDANCE</code> <code>Optional[ControlModeConfig]</code> <p>Configuration for IMPEDANCE mode.</p> <code>VELOCITY</code> <code>Optional[ControlModeConfig]</code> <p>Configuration for VELOCITY mode.</p> <code>TORQUE</code> <code>Optional[ControlModeConfig]</code> <p>Configuration for TORQUE mode.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; idle_config = ControlModeConfig(\n...     entry_callback=lambda a: print(\"Idle entered\"),\n...     exit_callback=lambda a: print(\"Idle exited\")\n...\n&gt;&gt;&gt; mode_configs = CONTROL_MODE_CONFIGS(IDLE=idle_config)\n&gt;&gt;&gt; mode_configs.IDLE.entry_callback(None)\nIdle entered\n</code></pre> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>class CONTROL_MODE_CONFIGS(NamedTuple):\n    \"\"\"\n    Named tuple containing control mode configurations.\n\n    Attributes:\n        IDLE (Optional[ControlModeConfig]): Configuration for IDLE mode.\n        POSITION (Optional[ControlModeConfig]): Configuration for POSITION mode.\n        CURRENT (Optional[ControlModeConfig]): Configuration for CURRENT mode.\n        VOLTAGE (Optional[ControlModeConfig]): Configuration for VOLTAGE mode.\n        IMPEDANCE (Optional[ControlModeConfig]): Configuration for IMPEDANCE mode.\n        VELOCITY (Optional[ControlModeConfig]): Configuration for VELOCITY mode.\n        TORQUE (Optional[ControlModeConfig]): Configuration for TORQUE mode.\n\n    Examples:\n        &gt;&gt;&gt; idle_config = ControlModeConfig(\n        ...     entry_callback=lambda a: print(\"Idle entered\"),\n        ...     exit_callback=lambda a: print(\"Idle exited\")\n        ...\n        &gt;&gt;&gt; mode_configs = CONTROL_MODE_CONFIGS(IDLE=idle_config)\n        &gt;&gt;&gt; mode_configs.IDLE.entry_callback(None)\n        Idle entered\n    \"\"\"\n\n    IDLE: Optional[ControlModeConfig] = None\n    POSITION: Optional[ControlModeConfig] = None\n    CURRENT: Optional[ControlModeConfig] = None\n    VOLTAGE: Optional[ControlModeConfig] = None\n    IMPEDANCE: Optional[ControlModeConfig] = None\n    VELOCITY: Optional[ControlModeConfig] = None\n    TORQUE: Optional[ControlModeConfig] = None\n</code></pre>"},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.ControlGains","title":"<code>ControlGains</code>  <code>dataclass</code>","text":"<p>Class to define the control gains.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; gains = ControlGains(kp=1.0, ki=0.1, kd=0.01, k=0.5, b=0.05, ff=0.0)\n&gt;&gt;&gt; gains.kp\n1.0\n</code></pre> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>@dataclass\nclass ControlGains:\n    \"\"\"\n    Class to define the control gains.\n\n    Examples:\n        &gt;&gt;&gt; gains = ControlGains(kp=1.0, ki=0.1, kd=0.01, k=0.5, b=0.05, ff=0.0)\n        &gt;&gt;&gt; gains.kp\n        1.0\n    \"\"\"\n\n    kp: float = 0\n    ki: float = 0\n    kd: float = 0\n    k: float = 0\n    b: float = 0\n    ff: float = 0\n</code></pre>"},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.ControlModeConfig","title":"<code>ControlModeConfig</code>  <code>dataclass</code>","text":"<p>Configuration for a control mode.</p> <p>Attributes:</p> Name Type Description <code>entry_callback</code> <code>Callable[[Any], None]</code> <p>Callback to execute when entering this mode.</p> <code>exit_callback</code> <code>Callable[[Any], None]</code> <p>Callback to execute when exiting this mode.</p> <code>has_gains</code> <code>bool</code> <p>Indicates if the control mode utilizes control gains.</p> <code>max_gains</code> <code>Union[ControlGains, None]</code> <p>The maximum allowable control gains (if applicable).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; def enter(actuator):\n...     print(\"Entering mode\")\n&gt;&gt;&gt; def exit(actuator):\n...     print(\"Exiting mode\")\n&gt;&gt;&gt; config = ControlModeConfig(\n...     entry_callback=enter,\n...     exit_callback=exit,\n...     has_gains=True,\n...     max_gains=ControlGains(1.0, 0.1, 0.01, 0.5, 0.05, 0.0)\n... )\n&gt;&gt;&gt; config.has_gains\nTrue\n</code></pre> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>@dataclass\nclass ControlModeConfig:\n    \"\"\"\n    Configuration for a control mode.\n\n    Attributes:\n        entry_callback (Callable[[Any], None]): Callback to execute when entering this mode.\n        exit_callback (Callable[[Any], None]): Callback to execute when exiting this mode.\n        has_gains (bool): Indicates if the control mode utilizes control gains.\n        max_gains (Union[ControlGains, None]): The maximum allowable control gains (if applicable).\n\n    Examples:\n        &gt;&gt;&gt; def enter(actuator):\n        ...     print(\"Entering mode\")\n        &gt;&gt;&gt; def exit(actuator):\n        ...     print(\"Exiting mode\")\n        &gt;&gt;&gt; config = ControlModeConfig(\n        ...     entry_callback=enter,\n        ...     exit_callback=exit,\n        ...     has_gains=True,\n        ...     max_gains=ControlGains(1.0, 0.1, 0.01, 0.5, 0.05, 0.0)\n        ... )\n        &gt;&gt;&gt; config.has_gains\n        True\n    \"\"\"\n\n    entry_callback: Callable[[Any], None]\n    exit_callback: Callable[[Any], None]\n    has_gains: bool = False\n    max_gains: Union[ControlGains, None] = None\n</code></pre>"},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.MOTOR_CONSTANTS","title":"<code>MOTOR_CONSTANTS</code>  <code>dataclass</code>","text":"<p>Class to define the motor constants.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; constants = MOTOR_CONSTANTS(\n...     MOTOR_COUNT_PER_REV=2048,\n...     NM_PER_AMP=0.02,\n...     NM_PER_RAD_TO_K=0.001,\n...     NM_S_PER_RAD_TO_B=0.0001,\n...     MAX_CASE_TEMPERATURE=80.0,\n...     MAX_WINDING_TEMPERATURE=120.0\n... )\n&gt;&gt;&gt; print(constants.MOTOR_COUNT_PER_REV)\n2048\n</code></pre> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>@dataclass\nclass MOTOR_CONSTANTS:\n    \"\"\"\n    Class to define the motor constants.\n\n    Examples:\n        &gt;&gt;&gt; constants = MOTOR_CONSTANTS(\n        ...     MOTOR_COUNT_PER_REV=2048,\n        ...     NM_PER_AMP=0.02,\n        ...     NM_PER_RAD_TO_K=0.001,\n        ...     NM_S_PER_RAD_TO_B=0.0001,\n        ...     MAX_CASE_TEMPERATURE=80.0,\n        ...     MAX_WINDING_TEMPERATURE=120.0\n        ... )\n        &gt;&gt;&gt; print(constants.MOTOR_COUNT_PER_REV)\n        2048\n    \"\"\"\n\n    MOTOR_COUNT_PER_REV: float\n    NM_PER_AMP: float  # Motor torque constant (Nm/A)\n    MAX_CASE_TEMPERATURE: float  # Hard limit for case/housing temperature\n    MAX_WINDING_TEMPERATURE: float  # Hard limit for winding temperature\n\n    # TMotor Servo Mode specific parameters (Servo Mode does not support PID)\n    NM_PER_RAD_TO_K: float = 0.001  # Default value for non-servo mode actuators\n    NM_S_PER_RAD_TO_B: float = 0.0001  # Default value for non-servo mode actuators\n\n    # Thermal model parameters from research paper (with defaults from Jake Schuchmann's tests)\n    WINDING_THERMAL_CAPACITANCE: float = 0.20 * 81.46202695970649  # Cw (J/\u00b0C)\n    CASE_THERMAL_CAPACITANCE: float = 512.249065845453  # Ch (J/\u00b0C)\n    WINDING_TO_CASE_RESISTANCE: float = 1.0702867186480716  # Rw-h (\u00b0C/W)\n    CASE_TO_AMBIENT_RESISTANCE: float = 1.9406620046327363  # Rh-a (\u00b0C/W)\n    COPPER_TEMPERATURE_COEFFICIENT: float = 0.393 / 100  # alpha (1/\u00b0C)\n    REFERENCE_TEMPERATURE: float = 65.0  # Reference temperature for resistance (\u00b0C)\n    REFERENCE_RESISTANCE: float = 0.376  # Reference resistance at reference temp (Ohms)\n\n    WINDING_SOFT_LIMIT: float = 70.0  # soft winding limit (\u00b0C)\n    CASE_SOFT_LIMIT: float = 60.0  # soft case limit (\u00b0C)\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"\n        Function to validate the motor constants and thermal parameters.\n\n        Examples:\n            &gt;&gt;&gt; # This will raise a ValueError because a negative value is invalid.\n            &gt;&gt;&gt; MOTOR_CONSTANTS(\n            ...     MOTOR_COUNT_PER_REV=-2048,\n            ...     NM_PER_AMP=0.02,\n            ...     MAX_CASE_TEMPERATURE=80.0,\n            ...     MAX_WINDING_TEMPERATURE=120.0\n            ... )\n        \"\"\"\n        if any(x &lt;= 0 for x in self.__dict__.values()):\n            raise ValueError(\"All values in MOTOR_CONSTANTS must be non-zero and positive.\")\n\n        # Validate thermal safety limits\n        if self.MAX_WINDING_TEMPERATURE &lt;= self.MAX_CASE_TEMPERATURE:\n            raise ValueError(\"MAX_WINDING_TEMPERATURE must be greater than MAX_CASE_TEMPERATURE\")\n        if self.WINDING_SOFT_LIMIT &gt;= self.MAX_WINDING_TEMPERATURE:\n            raise ValueError(\"WINDING_SOFT_LIMIT must be less than MAX_WINDING_TEMPERATURE\")\n        if self.CASE_SOFT_LIMIT &gt;= self.MAX_CASE_TEMPERATURE:\n            raise ValueError(\"CASE_SOFT_LIMIT must be less than MAX_CASE_TEMPERATURE\")\n\n    @property\n    def RAD_PER_COUNT(self) -&gt; float:\n        \"\"\"\n        Calculate the radians per count.\n\n        Returns:\n            float: Radians per count.\n\n        Examples:\n            &gt;&gt;&gt; constants = MOTOR_CONSTANTS(2048, 0.02, 0.001, 0.0001, 80.0, 120.0)\n            &gt;&gt;&gt; constants.RAD_PER_COUNT\n            0.0030679615757712823\n        \"\"\"\n        return 2 * np.pi / self.MOTOR_COUNT_PER_REV\n\n    @property\n    def NM_PER_MILLIAMP(self) -&gt; float:\n        \"\"\"\n        Convert NM per amp to NM per milliamp.\n\n        Returns:\n            float: NM per milliamp.\n\n        Examples:\n            &gt;&gt;&gt; constants = MOTOR_CONSTANTS(2048, 0.02, 0.001, 0.0001, 80.0, 120.0)\n            &gt;&gt;&gt; constants.NM_PER_MILLIAMP\n            2e-05\n        \"\"\"\n        return self.NM_PER_AMP / 1000\n</code></pre>"},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.MOTOR_CONSTANTS.NM_PER_MILLIAMP","title":"<code>NM_PER_MILLIAMP</code>  <code>property</code>","text":"<p>Convert NM per amp to NM per milliamp.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>NM per milliamp.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; constants = MOTOR_CONSTANTS(2048, 0.02, 0.001, 0.0001, 80.0, 120.0)\n&gt;&gt;&gt; constants.NM_PER_MILLIAMP\n2e-05\n</code></pre>"},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.MOTOR_CONSTANTS.RAD_PER_COUNT","title":"<code>RAD_PER_COUNT</code>  <code>property</code>","text":"<p>Calculate the radians per count.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Radians per count.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; constants = MOTOR_CONSTANTS(2048, 0.02, 0.001, 0.0001, 80.0, 120.0)\n&gt;&gt;&gt; constants.RAD_PER_COUNT\n0.0030679615757712823\n</code></pre>"},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.MOTOR_CONSTANTS.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Function to validate the motor constants and thermal parameters.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # This will raise a ValueError because a negative value is invalid.\n&gt;&gt;&gt; MOTOR_CONSTANTS(\n...     MOTOR_COUNT_PER_REV=-2048,\n...     NM_PER_AMP=0.02,\n...     MAX_CASE_TEMPERATURE=80.0,\n...     MAX_WINDING_TEMPERATURE=120.0\n... )\n</code></pre> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"\n    Function to validate the motor constants and thermal parameters.\n\n    Examples:\n        &gt;&gt;&gt; # This will raise a ValueError because a negative value is invalid.\n        &gt;&gt;&gt; MOTOR_CONSTANTS(\n        ...     MOTOR_COUNT_PER_REV=-2048,\n        ...     NM_PER_AMP=0.02,\n        ...     MAX_CASE_TEMPERATURE=80.0,\n        ...     MAX_WINDING_TEMPERATURE=120.0\n        ... )\n    \"\"\"\n    if any(x &lt;= 0 for x in self.__dict__.values()):\n        raise ValueError(\"All values in MOTOR_CONSTANTS must be non-zero and positive.\")\n\n    # Validate thermal safety limits\n    if self.MAX_WINDING_TEMPERATURE &lt;= self.MAX_CASE_TEMPERATURE:\n        raise ValueError(\"MAX_WINDING_TEMPERATURE must be greater than MAX_CASE_TEMPERATURE\")\n    if self.WINDING_SOFT_LIMIT &gt;= self.MAX_WINDING_TEMPERATURE:\n        raise ValueError(\"WINDING_SOFT_LIMIT must be less than MAX_WINDING_TEMPERATURE\")\n    if self.CASE_SOFT_LIMIT &gt;= self.MAX_CASE_TEMPERATURE:\n        raise ValueError(\"CASE_SOFT_LIMIT must be less than MAX_CASE_TEMPERATURE\")\n</code></pre>"},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.MethodWithRequiredModes","title":"<code>MethodWithRequiredModes</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for methods that define required control modes.</p> <p>Attributes:</p> Name Type Description <code>_required_modes</code> <code>set[CONTROL_MODES]</code> <p>A set of control modes in which the method is permitted.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class Dummy:\n...     _required_modes = {CONTROL_MODES.IDLE}\n&gt;&gt;&gt; isinstance(Dummy(), MethodWithRequiredModes)\nTrue\n</code></pre> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>@runtime_checkable\nclass MethodWithRequiredModes(Protocol):\n    \"\"\"\n    Protocol for methods that define required control modes.\n\n    Attributes:\n        _required_modes (set[CONTROL_MODES]): A set of control modes in which the method is permitted.\n\n    Examples:\n        &gt;&gt;&gt; class Dummy:\n        ...     _required_modes = {CONTROL_MODES.IDLE}\n        &gt;&gt;&gt; isinstance(Dummy(), MethodWithRequiredModes)\n        True\n    \"\"\"\n\n    _required_modes: set[CONTROL_MODES]\n</code></pre>"},{"location":"api/actuators/actuators/#opensourceleg.actuators.base.requires","title":"<code>requires(*modes)</code>","text":"<p>Decorator to specify required control modes for a method.</p> <p>The decorator attaches a set of required modes to the function, ensuring that the function is only active in the specified control modes.</p> <p>Parameters:</p> Name Type Description Default <code>*modes</code> <code>CONTROL_MODES</code> <p>One or more control modes required for the method.</p> <code>()</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>If any argument is not an instance of CONTROL_MODES.</p> <p>Returns:</p> Type Description <code>Callable[[T], T]</code> <p>Callable[[T], T]: The decorated function with an attached <code>_required_modes</code> attribute.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; @requires(CONTROL_MODES.POSITION, CONTROL_MODES.TORQUE)\n... def some_method(self, value):\n...     return value\n&gt;&gt;&gt; some_method._required_modes  # May output: {&lt;CONTROL_MODES.POSITION: 0&gt;, &lt;CONTROL_MODES.TORQUE: 5&gt;}\n</code></pre> Source code in <code>opensourceleg/actuators/base.py</code> <pre><code>def requires(*modes: CONTROL_MODES) -&gt; Callable[[T], T]:\n    \"\"\"\n    Decorator to specify required control modes for a method.\n\n    The decorator attaches a set of required modes to the function,\n    ensuring that the function is only active in the specified control modes.\n\n    Args:\n        *modes (CONTROL_MODES): One or more control modes required for the method.\n\n    Raises:\n        TypeError: If any argument is not an instance of CONTROL_MODES.\n\n    Returns:\n        Callable[[T], T]: The decorated function with an attached `_required_modes` attribute.\n\n    Examples:\n        &gt;&gt;&gt; @requires(CONTROL_MODES.POSITION, CONTROL_MODES.TORQUE)\n        ... def some_method(self, value):\n        ...     return value\n        &gt;&gt;&gt; some_method._required_modes  # May output: {&lt;CONTROL_MODES.POSITION: 0&gt;, &lt;CONTROL_MODES.TORQUE: 5&gt;}\n    \"\"\"\n\n    def decorator(func: T) -&gt; T:\n        \"\"\"\n        Attach required control modes to the decorated function.\n\n        Args:\n            func (T): The function to be decorated.\n\n        Returns:\n            T: The same function with an updated `_required_modes` attribute.\n        \"\"\"\n        if not all(isinstance(mode, CONTROL_MODES) for mode in modes):\n            raise TypeError(\"All arguments to 'requires' must be of type CONTROL_MODES\")\n\n        if not hasattr(func, \"_required_modes\"):\n            func._required_modes = set(modes)  # type: ignore[attr-defined]\n        else:\n            func._required_modes.update(modes)\n\n        return func\n\n    return decorator\n</code></pre>"},{"location":"api/actuators/dephy/","title":"Dephy","text":""},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator","title":"<code>DephyActuator</code>","text":"<p>               Bases: <code>Device</code>, <code>ActuatorBase</code></p> <p>Interface to a Dephy actuator device.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0', gear_ratio=2.0)\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; actuator.set_motor_voltage(1500)\n&gt;&gt;&gt; print(f\"Output position: {actuator.output_position:.2f} rad\")\n</code></pre> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>class DephyActuator(Device, ActuatorBase):  # type: ignore[no-any-unimported]\n    \"\"\"\n    Interface to a Dephy actuator device.\n\n    Examples:\n        &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0', gear_ratio=2.0)\n        &gt;&gt;&gt; actuator.start()\n        &gt;&gt;&gt; actuator.set_motor_voltage(1500)\n        &gt;&gt;&gt; print(f\"Output position: {actuator.output_position:.2f} rad\")\n    \"\"\"\n\n    def __init__(\n        self,\n        tag: str = \"DephyActuator\",\n        firmware_version: str = \"7.2.0\",\n        port: str = \"/dev/ttyACM0\",\n        gear_ratio: float = 1.0,\n        baud_rate: int = 230400,\n        frequency: int = 500,\n        debug_level: int = 4,\n        dephy_log: bool = False,\n        offline: bool = False,\n        stop_motor_on_disconnect: bool = True,\n    ) -&gt; None:\n        ActuatorBase.__init__(\n            self,\n            tag=tag,\n            gear_ratio=gear_ratio,\n            motor_constants=DEPHY_ACTUATOR_CONSTANTS,\n            frequency=frequency,\n            offline=offline,\n        )\n\n        # Override motor constants to ensure setter is called\n        self.MOTOR_CONSTANTS = DEPHY_ACTUATOR_CONSTANTS\n\n        self._debug_level: int = debug_level if dephy_log else 6\n        self._dephy_log: bool = dephy_log\n\n        if self.is_offline:\n            self.port = port\n            self._is_streaming: bool = False\n            self._is_open: bool = False\n        else:\n            Device.__init__(\n                self,\n                firmwareVersion=firmware_version,\n                port=port,\n                baudRate=baud_rate,\n                logLevel=self._debug_level,\n                debug=dephy_log,\n                stopMotorOnDisconnect=stop_motor_on_disconnect,\n            )\n\n        self._thermal_model: ThermalModel = ThermalModel(\n            motor_constants=self.MOTOR_CONSTANTS,\n            actuator_tag=self.tag,\n        )\n        self._thermal_scale: float = 1.0\n\n        self._i2t_fault_count: int = 0\n        self._i2t_fault_threshold: int = 2\n\n        self._mode = CONTROL_MODES.IDLE\n\n        self._impedance_gains = dataclasses.replace(DEFAULT_IMPEDANCE_GAINS)\n\n    def __repr__(self) -&gt; str:\n        return f\"{self.tag}[DephyActuator]\"\n\n    @property\n    def _CONTROL_MODE_CONFIGS(self) -&gt; CONTROL_MODE_CONFIGS:\n        return DEPHY_CONTROL_MODE_CONFIGS\n\n    @check_actuator_connection\n    def start(self) -&gt; None:\n        \"\"\"\n        Starts the actuator by opening the port, starting data streaming,\n        reading initial data, and setting the control mode to VOLTAGE.\n\n        Returns:\n            None\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n        \"\"\"\n        try:\n            self.open()\n            self._is_open = True\n        except OSError:\n            print(\"\\n\")\n            LOGGER.error(\n                msg=f\"[{self.__repr__()}] Need admin previleges to open the port '{self.port}'. \\n\\n \\\n                    Please run the script with 'sudo' command or add the user to the dialout group.\\n\"\n            )\n            os._exit(status=1)\n\n        self.start_streaming(self._frequency)\n        time.sleep(0.2)\n        self._is_streaming = True\n\n        self._data = self.read()\n        self.set_control_mode(CONTROL_MODES.VOLTAGE)\n\n    @check_actuator_stream\n    @check_actuator_open\n    def stop(self) -&gt; None:\n        \"\"\"\n        Stops the actuator by stopping the motor, switching to IDLE mode,\n        stopping data streaming, and closing the connection.\n\n        Returns:\n            None\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; # ... perform control tasks ...\n            &gt;&gt;&gt; actuator.stop()\n        \"\"\"\n        self.stop_motor()\n        self.set_control_mode(mode=CONTROL_MODES.IDLE)\n        self._is_streaming = False\n        self._is_open = False\n        self.stop_streaming()\n        self.close()\n\n    def update(self) -&gt; None:\n        \"\"\"\n        Updates the actuator's data by reading new values and updating the thermal model.\n        It raises exceptions if thermal limits are exceeded.\n\n        Returns:\n            None\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator()\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; actuator.update()\n            &gt;&gt;&gt; print(f\"Motor current: {actuator.motor_current} mA\")\n        \"\"\"\n        self._data = self.read()\n\n        self._thermal_scale = self._thermal_model.update(\n            dt=1 / self.frequency,\n            motor_current=self.motor_current,\n            case_temperature=self.case_temperature,\n        )\n\n        self._check_i2t_fault()\n\n    def _check_i2t_fault(self) -&gt; None:\n        \"\"\"\n        Checks for I2t faults and manage fault counting.\n        Raises I2tLimitException if fault threshold is exceeded.\n        \"\"\"\n        # Check for thermal fault, bit 2 of the execute status byte\n        if self._data[\"status_ex\"] &amp; 0b00000010 == 0b00000010:\n            self._i2t_fault_count += 1\n\n            # Only raise exception after multiple consecutive faults\n            if self._i2t_fault_count &gt;= self._i2t_fault_threshold:\n                LOGGER.error(\n                    msg=f\"[{str.upper(self.tag)}] I2t limit exceeded \"\n                    f\"(Maximum Average Current limit exceeded for time at current limit) \"\n                    f\"for {self._i2t_fault_count} consecutive readings. Current: {self.motor_current} mA. \"\n                    f\"Review physical setup to ensure excessive torque is not normally applied. \"\n                    \"If issue persists, review 'Maximum Average Current', \"\n                    \"'Current Limit', and 'Time at current limit' settings \"\n                    f\"for the Dephy ActPack Firmware using the Plan GUI software.\"\n                )\n                raise I2tLimitException()\n            else:\n                LOGGER.warning(\n                    msg=f\"[{str.upper(self.tag)}] I2t fault detected \"\n                    f\"({self._i2t_fault_count}/{self._i2t_fault_threshold}). \"\n                    f\"Current: {self.motor_current} mA. Monitoring for consecutive faults.\"\n                )\n        else:\n            self._i2t_fault_count = 0\n\n    def set_i2t_fault_threshold(self, threshold: int) -&gt; None:\n        \"\"\"\n        Sets the threshold for consecutive I2t faults before raising an exception.\n\n        This helps filter out spurious one-off bit flips in the status_ex register\n        by requiring multiple consecutive fault detections before triggering the exception.\n\n        Args:\n            threshold: Number of consecutive faults required to trigger exception.\n                           Default is 2. Must be &gt;= 1.\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.set_i2t_fault_threshold(5)  # Require 5 consecutive faults\n        \"\"\"\n        if threshold &lt; 1:\n            raise ValueError(\"I2t fault threshold must be &gt;= 1\")\n\n        self._i2t_fault_threshold = threshold\n        LOGGER.info(f\"[{self.tag}] I2t fault threshold set to {threshold} consecutive faults\")\n\n    def home(\n        self,\n        homing_voltage: int = 2000,\n        homing_frequency: Optional[int] = None,\n        homing_direction: int = -1,\n        output_position_offset: float = 0.0,\n        current_threshold: int = 5000,\n        velocity_threshold: float = 0.001,\n        callback: Optional[Callable[[], None]] = None,\n    ) -&gt; None:\n        \"\"\"\n\n        This method homes the actuator and the corresponding joint by moving it to the zero position.\n        The zero position is defined as the position where the joint is fully extended. This method will\n        also load the encoder map if it exists. The encoder map is a polynomial that maps the encoder counts\n        to joint position in radians. This is useful for more accurate joint position estimation.\n\n        Args:\n            homing_voltage (int): Voltage in mV to use for homing.\n                Default is 2000 mV.\n            homing_frequency (int): Frequency in Hz to use for homing.\n                Default is the actuator's frequency.\n            homing_direction (int): Direction to move the actuator during homing.\n                Default is -1.\n            output_position_offset (float): Offset in radians to add to the output position.\n                Default is 0.0.\n            current_threshold (int): Current threshold in mA to stop homing the joint or actuator.\n                This is used to detect if the actuator or joint has hit a hard stop.\n                Default is 5000 mA.\n            velocity_threshold (float): Velocity threshold in rad/s to stop homing the joint or actuator.\n                This is also used to detect if the actuator or joint has hit a hard stop.\n                Default is 0.001 rad/s.\n            callback (Optional[Callable[[], None]]): Optional callback function to be called when homing completes.\n                                                        The function should take no arguments and return None.\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; actuator.home(homing_voltage=2000, homing_direction=-1)\n\n        \"\"\"\n        is_homing = True\n        homing_frequency = homing_frequency if homing_frequency is not None else self.frequency\n\n        LOGGER.info(\n            f\"[{str.upper(self.tag)}] Homing {self.tag} joint. \"\n            \"Please make sure the joint is free to move and press Enter to continue.\"\n        )\n        input()\n\n        self.set_control_mode(mode=CONTROL_MODES.VOLTAGE)\n\n        self.set_motor_voltage(value=homing_direction * homing_voltage)  # mV, negative for counterclockwise\n\n        time.sleep(0.1)\n\n        try:\n            while is_homing:\n                self.update()\n                time.sleep(1 / homing_frequency)\n\n                if abs(self.output_velocity) &lt;= velocity_threshold or abs(self.motor_current) &gt;= current_threshold:\n                    self.set_motor_voltage(value=0)\n                    if callback is not None:\n                        callback()\n                    is_homing = False\n\n        except KeyboardInterrupt:\n            self.set_motor_voltage(value=0)\n            LOGGER.info(msg=f\"[{str.upper(self.tag)}] Homing interrupted.\")\n            return\n        except Exception as e:\n            self.set_motor_voltage(value=0)\n            LOGGER.error(msg=f\"[{str.upper(self.tag)}] Homing failed: {e}\")\n            return\n\n        self.set_motor_zero_position(value=self.motor_position + output_position_offset * self.gear_ratio)\n\n        time.sleep(0.1)\n\n        self._is_homed = True\n        LOGGER.info(f\"[{str.upper(self.tag)}] Homing complete.\")\n\n    def set_motor_torque(self, value: float) -&gt; None:\n        \"\"\"\n        Sets the motor torque in Nm. This is the torque that is applied to the motor rotor, not the joint or output.\n        Args:\n            value (float): The torque to set in Nm.\n        Returns:\n            None\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; actuator.set_motor_torque(0.1)\n        \"\"\"\n        self.set_motor_current(\n            value / self.MOTOR_CONSTANTS.NM_PER_MILLIAMP,\n        )\n\n    def set_output_torque(self, value: float) -&gt; None:\n        \"\"\"\n        Set the output torque of the joint.\n        This is the torque that is applied to the joint, not the motor.\n\n        Args:\n            value (float): torque in N_m\n\n        Returns:\n            None\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; actuator.set_output_torque(0.1)\n        \"\"\"\n        self.set_motor_torque(value=value / self.gear_ratio)\n\n    def set_motor_current(\n        self,\n        value: float,\n    ) -&gt; None:\n        \"\"\"\n        Sets the motor current in mA.\n\n        Args:\n            value (float): The current to set in mA.\n        Returns:\n            None\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; actuator.set_motor_current(1000)\n        \"\"\"\n        self.command_motor_current(value=int(value))\n\n    @deprecated_with_routing(alternative_func=set_motor_current)\n    def set_current(self, value: float) -&gt; None:\n        self.command_motor_current(value=int(value))\n\n    def set_motor_voltage(self, value: float) -&gt; None:\n        \"\"\"\n        Sets the motor voltage in mV.\n\n        Args:\n            value (float): The voltage to set in mV.\n\n        Returns:\n            None\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; actuator.set_motor_voltage(100) TODO: Validate number\n        \"\"\"\n        self.command_motor_voltage(value=int(value))\n\n    @deprecated_with_routing(alternative_func=set_motor_voltage)\n    def set_voltage(self, value: float) -&gt; None:\n        self.command_motor_voltage(value=int(value))\n\n    def set_motor_position(self, value: float) -&gt; None:\n        \"\"\"\n        Sets the motor position in radians.\n        If in impedance mode, this sets the equilibrium angle in radians.\n\n        Args:\n            value (float): The position to set\n\n        Returns:\n            None\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; actuator.set_motor_position(0.1)\n        \"\"\"\n        # TODO: New Dephy API splits impedance equilibrium position and position control into separate methods\n        if self.mode == CONTROL_MODES.POSITION:\n            self.command_motor_position(\n                value=int((value + self.motor_zero_position) / self.MOTOR_CONSTANTS.RAD_PER_COUNT),\n            )\n        elif self.mode == CONTROL_MODES.IMPEDANCE:\n            self.command_motor_impedance(\n                value=int((value + self.motor_zero_position) / self.MOTOR_CONSTANTS.RAD_PER_COUNT),\n            )\n        else:\n            raise ControlModeException(tag=self._tag, attribute=\"set_motor_position\", mode=self._mode.name)\n\n    def set_position_gains(\n        self,\n        kp: float = DEFAULT_POSITION_GAINS.kp,\n        ki: float = DEFAULT_POSITION_GAINS.ki,\n        kd: float = DEFAULT_POSITION_GAINS.kd,\n        ff: float = DEFAULT_POSITION_GAINS.ff,\n    ) -&gt; None:\n        \"\"\"\n        Sets the position gains in arbitrary Dephy units.\n\n        Args:\n            kp (float): The proportional gain\n            ki (float): The integral gain\n            kd (float): The derivative gain\n            ff (float): The feedforward gain\n\n        Returns:\n            None\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; actuator.set_position_gains(kp=30, ki=0, kd=0, ff=0)\n        \"\"\"\n        self.set_gains(\n            kp=int(kp),\n            ki=int(ki),\n            kd=int(kd),\n            k=0,\n            b=0,\n            ff=int(ff),\n        )\n\n    def set_current_gains(\n        self,\n        kp: float = DEFAULT_CURRENT_GAINS.kp,\n        ki: float = DEFAULT_CURRENT_GAINS.ki,\n        kd: float = DEFAULT_CURRENT_GAINS.kd,\n        ff: float = DEFAULT_CURRENT_GAINS.ff,\n    ) -&gt; None:\n        \"\"\"\n        Sets the current gains in arbitrary Dephy units.\n\n        Args:\n            kp (float): The proportional gain\n            ki (float): The integral gain\n            kd (float): The derivative gain\n            ff (float): The feedforward gain\n\n        Returns:\n            None\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; actuator.set_current_gains(kp=40, ki=400, kd=0, ff=128)\n        \"\"\"\n        self.set_gains(\n            kp=int(kp),\n            ki=int(ki),\n            kd=int(kd),\n            k=0,\n            b=0,\n            ff=int(ff),\n        )\n\n    def set_output_impedance(\n        self,\n        k: float = 153.66,\n        b: float = 6.56,\n    ) -&gt; None:\n        \"\"\"\n        Set the impedance gains of the joint in real units: Nm/rad and Nm/rad/s.\n        This sets the impedance at the output and automatically scales based on gear ratios.\n        Note: Default k and b calculated from the default motor impedance k, b for gear ratio 41.5\n        Conversion:\n            K_motor = K_joint / (gear_ratio ** 2)\n            B_motor = B_joint / (gear_ratio ** 2)\n\n        Args:\n            k (float): Spring constant. Defaults to 100 Nm/rad.\n            b (float): Damping constant. Defaults to 3.0 Nm/rad/s.\n\n        Returns:\n            None\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; actuator.set_output_impedance(k=100, b=3)\n        \"\"\"\n\n        self.set_motor_impedance(\n            k=k / (self.gear_ratio**2),\n            b=b / (self.gear_ratio**2),\n        )\n\n    def set_impedance_cc_pidf_gains(\n        self,\n        kp: float = DEFAULT_IMPEDANCE_GAINS.kp,\n        ki: float = DEFAULT_IMPEDANCE_GAINS.ki,\n        kd: float = DEFAULT_IMPEDANCE_GAINS.kd,\n        ff: float = DEFAULT_IMPEDANCE_GAINS.ff,\n    ) -&gt; None:\n        \"\"\"\n        Caches the PID &amp; feedforward gains used in the current controller within the impedance control mode.\n\n        This does not configure the physical parameters (`k` and `b`)\n        which are set via `set_output_impedance` or `set_motor_impedance`.\n\n        Calling this method is optional - if not called before using the\n        impedance setters, a set of default gains will automatically be used.\n\n        Args:\n            kp (float): Proportional gain. Defaults to 40.\n            ki (float): Integral gain. Defaults to 400.\n            kd (float): Derivative gain. Defaults to 0.\n            ff (float): Feedforward gain. Defaults to 128.\n\n        Returns:\n            None\n        \"\"\"\n        self._impedance_gains = ControlGains(kp, ki, kd, 0, 0, ff)\n\n    def _set_impedance_gains(\n        self,\n        k: float = DEFAULT_IMPEDANCE_GAINS.k,\n        b: float = DEFAULT_IMPEDANCE_GAINS.b,\n    ) -&gt; None:\n        \"\"\"\n        Internal method which sets the impedance gains in arbitrary actpack units.\n        See Dephy's webpage for conversions or use other library methods that handle conversion for you.\n\n        Args:\n            k (float): The spring constant\n            b (float): The damping constant\n\n        Returns:\n            None\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; actuator._set_impedance_gains(k=200, b=400)\n        \"\"\"\n        gains = self._impedance_gains\n        self.set_gains(\n            kp=int(gains.kp),\n            ki=int(gains.ki),\n            kd=int(gains.kd),\n            k=int(k),\n            b=int(b),\n            ff=int(gains.ff),\n        )\n\n    def set_motor_impedance(\n        self,\n        k: float = 0.08922,\n        b: float = 0.0038070,\n    ) -&gt; None:\n        \"\"\"\n        Set the impedance gains of the motor in real units: Nm/rad and Nm/rad/s.\n\n        Args:\n            k (float): Spring constant. Defaults to 0.08922 Nm/rad.\n            b (float): Damping constant. Defaults to 0.0038070 Nm/rad/s.\n\n        Returns:\n            None\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; actuator.set_motor_impedance(k=0.08922, b=0.0038070)\n        \"\"\"\n        if k &lt; 0:\n            raise ValueError(f\"Stiffness k={k} cannot be negative\")\n        if b &lt; 0:\n            raise ValueError(f\"Damping b={b} cannot be negative\")\n\n        self._set_impedance_gains(\n            k=int(k * self.NM_PER_RAD_TO_MOTOR_UNITS),\n            b=int(b * self.NM_S_PER_RAD_TO_MOTOR_UNITS),\n        )\n\n    @property\n    def MOTOR_CONSTANTS(self) -&gt; MOTOR_CONSTANTS:\n        \"\"\"\n        Get the motor constants configuration.\n        Redefines the property from the ABC so we can set a setter.\n\n        Returns:\n            MOTOR_CONSTANTS: The motor constants.\n\n        Examples:\n            &gt;&gt;&gt; constants = actuator.MOTOR_CONSTANTS\n            &gt;&gt;&gt; constants.MAX_CASE_TEMPERATURE\n            80.0\n        \"\"\"\n        return self._MOTOR_CONSTANTS\n\n    @MOTOR_CONSTANTS.setter\n    def MOTOR_CONSTANTS(self, value: MOTOR_CONSTANTS) -&gt; None:\n        \"\"\"\n        Setter for MOTOR_CONSTANTS property.\n        Updates the motor constants and recalculates derived conversion factors.\n\n        Args:\n            value (MOTOR_CONSTANTS): New motor constants to set.\n        \"\"\"\n\n        if not isinstance(value, MOTOR_CONSTANTS):\n            raise TypeError(f\"Expected MOTOR_CONSTANTS, got {type(value)}\")\n        self._MOTOR_CONSTANTS = value\n        self._update_derived_constants()\n\n    def _update_derived_constants(self) -&gt; None:\n        \"\"\"\n        Recalculate conversion factors based on current motor constants.\n        Updates NM_PER_RAD_TO_MOTOR_UNITS and NM_S_PER_RAD_TO_MOTOR_UNITS.\n        \"\"\"\n        self.NM_PER_RAD_TO_MOTOR_UNITS = (\n            (2 * np.pi / self.MOTOR_CONSTANTS.MOTOR_COUNT_PER_REV) / IMPEDANCE_C * 1e3 / self.MOTOR_CONSTANTS.NM_PER_AMP\n        )\n        self.NM_S_PER_RAD_TO_MOTOR_UNITS = (np.pi / 180) / IMPEDANCE_A * 1e3 / self.MOTOR_CONSTANTS.NM_PER_AMP\n\n    @property\n    def motor_voltage(self) -&gt; float:\n        \"\"\"\n        Q-axis motor voltage in mV.\n\n        Returns:\n            float: Motor voltage in mV.\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; print(f\"Motor voltage: {actuator.motor_voltage} mV\")\n        \"\"\"\n        if self._data is not None:\n            return float(self._data[\"mot_volt\"])\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def motor_current(self) -&gt; float:\n        \"\"\"\n        Motor current in mA.\n\n        Returns:\n            float: Motor current in mA.\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; print(f\"Motor current: {actuator.motor_current} mA\")\n        \"\"\"\n        if self._data is not None:\n            return float(self._data[\"mot_cur\"])\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def motor_torque(self) -&gt; float:\n        \"\"\"\n        Torque at the motor output in Nm.\n\n        Returns:\n            float: Motor torque in Nm.\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; print(f\"Motor torque: {actuator.motor_torque} Nm\")\n        \"\"\"\n        if self._data is not None:\n            return float(self._data[\"mot_cur\"] * self.MOTOR_CONSTANTS.NM_PER_MILLIAMP)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def motor_position(self) -&gt; float:\n        \"\"\"\n        Motor position in radians.\n\n        Returns:\n            float: Motor position in radians.\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; print(f\"Motor position: {actuator.motor_position} rad\")\n        \"\"\"\n        if self._data is not None:\n            return float(self._data[\"mot_ang\"] * self.MOTOR_CONSTANTS.RAD_PER_COUNT) - self.motor_zero_position\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def motor_encoder_counts(self) -&gt; int:\n        \"\"\"\n        Raw reading from motor encoder in counts.\n\n        Returns:\n            int: Motor encoder counts.\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; print(f\"Motor encoder counts: {actuator.motor_encoder_counts}\")\n        \"\"\"\n        if self._data is not None:\n            return int(self._data[\"mot_ang\"])\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.\"\n            )\n            return 0\n\n    @property\n    def motor_velocity(self) -&gt; float:\n        \"\"\"\n        Motor velocity in rad/s.\n\n        Returns:\n            float: Motor velocity in rad/s.\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; print(f\"Motor velocity: {actuator.motor_velocity} rad/s\")\n        \"\"\"\n\n        if self._data is not None:\n            return int(self._data[\"mot_vel\"]) * RAD_PER_DEG\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def motor_acceleration(self) -&gt; float:\n        \"\"\"\n        Motor acceleration in rad/s^2.\n\n        Returns:\n            float: Motor acceleration in rad/s^2.\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; print(f\"Motor acceleration: {actuator.motor_acceleration} rad/s^2\")\n        \"\"\"\n\n        if self._data is not None:\n            return float(self._data[\"mot_acc\"])\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def battery_voltage(self) -&gt; float:\n        \"\"\"\n        Battery voltage in mV.\n\n        Returns:\n            float: Battery voltage in mV.\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; print(f\"Battery voltage: {actuator.battery_voltage} mV\")\n        \"\"\"\n        if self._data is not None:\n            return float(self._data[\"batt_volt\"])\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def battery_current(self) -&gt; float:\n        \"\"\"\n        Battery current in mA.\n\n        Returns:\n            float: Battery current in mA.\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; print(f\"Battery current: {actuator.battery_current} mA\")\n        \"\"\"\n        if self._data is not None:\n            return float(self._data[\"batt_curr\"])\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def output_torque(self) -&gt; float:\n        \"\"\"\n        Torque at the joint output in Nm. This is calculated using motor current, k_t, and the gear ratio.\n\n        Returns:\n            float: Output torque in Nm.\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; print(f\"Output torque: {actuator.output_torque} Nm\")\n        \"\"\"\n        return self.motor_torque * self.gear_ratio\n\n    @property\n    def case_temperature(self) -&gt; float:\n        \"\"\"\n        Case temperature in degrees celsius. This is read during actuator update.\n\n        Returns:\n            float: Case temperature in degrees celsius.\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; print(f\"Case temperature: {actuator.case_temperature} C\")\n        \"\"\"\n        if self._data is not None:\n            return float(self._data[\"temperature\"])\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def winding_temperature(self) -&gt; float:\n        \"\"\"\n        ESTIMATED temperature of the windings in celsius.\n        This is calculated based on the thermal model using motor current.\n\n        Returns:\n            float: Winding temperature in degrees celsius.\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; print(f\"Winding temperature: {actuator.winding_temperature} C\")\n        \"\"\"\n        if self._data is not None:\n            return float(self._thermal_model.winding_temperature)\n        else:\n            return 0.0\n\n    @property\n    def genvars(self) -&gt; np.ndarray:\n        \"\"\"Dephy's 'genvars' object.\"\"\"\n        if self._data is not None:\n            return np.array(\n                object=[\n                    self._data[\"genvar_0\"],\n                    self._data[\"genvar_1\"],\n                    self._data[\"genvar_2\"],\n                    self._data[\"genvar_3\"],\n                    self._data[\"genvar_4\"],\n                    self._data[\"genvar_5\"],\n                ]\n            )\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning zeros\"\n            )\n            return np.zeros(shape=6)\n\n    @property\n    def accelx(self) -&gt; float:\n        \"\"\"\n        Acceleration in x direction in m/s^2.\n        Measured using actpack's onboard IMU.\n\n        Returns:\n            float: Acceleration in x direction in m/s^2.\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; print(f\"Acceleration in x direction: {actuator.accelx} m/s^2\")\n        \"\"\"\n        if self._data is not None:\n            return float(self._data[\"accelx\"] * M_PER_SEC_SQUARED_ACCLSB)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def accely(self) -&gt; float:\n        \"\"\"\n        Acceleration in y direction in m/s^2.\n        Measured using actpack's onboard IMU.\n\n        Returns:\n            float: Acceleration in y direction in m/s^2.\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; print(f\"Acceleration in y direction: {actuator.accely} m/s^2\")\n        \"\"\"\n        if self._data is not None:\n            return float(self._data[\"accely\"] * M_PER_SEC_SQUARED_ACCLSB)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def accelz(self) -&gt; float:\n        \"\"\"\n        Acceleration in z direction in m/s^2.\n        Measured using actpack's onboard IMU.\n\n        Returns:\n            float: Acceleration in z direction in m/s^2.\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; print(f\"Acceleration in z direction: {actuator.accelz} m/s^2\")\n        \"\"\"\n        if self._data is not None:\n            return float(self._data[\"accelz\"] * M_PER_SEC_SQUARED_ACCLSB)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def gyrox(self) -&gt; float:\n        \"\"\"\n        Angular velocity in x direction in rad/s.\n        Measured using actpack's onboard IMU.\n\n        Returns:\n            float: Angular velocity in x direction in rad/s.\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; print(f\"Angular velocity in x direction: {actuator.gyrox} rad/s\")\n        \"\"\"\n        if self._data is not None:\n            return float(self._data[\"gyrox\"] * RAD_PER_SEC_GYROLSB)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def gyroy(self) -&gt; float:\n        \"\"\"\n        Angular velocity in y direction in rad/s.\n        Measured using actpack's onboard IMU.\n\n        Returns:\n            float: Angular velocity in y direction in rad/s.\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; print(f\"Angular velocity in y direction: {actuator.gyroy} rad/s\")\n        \"\"\"\n        if self._data is not None:\n            return float(self._data[\"gyroy\"] * RAD_PER_SEC_GYROLSB)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def gyroz(self) -&gt; float:\n        \"\"\"\n        Angular velocity in z direction in rad/s.\n        Measured using actpack's onboard IMU.\n\n        Returns:\n            float: Angular velocity in z direction in rad/s.\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; print(f\"Angular velocity in z direction: {actuator.gyroz} rad/s\")\n        \"\"\"\n        if self._data is not None:\n            return float(self._data[\"gyroz\"] * RAD_PER_SEC_GYROLSB)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def thermal_scaling_factor(self) -&gt; float:\n        \"\"\"\n        Scale factor to use in torque control, in [0,1].\n        If you scale the torque command by this factor, the motor temperature will never\n        exceed max allowable temperature. For a proof, see paper referenced in thermal model.\n\n        Returns:\n            float: Thermal scaling factor.\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; print(f\"Thermal scaling factor: {actuator.thermal_scaling_factor}\")\n            &gt;&gt;&gt; actuator.update()\n            &gt;&gt;&gt; # This will update the thermal model and return the new scaling factor.\n            &gt;&gt;&gt; print(f\"Thermal scaling factor: {actuator.thermal_scaling_factor}\")\n        \"\"\"\n        return self._thermal_scale\n</code></pre>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.MOTOR_CONSTANTS","title":"<code>MOTOR_CONSTANTS</code>  <code>property</code> <code>writable</code>","text":"<p>Get the motor constants configuration. Redefines the property from the ABC so we can set a setter.</p> <p>Returns:</p> Name Type Description <code>MOTOR_CONSTANTS</code> <code>MOTOR_CONSTANTS</code> <p>The motor constants.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; constants = actuator.MOTOR_CONSTANTS\n&gt;&gt;&gt; constants.MAX_CASE_TEMPERATURE\n80.0\n</code></pre>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.accelx","title":"<code>accelx</code>  <code>property</code>","text":"<p>Acceleration in x direction in m/s^2. Measured using actpack's onboard IMU.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Acceleration in x direction in m/s^2.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; print(f\"Acceleration in x direction: {actuator.accelx} m/s^2\")\n</code></pre>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.accely","title":"<code>accely</code>  <code>property</code>","text":"<p>Acceleration in y direction in m/s^2. Measured using actpack's onboard IMU.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Acceleration in y direction in m/s^2.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; print(f\"Acceleration in y direction: {actuator.accely} m/s^2\")\n</code></pre>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.accelz","title":"<code>accelz</code>  <code>property</code>","text":"<p>Acceleration in z direction in m/s^2. Measured using actpack's onboard IMU.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Acceleration in z direction in m/s^2.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; print(f\"Acceleration in z direction: {actuator.accelz} m/s^2\")\n</code></pre>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.battery_current","title":"<code>battery_current</code>  <code>property</code>","text":"<p>Battery current in mA.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Battery current in mA.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; print(f\"Battery current: {actuator.battery_current} mA\")\n</code></pre>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.battery_voltage","title":"<code>battery_voltage</code>  <code>property</code>","text":"<p>Battery voltage in mV.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Battery voltage in mV.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; print(f\"Battery voltage: {actuator.battery_voltage} mV\")\n</code></pre>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.case_temperature","title":"<code>case_temperature</code>  <code>property</code>","text":"<p>Case temperature in degrees celsius. This is read during actuator update.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Case temperature in degrees celsius.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; print(f\"Case temperature: {actuator.case_temperature} C\")\n</code></pre>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.genvars","title":"<code>genvars</code>  <code>property</code>","text":"<p>Dephy's 'genvars' object.</p>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.gyrox","title":"<code>gyrox</code>  <code>property</code>","text":"<p>Angular velocity in x direction in rad/s. Measured using actpack's onboard IMU.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Angular velocity in x direction in rad/s.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; print(f\"Angular velocity in x direction: {actuator.gyrox} rad/s\")\n</code></pre>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.gyroy","title":"<code>gyroy</code>  <code>property</code>","text":"<p>Angular velocity in y direction in rad/s. Measured using actpack's onboard IMU.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Angular velocity in y direction in rad/s.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; print(f\"Angular velocity in y direction: {actuator.gyroy} rad/s\")\n</code></pre>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.gyroz","title":"<code>gyroz</code>  <code>property</code>","text":"<p>Angular velocity in z direction in rad/s. Measured using actpack's onboard IMU.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Angular velocity in z direction in rad/s.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; print(f\"Angular velocity in z direction: {actuator.gyroz} rad/s\")\n</code></pre>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.motor_acceleration","title":"<code>motor_acceleration</code>  <code>property</code>","text":"<p>Motor acceleration in rad/s^2.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Motor acceleration in rad/s^2.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; print(f\"Motor acceleration: {actuator.motor_acceleration} rad/s^2\")\n</code></pre>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.motor_current","title":"<code>motor_current</code>  <code>property</code>","text":"<p>Motor current in mA.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Motor current in mA.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; print(f\"Motor current: {actuator.motor_current} mA\")\n</code></pre>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.motor_encoder_counts","title":"<code>motor_encoder_counts</code>  <code>property</code>","text":"<p>Raw reading from motor encoder in counts.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Motor encoder counts.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; print(f\"Motor encoder counts: {actuator.motor_encoder_counts}\")\n</code></pre>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.motor_position","title":"<code>motor_position</code>  <code>property</code>","text":"<p>Motor position in radians.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Motor position in radians.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; print(f\"Motor position: {actuator.motor_position} rad\")\n</code></pre>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.motor_torque","title":"<code>motor_torque</code>  <code>property</code>","text":"<p>Torque at the motor output in Nm.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Motor torque in Nm.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; print(f\"Motor torque: {actuator.motor_torque} Nm\")\n</code></pre>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.motor_velocity","title":"<code>motor_velocity</code>  <code>property</code>","text":"<p>Motor velocity in rad/s.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Motor velocity in rad/s.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; print(f\"Motor velocity: {actuator.motor_velocity} rad/s\")\n</code></pre>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.motor_voltage","title":"<code>motor_voltage</code>  <code>property</code>","text":"<p>Q-axis motor voltage in mV.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Motor voltage in mV.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; print(f\"Motor voltage: {actuator.motor_voltage} mV\")\n</code></pre>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.output_torque","title":"<code>output_torque</code>  <code>property</code>","text":"<p>Torque at the joint output in Nm. This is calculated using motor current, k_t, and the gear ratio.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Output torque in Nm.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; print(f\"Output torque: {actuator.output_torque} Nm\")\n</code></pre>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.thermal_scaling_factor","title":"<code>thermal_scaling_factor</code>  <code>property</code>","text":"<p>Scale factor to use in torque control, in [0,1]. If you scale the torque command by this factor, the motor temperature will never exceed max allowable temperature. For a proof, see paper referenced in thermal model.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Thermal scaling factor.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; print(f\"Thermal scaling factor: {actuator.thermal_scaling_factor}\")\n&gt;&gt;&gt; actuator.update()\n&gt;&gt;&gt; # This will update the thermal model and return the new scaling factor.\n&gt;&gt;&gt; print(f\"Thermal scaling factor: {actuator.thermal_scaling_factor}\")\n</code></pre>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.winding_temperature","title":"<code>winding_temperature</code>  <code>property</code>","text":"<p>ESTIMATED temperature of the windings in celsius. This is calculated based on the thermal model using motor current.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Winding temperature in degrees celsius.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; print(f\"Winding temperature: {actuator.winding_temperature} C\")\n</code></pre>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.home","title":"<code>home(homing_voltage=2000, homing_frequency=None, homing_direction=-1, output_position_offset=0.0, current_threshold=5000, velocity_threshold=0.001, callback=None)</code>","text":"<p>This method homes the actuator and the corresponding joint by moving it to the zero position. The zero position is defined as the position where the joint is fully extended. This method will also load the encoder map if it exists. The encoder map is a polynomial that maps the encoder counts to joint position in radians. This is useful for more accurate joint position estimation.</p> <p>Parameters:</p> Name Type Description Default <code>homing_voltage</code> <code>int</code> <p>Voltage in mV to use for homing. Default is 2000 mV.</p> <code>2000</code> <code>homing_frequency</code> <code>int</code> <p>Frequency in Hz to use for homing. Default is the actuator's frequency.</p> <code>None</code> <code>homing_direction</code> <code>int</code> <p>Direction to move the actuator during homing. Default is -1.</p> <code>-1</code> <code>output_position_offset</code> <code>float</code> <p>Offset in radians to add to the output position. Default is 0.0.</p> <code>0.0</code> <code>current_threshold</code> <code>int</code> <p>Current threshold in mA to stop homing the joint or actuator. This is used to detect if the actuator or joint has hit a hard stop. Default is 5000 mA.</p> <code>5000</code> <code>velocity_threshold</code> <code>float</code> <p>Velocity threshold in rad/s to stop homing the joint or actuator. This is also used to detect if the actuator or joint has hit a hard stop. Default is 0.001 rad/s.</p> <code>0.001</code> <code>callback</code> <code>Optional[Callable[[], None]]</code> <p>Optional callback function to be called when homing completes.                                         The function should take no arguments and return None.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; actuator.home(homing_voltage=2000, homing_direction=-1)\n</code></pre> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def home(\n    self,\n    homing_voltage: int = 2000,\n    homing_frequency: Optional[int] = None,\n    homing_direction: int = -1,\n    output_position_offset: float = 0.0,\n    current_threshold: int = 5000,\n    velocity_threshold: float = 0.001,\n    callback: Optional[Callable[[], None]] = None,\n) -&gt; None:\n    \"\"\"\n\n    This method homes the actuator and the corresponding joint by moving it to the zero position.\n    The zero position is defined as the position where the joint is fully extended. This method will\n    also load the encoder map if it exists. The encoder map is a polynomial that maps the encoder counts\n    to joint position in radians. This is useful for more accurate joint position estimation.\n\n    Args:\n        homing_voltage (int): Voltage in mV to use for homing.\n            Default is 2000 mV.\n        homing_frequency (int): Frequency in Hz to use for homing.\n            Default is the actuator's frequency.\n        homing_direction (int): Direction to move the actuator during homing.\n            Default is -1.\n        output_position_offset (float): Offset in radians to add to the output position.\n            Default is 0.0.\n        current_threshold (int): Current threshold in mA to stop homing the joint or actuator.\n            This is used to detect if the actuator or joint has hit a hard stop.\n            Default is 5000 mA.\n        velocity_threshold (float): Velocity threshold in rad/s to stop homing the joint or actuator.\n            This is also used to detect if the actuator or joint has hit a hard stop.\n            Default is 0.001 rad/s.\n        callback (Optional[Callable[[], None]]): Optional callback function to be called when homing completes.\n                                                    The function should take no arguments and return None.\n\n    Examples:\n        &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n        &gt;&gt;&gt; actuator.start()\n        &gt;&gt;&gt; actuator.home(homing_voltage=2000, homing_direction=-1)\n\n    \"\"\"\n    is_homing = True\n    homing_frequency = homing_frequency if homing_frequency is not None else self.frequency\n\n    LOGGER.info(\n        f\"[{str.upper(self.tag)}] Homing {self.tag} joint. \"\n        \"Please make sure the joint is free to move and press Enter to continue.\"\n    )\n    input()\n\n    self.set_control_mode(mode=CONTROL_MODES.VOLTAGE)\n\n    self.set_motor_voltage(value=homing_direction * homing_voltage)  # mV, negative for counterclockwise\n\n    time.sleep(0.1)\n\n    try:\n        while is_homing:\n            self.update()\n            time.sleep(1 / homing_frequency)\n\n            if abs(self.output_velocity) &lt;= velocity_threshold or abs(self.motor_current) &gt;= current_threshold:\n                self.set_motor_voltage(value=0)\n                if callback is not None:\n                    callback()\n                is_homing = False\n\n    except KeyboardInterrupt:\n        self.set_motor_voltage(value=0)\n        LOGGER.info(msg=f\"[{str.upper(self.tag)}] Homing interrupted.\")\n        return\n    except Exception as e:\n        self.set_motor_voltage(value=0)\n        LOGGER.error(msg=f\"[{str.upper(self.tag)}] Homing failed: {e}\")\n        return\n\n    self.set_motor_zero_position(value=self.motor_position + output_position_offset * self.gear_ratio)\n\n    time.sleep(0.1)\n\n    self._is_homed = True\n    LOGGER.info(f\"[{str.upper(self.tag)}] Homing complete.\")\n</code></pre>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.set_current_gains","title":"<code>set_current_gains(kp=DEFAULT_CURRENT_GAINS.kp, ki=DEFAULT_CURRENT_GAINS.ki, kd=DEFAULT_CURRENT_GAINS.kd, ff=DEFAULT_CURRENT_GAINS.ff)</code>","text":"<p>Sets the current gains in arbitrary Dephy units.</p> <p>Parameters:</p> Name Type Description Default <code>kp</code> <code>float</code> <p>The proportional gain</p> <code>kp</code> <code>ki</code> <code>float</code> <p>The integral gain</p> <code>ki</code> <code>kd</code> <code>float</code> <p>The derivative gain</p> <code>kd</code> <code>ff</code> <code>float</code> <p>The feedforward gain</p> <code>ff</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; actuator.set_current_gains(kp=40, ki=400, kd=0, ff=128)\n</code></pre> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def set_current_gains(\n    self,\n    kp: float = DEFAULT_CURRENT_GAINS.kp,\n    ki: float = DEFAULT_CURRENT_GAINS.ki,\n    kd: float = DEFAULT_CURRENT_GAINS.kd,\n    ff: float = DEFAULT_CURRENT_GAINS.ff,\n) -&gt; None:\n    \"\"\"\n    Sets the current gains in arbitrary Dephy units.\n\n    Args:\n        kp (float): The proportional gain\n        ki (float): The integral gain\n        kd (float): The derivative gain\n        ff (float): The feedforward gain\n\n    Returns:\n        None\n\n    Examples:\n        &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n        &gt;&gt;&gt; actuator.start()\n        &gt;&gt;&gt; actuator.set_current_gains(kp=40, ki=400, kd=0, ff=128)\n    \"\"\"\n    self.set_gains(\n        kp=int(kp),\n        ki=int(ki),\n        kd=int(kd),\n        k=0,\n        b=0,\n        ff=int(ff),\n    )\n</code></pre>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.set_i2t_fault_threshold","title":"<code>set_i2t_fault_threshold(threshold)</code>","text":"<p>Sets the threshold for consecutive I2t faults before raising an exception.</p> <p>This helps filter out spurious one-off bit flips in the status_ex register by requiring multiple consecutive fault detections before triggering the exception.</p> <p>Parameters:</p> Name Type Description Default <code>threshold</code> <code>int</code> <p>Number of consecutive faults required to trigger exception.            Default is 2. Must be &gt;= 1.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.set_i2t_fault_threshold(5)  # Require 5 consecutive faults\n</code></pre> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def set_i2t_fault_threshold(self, threshold: int) -&gt; None:\n    \"\"\"\n    Sets the threshold for consecutive I2t faults before raising an exception.\n\n    This helps filter out spurious one-off bit flips in the status_ex register\n    by requiring multiple consecutive fault detections before triggering the exception.\n\n    Args:\n        threshold: Number of consecutive faults required to trigger exception.\n                       Default is 2. Must be &gt;= 1.\n\n    Examples:\n        &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n        &gt;&gt;&gt; actuator.set_i2t_fault_threshold(5)  # Require 5 consecutive faults\n    \"\"\"\n    if threshold &lt; 1:\n        raise ValueError(\"I2t fault threshold must be &gt;= 1\")\n\n    self._i2t_fault_threshold = threshold\n    LOGGER.info(f\"[{self.tag}] I2t fault threshold set to {threshold} consecutive faults\")\n</code></pre>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.set_impedance_cc_pidf_gains","title":"<code>set_impedance_cc_pidf_gains(kp=DEFAULT_IMPEDANCE_GAINS.kp, ki=DEFAULT_IMPEDANCE_GAINS.ki, kd=DEFAULT_IMPEDANCE_GAINS.kd, ff=DEFAULT_IMPEDANCE_GAINS.ff)</code>","text":"<p>Caches the PID &amp; feedforward gains used in the current controller within the impedance control mode.</p> <p>This does not configure the physical parameters (<code>k</code> and <code>b</code>) which are set via <code>set_output_impedance</code> or <code>set_motor_impedance</code>.</p> <p>Calling this method is optional - if not called before using the impedance setters, a set of default gains will automatically be used.</p> <p>Parameters:</p> Name Type Description Default <code>kp</code> <code>float</code> <p>Proportional gain. Defaults to 40.</p> <code>kp</code> <code>ki</code> <code>float</code> <p>Integral gain. Defaults to 400.</p> <code>ki</code> <code>kd</code> <code>float</code> <p>Derivative gain. Defaults to 0.</p> <code>kd</code> <code>ff</code> <code>float</code> <p>Feedforward gain. Defaults to 128.</p> <code>ff</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def set_impedance_cc_pidf_gains(\n    self,\n    kp: float = DEFAULT_IMPEDANCE_GAINS.kp,\n    ki: float = DEFAULT_IMPEDANCE_GAINS.ki,\n    kd: float = DEFAULT_IMPEDANCE_GAINS.kd,\n    ff: float = DEFAULT_IMPEDANCE_GAINS.ff,\n) -&gt; None:\n    \"\"\"\n    Caches the PID &amp; feedforward gains used in the current controller within the impedance control mode.\n\n    This does not configure the physical parameters (`k` and `b`)\n    which are set via `set_output_impedance` or `set_motor_impedance`.\n\n    Calling this method is optional - if not called before using the\n    impedance setters, a set of default gains will automatically be used.\n\n    Args:\n        kp (float): Proportional gain. Defaults to 40.\n        ki (float): Integral gain. Defaults to 400.\n        kd (float): Derivative gain. Defaults to 0.\n        ff (float): Feedforward gain. Defaults to 128.\n\n    Returns:\n        None\n    \"\"\"\n    self._impedance_gains = ControlGains(kp, ki, kd, 0, 0, ff)\n</code></pre>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.set_motor_current","title":"<code>set_motor_current(value)</code>","text":"<p>Sets the motor current in mA.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The current to set in mA.</p> required <p>Returns:     None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; actuator.set_motor_current(1000)\n</code></pre> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def set_motor_current(\n    self,\n    value: float,\n) -&gt; None:\n    \"\"\"\n    Sets the motor current in mA.\n\n    Args:\n        value (float): The current to set in mA.\n    Returns:\n        None\n\n    Examples:\n        &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n        &gt;&gt;&gt; actuator.start()\n        &gt;&gt;&gt; actuator.set_motor_current(1000)\n    \"\"\"\n    self.command_motor_current(value=int(value))\n</code></pre>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.set_motor_impedance","title":"<code>set_motor_impedance(k=0.08922, b=0.003807)</code>","text":"<p>Set the impedance gains of the motor in real units: Nm/rad and Nm/rad/s.</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>float</code> <p>Spring constant. Defaults to 0.08922 Nm/rad.</p> <code>0.08922</code> <code>b</code> <code>float</code> <p>Damping constant. Defaults to 0.0038070 Nm/rad/s.</p> <code>0.003807</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; actuator.set_motor_impedance(k=0.08922, b=0.0038070)\n</code></pre> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def set_motor_impedance(\n    self,\n    k: float = 0.08922,\n    b: float = 0.0038070,\n) -&gt; None:\n    \"\"\"\n    Set the impedance gains of the motor in real units: Nm/rad and Nm/rad/s.\n\n    Args:\n        k (float): Spring constant. Defaults to 0.08922 Nm/rad.\n        b (float): Damping constant. Defaults to 0.0038070 Nm/rad/s.\n\n    Returns:\n        None\n\n    Examples:\n        &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n        &gt;&gt;&gt; actuator.start()\n        &gt;&gt;&gt; actuator.set_motor_impedance(k=0.08922, b=0.0038070)\n    \"\"\"\n    if k &lt; 0:\n        raise ValueError(f\"Stiffness k={k} cannot be negative\")\n    if b &lt; 0:\n        raise ValueError(f\"Damping b={b} cannot be negative\")\n\n    self._set_impedance_gains(\n        k=int(k * self.NM_PER_RAD_TO_MOTOR_UNITS),\n        b=int(b * self.NM_S_PER_RAD_TO_MOTOR_UNITS),\n    )\n</code></pre>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.set_motor_position","title":"<code>set_motor_position(value)</code>","text":"<p>Sets the motor position in radians. If in impedance mode, this sets the equilibrium angle in radians.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The position to set</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; actuator.set_motor_position(0.1)\n</code></pre> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def set_motor_position(self, value: float) -&gt; None:\n    \"\"\"\n    Sets the motor position in radians.\n    If in impedance mode, this sets the equilibrium angle in radians.\n\n    Args:\n        value (float): The position to set\n\n    Returns:\n        None\n\n    Examples:\n        &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n        &gt;&gt;&gt; actuator.start()\n        &gt;&gt;&gt; actuator.set_motor_position(0.1)\n    \"\"\"\n    # TODO: New Dephy API splits impedance equilibrium position and position control into separate methods\n    if self.mode == CONTROL_MODES.POSITION:\n        self.command_motor_position(\n            value=int((value + self.motor_zero_position) / self.MOTOR_CONSTANTS.RAD_PER_COUNT),\n        )\n    elif self.mode == CONTROL_MODES.IMPEDANCE:\n        self.command_motor_impedance(\n            value=int((value + self.motor_zero_position) / self.MOTOR_CONSTANTS.RAD_PER_COUNT),\n        )\n    else:\n        raise ControlModeException(tag=self._tag, attribute=\"set_motor_position\", mode=self._mode.name)\n</code></pre>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.set_motor_torque","title":"<code>set_motor_torque(value)</code>","text":"<p>Sets the motor torque in Nm. This is the torque that is applied to the motor rotor, not the joint or output. Args:     value (float): The torque to set in Nm. Returns:     None Examples:     &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')     &gt;&gt;&gt; actuator.start()     &gt;&gt;&gt; actuator.set_motor_torque(0.1)</p> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def set_motor_torque(self, value: float) -&gt; None:\n    \"\"\"\n    Sets the motor torque in Nm. This is the torque that is applied to the motor rotor, not the joint or output.\n    Args:\n        value (float): The torque to set in Nm.\n    Returns:\n        None\n    Examples:\n        &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n        &gt;&gt;&gt; actuator.start()\n        &gt;&gt;&gt; actuator.set_motor_torque(0.1)\n    \"\"\"\n    self.set_motor_current(\n        value / self.MOTOR_CONSTANTS.NM_PER_MILLIAMP,\n    )\n</code></pre>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.set_motor_voltage","title":"<code>set_motor_voltage(value)</code>","text":"<p>Sets the motor voltage in mV.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The voltage to set in mV.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; actuator.set_motor_voltage(100) TODO: Validate number\n</code></pre> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def set_motor_voltage(self, value: float) -&gt; None:\n    \"\"\"\n    Sets the motor voltage in mV.\n\n    Args:\n        value (float): The voltage to set in mV.\n\n    Returns:\n        None\n\n    Examples:\n        &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n        &gt;&gt;&gt; actuator.start()\n        &gt;&gt;&gt; actuator.set_motor_voltage(100) TODO: Validate number\n    \"\"\"\n    self.command_motor_voltage(value=int(value))\n</code></pre>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.set_output_impedance","title":"<code>set_output_impedance(k=153.66, b=6.56)</code>","text":"<p>Set the impedance gains of the joint in real units: Nm/rad and Nm/rad/s. This sets the impedance at the output and automatically scales based on gear ratios. Note: Default k and b calculated from the default motor impedance k, b for gear ratio 41.5 Conversion:     K_motor = K_joint / (gear_ratio ** 2)     B_motor = B_joint / (gear_ratio ** 2)</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>float</code> <p>Spring constant. Defaults to 100 Nm/rad.</p> <code>153.66</code> <code>b</code> <code>float</code> <p>Damping constant. Defaults to 3.0 Nm/rad/s.</p> <code>6.56</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; actuator.set_output_impedance(k=100, b=3)\n</code></pre> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def set_output_impedance(\n    self,\n    k: float = 153.66,\n    b: float = 6.56,\n) -&gt; None:\n    \"\"\"\n    Set the impedance gains of the joint in real units: Nm/rad and Nm/rad/s.\n    This sets the impedance at the output and automatically scales based on gear ratios.\n    Note: Default k and b calculated from the default motor impedance k, b for gear ratio 41.5\n    Conversion:\n        K_motor = K_joint / (gear_ratio ** 2)\n        B_motor = B_joint / (gear_ratio ** 2)\n\n    Args:\n        k (float): Spring constant. Defaults to 100 Nm/rad.\n        b (float): Damping constant. Defaults to 3.0 Nm/rad/s.\n\n    Returns:\n        None\n\n    Examples:\n        &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n        &gt;&gt;&gt; actuator.start()\n        &gt;&gt;&gt; actuator.set_output_impedance(k=100, b=3)\n    \"\"\"\n\n    self.set_motor_impedance(\n        k=k / (self.gear_ratio**2),\n        b=b / (self.gear_ratio**2),\n    )\n</code></pre>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.set_output_torque","title":"<code>set_output_torque(value)</code>","text":"<p>Set the output torque of the joint. This is the torque that is applied to the joint, not the motor.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>torque in N_m</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; actuator.set_output_torque(0.1)\n</code></pre> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def set_output_torque(self, value: float) -&gt; None:\n    \"\"\"\n    Set the output torque of the joint.\n    This is the torque that is applied to the joint, not the motor.\n\n    Args:\n        value (float): torque in N_m\n\n    Returns:\n        None\n\n    Examples:\n        &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n        &gt;&gt;&gt; actuator.start()\n        &gt;&gt;&gt; actuator.set_output_torque(0.1)\n    \"\"\"\n    self.set_motor_torque(value=value / self.gear_ratio)\n</code></pre>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.set_position_gains","title":"<code>set_position_gains(kp=DEFAULT_POSITION_GAINS.kp, ki=DEFAULT_POSITION_GAINS.ki, kd=DEFAULT_POSITION_GAINS.kd, ff=DEFAULT_POSITION_GAINS.ff)</code>","text":"<p>Sets the position gains in arbitrary Dephy units.</p> <p>Parameters:</p> Name Type Description Default <code>kp</code> <code>float</code> <p>The proportional gain</p> <code>kp</code> <code>ki</code> <code>float</code> <p>The integral gain</p> <code>ki</code> <code>kd</code> <code>float</code> <p>The derivative gain</p> <code>kd</code> <code>ff</code> <code>float</code> <p>The feedforward gain</p> <code>ff</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; actuator.set_position_gains(kp=30, ki=0, kd=0, ff=0)\n</code></pre> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def set_position_gains(\n    self,\n    kp: float = DEFAULT_POSITION_GAINS.kp,\n    ki: float = DEFAULT_POSITION_GAINS.ki,\n    kd: float = DEFAULT_POSITION_GAINS.kd,\n    ff: float = DEFAULT_POSITION_GAINS.ff,\n) -&gt; None:\n    \"\"\"\n    Sets the position gains in arbitrary Dephy units.\n\n    Args:\n        kp (float): The proportional gain\n        ki (float): The integral gain\n        kd (float): The derivative gain\n        ff (float): The feedforward gain\n\n    Returns:\n        None\n\n    Examples:\n        &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n        &gt;&gt;&gt; actuator.start()\n        &gt;&gt;&gt; actuator.set_position_gains(kp=30, ki=0, kd=0, ff=0)\n    \"\"\"\n    self.set_gains(\n        kp=int(kp),\n        ki=int(ki),\n        kd=int(kd),\n        k=0,\n        b=0,\n        ff=int(ff),\n    )\n</code></pre>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.start","title":"<code>start()</code>","text":"<p>Starts the actuator by opening the port, starting data streaming, reading initial data, and setting the control mode to VOLTAGE.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n</code></pre> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>@check_actuator_connection\ndef start(self) -&gt; None:\n    \"\"\"\n    Starts the actuator by opening the port, starting data streaming,\n    reading initial data, and setting the control mode to VOLTAGE.\n\n    Returns:\n        None\n\n    Examples:\n        &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n        &gt;&gt;&gt; actuator.start()\n    \"\"\"\n    try:\n        self.open()\n        self._is_open = True\n    except OSError:\n        print(\"\\n\")\n        LOGGER.error(\n            msg=f\"[{self.__repr__()}] Need admin previleges to open the port '{self.port}'. \\n\\n \\\n                Please run the script with 'sudo' command or add the user to the dialout group.\\n\"\n        )\n        os._exit(status=1)\n\n    self.start_streaming(self._frequency)\n    time.sleep(0.2)\n    self._is_streaming = True\n\n    self._data = self.read()\n    self.set_control_mode(CONTROL_MODES.VOLTAGE)\n</code></pre>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.stop","title":"<code>stop()</code>","text":"<p>Stops the actuator by stopping the motor, switching to IDLE mode, stopping data streaming, and closing the connection.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; # ... perform control tasks ...\n&gt;&gt;&gt; actuator.stop()\n</code></pre> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>@check_actuator_stream\n@check_actuator_open\ndef stop(self) -&gt; None:\n    \"\"\"\n    Stops the actuator by stopping the motor, switching to IDLE mode,\n    stopping data streaming, and closing the connection.\n\n    Returns:\n        None\n\n    Examples:\n        &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n        &gt;&gt;&gt; actuator.start()\n        &gt;&gt;&gt; # ... perform control tasks ...\n        &gt;&gt;&gt; actuator.stop()\n    \"\"\"\n    self.stop_motor()\n    self.set_control_mode(mode=CONTROL_MODES.IDLE)\n    self._is_streaming = False\n    self._is_open = False\n    self.stop_streaming()\n    self.close()\n</code></pre>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyActuator.update","title":"<code>update()</code>","text":"<p>Updates the actuator's data by reading new values and updating the thermal model. It raises exceptions if thermal limits are exceeded.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator()\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; actuator.update()\n&gt;&gt;&gt; print(f\"Motor current: {actuator.motor_current} mA\")\n</code></pre> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def update(self) -&gt; None:\n    \"\"\"\n    Updates the actuator's data by reading new values and updating the thermal model.\n    It raises exceptions if thermal limits are exceeded.\n\n    Returns:\n        None\n\n    Examples:\n        &gt;&gt;&gt; actuator = DephyActuator()\n        &gt;&gt;&gt; actuator.start()\n        &gt;&gt;&gt; actuator.update()\n        &gt;&gt;&gt; print(f\"Motor current: {actuator.motor_current} mA\")\n    \"\"\"\n    self._data = self.read()\n\n    self._thermal_scale = self._thermal_model.update(\n        dt=1 / self.frequency,\n        motor_current=self.motor_current,\n        case_temperature=self.case_temperature,\n    )\n\n    self._check_i2t_fault()\n</code></pre>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyLegacyActuator","title":"<code>DephyLegacyActuator</code>","text":"<p>               Bases: <code>DephyActuator</code></p> Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>class DephyLegacyActuator(DephyActuator):\n    def __init__(\n        self,\n        tag: str = \"DephyActuator\",\n        port: str = \"/dev/ttyACM0\",\n        gear_ratio: float = 1.0,\n        baud_rate: int = 230400,\n        frequency: int = 500,\n        debug_level: int = 4,\n        dephy_log: bool = False,\n        offline: bool = False,\n    ) -&gt; None:\n        ActuatorBase.__init__(\n            self,\n            tag=tag,\n            gear_ratio=gear_ratio,\n            motor_constants=DEPHY_ACTUATOR_CONSTANTS,\n            frequency=frequency,\n            offline=offline,\n        )\n\n        self._debug_level: int = debug_level if dephy_log else 6\n        self._dephy_log: bool = dephy_log\n\n        if self.is_offline:\n            self.port = port\n            self._is_streaming: bool = False\n            self._is_open: bool = False\n        else:\n            # def set_is_streaming(self, value):\n            #     self._is_streaming = value\n\n            # def set_is_open(self, value):\n            #     self._is_open = value\n\n            # type(self).is_streaming = property(fset=set_is_streaming)\n            # type(self).is_open = property(fset=set_is_open)\n\n            Device.__init__(self, port=port, baud_rate=baud_rate)\n\n        self._thermal_model: ThermalModel = ThermalModel(\n            motor_constants=self.MOTOR_CONSTANTS,\n            actuator_tag=self.tag,\n        )\n        self._thermal_scale: float = 1.0\n\n        self._mode = CONTROL_MODES.IDLE\n\n    def __repr__(self) -&gt; str:\n        return f\"{self.tag}[DephyLegacyActuator]\"\n\n    @property\n    def _CONTROL_MODE_CONFIGS(self) -&gt; CONTROL_MODE_CONFIGS:\n        return DEPHY_LEGACY_CONTROL_MODE_CONFIGS\n\n    @check_actuator_connection\n    def start(self) -&gt; None:\n        try:\n            self.open(\n                freq=self._frequency,\n                log_level=self._debug_level,\n                log_enabled=self._dephy_log,\n            )\n        except OSError:\n            print(\"\\n\")\n            LOGGER.error(\n                msg=f\"[{self.__repr__()}] Need admin previleges to open the port '{self.port}'. \\n\\n \\\n                    Please run the script with 'sudo' command or add the user to the dialout group.\\n\"\n            )\n            os._exit(status=1)\n\n        self._data = self.read()\n\n        # TODO: Verify if we need this sleep here\n        time.sleep(0.1)\n        self.set_control_mode(CONTROL_MODES.VOLTAGE)\n\n    @check_actuator_stream\n    @check_actuator_open\n    def stop(self) -&gt; None:\n        self.set_control_mode(mode=CONTROL_MODES.VOLTAGE)\n        self.set_motor_voltage(value=0)\n\n        self.set_control_mode(mode=CONTROL_MODES.IDLE)\n        time.sleep(0.1)\n        self._is_streaming = False\n        self._is_open = False\n        self.stop_streaming()\n        self.close()\n\n    def update(self) -&gt; None:\n        self._data = self.read()\n        self._thermal_scale = self._thermal_model.update(\n            dt=1 / self.frequency,\n            motor_current=self.motor_current,\n            case_temperature=self.case_temperature,\n        )\n\n        # Check for thermal fault, bit 2 of the execute status byte\n        if self._data.status_ex &amp; 0b00000010 == 0b00000010:\n            LOGGER.error(\n                f\"[{str.upper(self.tag)}] Thermal Fault: Winding temperature: {self.winding_temperature}; \"\n                f\"Case temperature: {self.case_temperature}.\"\n            )\n            raise ThermalLimitException(\"Internal thermal limit tripped.\")\n\n    def set_motor_current(\n        self,\n        value: float,\n    ) -&gt; None:\n        \"\"\"\n        Sets the motor current in mA.\n\n        Args:\n            value (float): The current to set in mA.\n        \"\"\"\n        self.send_motor_command(ctrl_mode=c_int(self.mode.value), value=int(value))\n\n    @deprecated_with_routing(alternative_func=set_motor_current)\n    def set_current(self, value: float) -&gt; None:\n        self.send_motor_command(ctrl_mode=c_int(self.mode.value), value=int(value))\n\n    def set_motor_voltage(self, value: float) -&gt; None:\n        \"\"\"\n        Sets the motor voltage in mV.\n\n        Args:\n            value (float): The voltage to set in mV.\n        \"\"\"\n        self.send_motor_command(ctrl_mode=c_int(self.mode.value), value=int(value))\n\n    @deprecated_with_routing(alternative_func=set_motor_voltage)\n    def set_voltage(self, value: float) -&gt; None:\n        self.send_motor_command(ctrl_mode=c_int(self.mode.value), value=int(value))\n\n    def set_motor_position(self, value: float) -&gt; None:\n        \"\"\"\n        Sets the motor position in radians.\n        If in impedance mode, this sets the equilibrium angle in radians.\n\n        Args:\n            value (float): The position to set\n        \"\"\"\n        self.send_motor_command(\n            ctrl_mode=c_int(self.mode.value),\n            value=int((value + self.motor_zero_position) / self.MOTOR_CONSTANTS.RAD_PER_COUNT),\n        )\n\n    @property\n    def motor_voltage(self) -&gt; float:\n        \"\"\"Q-axis motor voltage in mV.\"\"\"\n        if self._data is not None:\n            return float(self._data.mot_volt)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def motor_current(self) -&gt; float:\n        if self._data is not None:\n            return float(self._data.mot_cur)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def motor_torque(self) -&gt; float:\n        \"\"\"\n        Torque at the motor output in Nm.\n        \"\"\"\n        if self._data is not None:\n            return float(self._data.mot_cur * self.MOTOR_CONSTANTS.NM_PER_MILLIAMP)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def motor_position(self) -&gt; float:\n        \"\"\"\n        Motor position in radians.\n        \"\"\"\n        if self._data is not None:\n            return float(self._data.mot_ang * self.MOTOR_CONSTANTS.RAD_PER_COUNT) - self.motor_zero_position\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def motor_encoder_counts(self) -&gt; int:\n        \"\"\"Raw reading from motor encoder in counts.\"\"\"\n        if self._data is not None:\n            return int(self._data.mot_ang)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.\"\n            )\n            return 0\n\n    @property\n    def motor_velocity(self) -&gt; float:\n        \"\"\"\n        Motor velocity in rad/s.\n        \"\"\"\n        if self._data is not None:\n            return int(self._data.mot_vel) * RAD_PER_DEG\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def motor_acceleration(self) -&gt; float:\n        \"\"\"\n        Motor acceleration in rad/s^2.\n        \"\"\"\n        if self._data is not None:\n            return float(self._data.mot_acc)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def battery_voltage(self) -&gt; float:\n        \"\"\"Battery voltage in mV.\"\"\"\n        if self._data is not None:\n            return float(self._data.batt_volt)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def battery_current(self) -&gt; float:\n        \"\"\"Battery current in mA.\"\"\"\n        if self._data is not None:\n            return float(self._data.batt_curr)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def output_torque(self) -&gt; float:\n        \"\"\"\n        Torque at the joint output in Nm.\n        This is calculated using motor current, k_t, and the gear ratio.\n        \"\"\"\n        return self.motor_torque * self.gear_ratio\n\n    @property\n    def case_temperature(self) -&gt; float:\n        \"\"\"\n        Case temperature of the actuator in celsius.\n        \"\"\"\n        if self._data is not None:\n            return float(self._data.temperature)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def winding_temperature(self) -&gt; float:\n        \"\"\"\n        ESTIMATED temperature of the windings in celsius.\n        This is calculated based on the thermal model using motor current.\n        \"\"\"\n        if self._data is not None:\n            return float(self._thermal_model.winding_temperature)\n        else:\n            return 0.0\n\n    @property\n    def genvars(self) -&gt; np.ndarray:\n        \"\"\"Dephy's 'genvars' object.\"\"\"\n        if self._data is not None:\n            return np.array(\n                object=[\n                    self._data.genvar_0,\n                    self._data.genvar_1,\n                    self._data.genvar_2,\n                    self._data.genvar_3,\n                    self._data.genvar_4,\n                    self._data.genvar_5,\n                ]\n            )\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning zeros\"\n            )\n            return np.zeros(shape=6)\n\n    @property\n    def accelx(self) -&gt; float:\n        \"\"\"\n        Acceleration in x direction in m/s^2.\n        Measured using actpack's onboard IMU.\n        \"\"\"\n        if self._data is not None:\n            return float(self._data.accelx * M_PER_SEC_SQUARED_ACCLSB)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def accely(self) -&gt; float:\n        \"\"\"\n        Acceleration in y direction in m/s^2.\n        Measured using actpack's onboard IMU.\n        \"\"\"\n        if self._data is not None:\n            return float(self._data.accely * M_PER_SEC_SQUARED_ACCLSB)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def accelz(self) -&gt; float:\n        \"\"\"\n        Acceleration in z direction in m/s^2.\n        Measured using actpack's onboard IMU.\n        \"\"\"\n        if self._data is not None:\n            return float(self._data.accelz * M_PER_SEC_SQUARED_ACCLSB)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def gyrox(self) -&gt; float:\n        \"\"\"\n        Angular velocity in x direction in rad/s.\n        Measured using actpack's onboard IMU.\n        \"\"\"\n        if self._data is not None:\n            return float(self._data.gyrox * RAD_PER_SEC_GYROLSB)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def gyroy(self) -&gt; float:\n        \"\"\"\n        Angular velocity in y direction in rad/s.\n        Measured using actpack's onboard IMU.\n        \"\"\"\n        if self._data is not None:\n            return float(self._data.gyroy * RAD_PER_SEC_GYROLSB)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def is_streaming(self) -&gt; bool:\n        return self._is_streaming\n\n    @is_streaming.setter\n    def is_streaming(self, value: bool) -&gt; None:\n        self._is_streaming = value\n\n    @property\n    def is_open(self) -&gt; bool:\n        return self._is_open\n\n    @is_open.setter\n    def is_open(self, value: bool) -&gt; None:\n        self._is_open = value\n\n    @property\n    def gyroz(self) -&gt; float:\n        \"\"\"\n        Angular velocity in z direction in rad/s.\n        Measured using actpack's onboard IMU.\n        \"\"\"\n        if self._data is not None:\n            return float(self._data.gyroz * RAD_PER_SEC_GYROLSB)\n        else:\n            LOGGER.debug(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n</code></pre>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyLegacyActuator.accelx","title":"<code>accelx</code>  <code>property</code>","text":"<p>Acceleration in x direction in m/s^2. Measured using actpack's onboard IMU.</p>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyLegacyActuator.accely","title":"<code>accely</code>  <code>property</code>","text":"<p>Acceleration in y direction in m/s^2. Measured using actpack's onboard IMU.</p>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyLegacyActuator.accelz","title":"<code>accelz</code>  <code>property</code>","text":"<p>Acceleration in z direction in m/s^2. Measured using actpack's onboard IMU.</p>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyLegacyActuator.battery_current","title":"<code>battery_current</code>  <code>property</code>","text":"<p>Battery current in mA.</p>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyLegacyActuator.battery_voltage","title":"<code>battery_voltage</code>  <code>property</code>","text":"<p>Battery voltage in mV.</p>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyLegacyActuator.case_temperature","title":"<code>case_temperature</code>  <code>property</code>","text":"<p>Case temperature of the actuator in celsius.</p>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyLegacyActuator.genvars","title":"<code>genvars</code>  <code>property</code>","text":"<p>Dephy's 'genvars' object.</p>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyLegacyActuator.gyrox","title":"<code>gyrox</code>  <code>property</code>","text":"<p>Angular velocity in x direction in rad/s. Measured using actpack's onboard IMU.</p>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyLegacyActuator.gyroy","title":"<code>gyroy</code>  <code>property</code>","text":"<p>Angular velocity in y direction in rad/s. Measured using actpack's onboard IMU.</p>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyLegacyActuator.gyroz","title":"<code>gyroz</code>  <code>property</code>","text":"<p>Angular velocity in z direction in rad/s. Measured using actpack's onboard IMU.</p>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyLegacyActuator.motor_acceleration","title":"<code>motor_acceleration</code>  <code>property</code>","text":"<p>Motor acceleration in rad/s^2.</p>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyLegacyActuator.motor_encoder_counts","title":"<code>motor_encoder_counts</code>  <code>property</code>","text":"<p>Raw reading from motor encoder in counts.</p>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyLegacyActuator.motor_position","title":"<code>motor_position</code>  <code>property</code>","text":"<p>Motor position in radians.</p>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyLegacyActuator.motor_torque","title":"<code>motor_torque</code>  <code>property</code>","text":"<p>Torque at the motor output in Nm.</p>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyLegacyActuator.motor_velocity","title":"<code>motor_velocity</code>  <code>property</code>","text":"<p>Motor velocity in rad/s.</p>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyLegacyActuator.motor_voltage","title":"<code>motor_voltage</code>  <code>property</code>","text":"<p>Q-axis motor voltage in mV.</p>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyLegacyActuator.output_torque","title":"<code>output_torque</code>  <code>property</code>","text":"<p>Torque at the joint output in Nm. This is calculated using motor current, k_t, and the gear ratio.</p>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyLegacyActuator.winding_temperature","title":"<code>winding_temperature</code>  <code>property</code>","text":"<p>ESTIMATED temperature of the windings in celsius. This is calculated based on the thermal model using motor current.</p>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyLegacyActuator.set_motor_current","title":"<code>set_motor_current(value)</code>","text":"<p>Sets the motor current in mA.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The current to set in mA.</p> required Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def set_motor_current(\n    self,\n    value: float,\n) -&gt; None:\n    \"\"\"\n    Sets the motor current in mA.\n\n    Args:\n        value (float): The current to set in mA.\n    \"\"\"\n    self.send_motor_command(ctrl_mode=c_int(self.mode.value), value=int(value))\n</code></pre>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyLegacyActuator.set_motor_position","title":"<code>set_motor_position(value)</code>","text":"<p>Sets the motor position in radians. If in impedance mode, this sets the equilibrium angle in radians.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The position to set</p> required Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def set_motor_position(self, value: float) -&gt; None:\n    \"\"\"\n    Sets the motor position in radians.\n    If in impedance mode, this sets the equilibrium angle in radians.\n\n    Args:\n        value (float): The position to set\n    \"\"\"\n    self.send_motor_command(\n        ctrl_mode=c_int(self.mode.value),\n        value=int((value + self.motor_zero_position) / self.MOTOR_CONSTANTS.RAD_PER_COUNT),\n    )\n</code></pre>"},{"location":"api/actuators/dephy/#opensourceleg.actuators.dephy.DephyLegacyActuator.set_motor_voltage","title":"<code>set_motor_voltage(value)</code>","text":"<p>Sets the motor voltage in mV.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The voltage to set in mV.</p> required Source code in <code>opensourceleg/actuators/dephy.py</code> <pre><code>def set_motor_voltage(self, value: float) -&gt; None:\n    \"\"\"\n    Sets the motor voltage in mV.\n\n    Args:\n        value (float): The voltage to set in mV.\n    \"\"\"\n    self.send_motor_command(ctrl_mode=c_int(self.mode.value), value=int(value))\n</code></pre>"},{"location":"api/actuators/moteus/","title":"Moteus","text":""},{"location":"api/actuators/moteus/#opensourceleg.actuators.moteus.MoteusActuator","title":"<code>MoteusActuator</code>","text":"<p>               Bases: <code>ActuatorBase</code>, <code>Controller</code></p> Source code in <code>opensourceleg/actuators/moteus.py</code> <pre><code>class MoteusActuator(ActuatorBase, Controller):\n    def __init__(\n        self,\n        tag: str = \"Moteus\",\n        servo_id: int = 0,\n        bus_id: int = 0,\n        gear_ratio: float = 1.0,\n        frequency: int = 500,\n        offline: bool = False,\n        query: Optional[MoteusQueryResolution] = None,\n    ) -&gt; None:\n        if query is None:\n            query = MoteusQueryResolution()\n\n        self._servo_id = servo_id\n        self._bus_id = bus_id\n        super().__init__(\n            tag=tag,\n            gear_ratio=gear_ratio,\n            motor_constants=MOTEUS_ACTUATOR_CONSTANTS,\n            frequency=frequency,\n            offline=offline,\n        )\n\n        self._interface = MoteusInterface()\n        self._interface._add2map(servo_id=servo_id, bus_id=bus_id)\n        self._interface.actuator_map[servo_id] = self\n\n        self._is_streaming: bool = False\n        self._is_open: bool = False\n\n        self._command: Command = None\n        self._data = None\n        self._query = query\n\n        self._thermal_model: ThermalModel = ThermalModel(\n            motor_constants=self.MOTOR_CONSTANTS,\n            actuator_tag=self.tag,\n        )\n        self._thermal_scale: float = 1.0\n\n        self._mode = CONTROL_MODES.IDLE\n\n    def __repr__(self) -&gt; str:\n        return f\"Moteus[{self._tag}]\"\n\n    @property\n    def _CONTROL_MODE_CONFIGS(self) -&gt; CONTROL_MODE_CONFIGS:\n        return MOTEUS_CONTROL_MODE_CONFIGS\n\n    @check_actuator_connection\n    async def start(self) -&gt; None:\n        try:\n            self._interface.start()\n            Controller.__init__(\n                self,\n                id=self._servo_id,\n                transport=self._interface.transport,\n                query_resolution=self._query,\n            )\n            self._stream = Stream(controller=self)\n\n            self._is_open = True\n            self._is_streaming = True\n\n        except OSError:\n            print(\"\\n\")\n            LOGGER.error(\n                msg=f\"[{self.__repr__()}] Need admin previleges to open the port. \\n\\n \\\n                    Please run the script with 'sudo' command or add the user to the dialout group.\\n\"\n            )\n            os._exit(status=1)\n\n        default_mode_config = self._get_control_mode_config(self._mode)\n        if default_mode_config:\n            default_mode_config.entry_callback(self)\n\n        if (await self._interface.transport.cycle([self.make_stop(query=True)])) == []:\n            LOGGER.error(msg=f\"[{self.__repr__()}] Could not start the actuator. Please check the connection.\")\n            self._is_streaming = False\n            self._is_open = False\n        # Keep the default command as query -- reading sensor data\n        self._command = self.make_query()\n\n    @check_actuator_stream\n    @check_actuator_open\n    async def stop(self) -&gt; None:\n        if self._interface.batch:\n            LOGGER.warning(\"Batching is enabled. Use the stop method of MoteusInterface\")\n\n        self.set_control_mode(mode=CONTROL_MODES.IDLE)\n\n        await self._interface.transport.cycle([self.make_stop(query=True)])\n        self._command = self.make_query()\n\n    async def update(self):\n        if self._interface.batch:\n            LOGGER.warning(\"Batching is enabled. Use the update method of MoteusInterface\")\n\n        self._data = await self._interface.transport.cycle([self._command])\n        self.check_thermals()\n        self._command = self.make_query()\n\n    def check_thermals(self):\n        self._thermal_scale = self._thermal_model.update(\n            dt=1 / self.frequency,\n            motor_current=self.motor_current,\n            case_temperature=self.case_temperature,\n        )\n\n    def enqueue_command(self) -&gt; None:\n        # Set the command for this cycle\n        self._interface._command_map[self._servo_id] = self._command\n\n    def enqueue_stop_command(self) -&gt; None:\n        self._interface._stop_servos.append(self)\n\n    def home(\n        self,\n        homing_voltage: int = 2000,\n        homing_frequency: Optional[int] = None,\n        homing_direction: int = -1,\n        output_position_offset: float = 0.0,\n        current_threshold: int = 5000,\n        velocity_threshold: float = 0.001,\n    ) -&gt; None:\n        # TODO: implement homing\n        LOGGER.info(msg=f\"[{self.__repr__()}] Homing not implemented.\")\n\n    def set_motor_torque(self, value: float) -&gt; None:\n        \"\"\"\n        Sets the motor torque in Nm.\n\n        Args:\n            value (float): The torque to set in Nm.\n        \"\"\"\n        self._command = self.make_position(\n            position=math.nan,\n            velocity=math.nan,\n            feedforward_torque=value,\n            kp_scale=0,\n            kd_scale=0,\n            ilimit_scale=0,\n            watchdog_timeout=math.nan,\n            query=True,\n        )\n\n        if self._interface.batch:\n            self.enqueue_command()\n\n    def set_output_torque(self, value: float) -&gt; None:\n        \"\"\"\n        Set the output torque of the actuator.\n        This is the torque that is applied to the joint, not the motor.\n\n        Args:\n            value (float): torque in N_m\n        \"\"\"\n        self.set_motor_torque(value=value / self.gear_ratio)\n\n    def set_motor_current(\n        self,\n        value: float,\n    ) -&gt; None:\n        LOGGER.info(\"Current Mode Not Implemented\")\n\n    def set_motor_velocity(self, value: float) -&gt; None:\n        self._command = self.make_position(\n            position=math.nan,\n            velocity=value / (np.pi * 2),  # TODO: Verify this conversion, are we converting from rad/s to rev/s?\n            query=True,\n            watchdog_timeout=math.nan,\n        )\n\n        if self._interface.batch:\n            self.enqueue_command()\n\n    def set_motor_voltage(self, value: float) -&gt; None:\n        \"\"\"\n        Sets the motor voltage in mV.\n\n        Args:\n            value (float): The voltage to set in mV.\n        \"\"\"\n        LOGGER.info(\"Voltage Mode Not Implemented\")\n\n    def set_motor_position(self, value: float) -&gt; None:\n        \"\"\"\n        Sets the motor position in radians.\n        If in impedance mode, this sets the equilibrium angle in radians.\n\n        Args:\n            value (float): The position to set\n        \"\"\"\n        self._command = self.make_position(\n            position=float((value) / (2 * np.pi)),  # TODO: Verify this conversion, are we converting from rad to rev?\n            query=True,\n            watchdog_timeout=math.nan,\n        )\n\n        if self._interface.batch:\n            self.enqueue_command()\n\n    async def set_torque_gains(\n        self,\n        kp: float = DEFAULT_TORQUE_GAINS.kp,\n        ki: float = DEFAULT_TORQUE_GAINS.ki,\n    ) -&gt; None:\n        \"\"\"\n        Sets the position gains in arbitrary Moteus units.\n\n        Args:\n            kp (float): The proportional gain\n            ki (float): The integral gain\n        \"\"\"\n        await self._stream.command(f\"conf set servo.pid_dq.kp {kp}\".encode())\n        await self._stream.command(f\"conf set servo.pid_dq.ki {ki}\".encode())\n\n    async def set_position_gains(\n        self,\n        kp: float = DEFAULT_POSITION_GAINS.kp,\n        ki: float = DEFAULT_POSITION_GAINS.ki,\n        kd: float = DEFAULT_POSITION_GAINS.kd,\n        ff: float = DEFAULT_POSITION_GAINS.ff,\n    ) -&gt; None:\n        \"\"\"\n        Sets the position gains in arbitrary Moteus units.\n\n        Args:\n            kp (float): The proportional gain\n            ki (float): The integral gain\n            kd (float): The derivative gain\n            ff (float): The feedforward gain\n        \"\"\"\n        await self._stream.command(f\"conf set servo.pid_position.kp {kp}\".encode())\n        await self._stream.command(f\"conf set servo.pid_position.ki {ki}\".encode())\n        await self._stream.command(f\"conf set servo.pid_position.kd {kd}\".encode())\n\n    async def set_velocity_gains(\n        self,\n        kp: float = DEFAULT_VELOCITY_GAINS.kp,\n        ki: float = DEFAULT_VELOCITY_GAINS.ki,\n        kd: float = DEFAULT_VELOCITY_GAINS.kd,\n        ff: float = DEFAULT_VELOCITY_GAINS.ff,\n    ) -&gt; None:\n        \"\"\"\n        Sets the position gains in arbitrary Moteus units.\n\n        Args:\n            kp (float): The proportional gain\n            ki (float): The integral gain\n            kd (float): The derivative gain\n            ff (float): The feedforward gain\n        \"\"\"\n        await self._stream.command(f\"conf set servo.pid_position.kp {kp}\".encode())\n        await self._stream.command(f\"conf set servo.pid_position.ki {ki}\".encode())\n        await self._stream.command(f\"conf set servo.pid_position.kd {kd}\".encode())\n\n    def set_current_gains(\n        self,\n        kp: float = DEFAULT_CURRENT_GAINS.kp,\n        ki: float = DEFAULT_CURRENT_GAINS.ki,\n        kd: float = DEFAULT_CURRENT_GAINS.kd,\n        ff: float = DEFAULT_CURRENT_GAINS.ff,\n    ) -&gt; None:\n        \"\"\"\n        Sets the current gains in arbitrary Moteus units.\n\n        Args:\n            kp (float): The proportional gain\n            ki (float): The integral gain\n            kd (float): The derivative gain\n            ff (float): The feedforward gain\n        \"\"\"\n        LOGGER.info(msg=f\"[{self.__repr__()}] Current mode not implemented.\")\n\n    def _set_impedance_gains(\n        self,\n        k: float = DEFAULT_IMPEDANCE_GAINS.k,\n        b: float = DEFAULT_IMPEDANCE_GAINS.b,\n    ) -&gt; None:\n        LOGGER.info(msg=f\"[{self.__repr__()}] Impedance mode not implemented.\")\n\n    @property\n    def motor_voltage(self) -&gt; float:\n        \"\"\"Q-axis motor voltage in mV.\"\"\"\n        if self._data is not None:\n            return float(self._data[0].values[MoteusRegister.VOLTAGE])\n        else:\n            LOGGER.warning(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def motor_current(self) -&gt; float:\n        if self._data is not None:\n            return float(self._data[0].values[MoteusRegister.Q_CURRENT])\n        else:\n            LOGGER.warning(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def motor_torque(self) -&gt; float:\n        if self._data is not None:\n            return float(self.motor_current * self.MOTOR_CONSTANTS.NM_PER_MILLIAMP) / self.gear_ratio\n        else:\n            LOGGER.warning(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def motor_position(self) -&gt; float:\n        if self._data is not None:\n            return float(self._data[0].values[MoteusRegister.POSITION] * 2 * np.pi) - self.motor_zero_position\n        else:\n            LOGGER.warning(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def motor_velocity(self) -&gt; float:\n        if self._data is not None:\n            return float(self._data[0].values[MoteusRegister.VELOCITY] * 2 * np.pi)\n        else:\n            LOGGER.warning(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def battery_voltage(self) -&gt; float:\n        \"\"\"Battery voltage in mV.\"\"\"\n        if self._data is not None:\n            return float(self._data[0].values[MoteusRegister.VOLTAGE])\n        else:\n            LOGGER.warning(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def battery_current(self) -&gt; float:\n        \"\"\"Battery current in mA.\"\"\"\n        if self._data is not None:\n            return float(self._data[0].values[MoteusRegister.Q_CURRENT])\n        else:\n            LOGGER.warning(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def joint_torque(self) -&gt; float:\n        \"\"\"\n        Torque at the joint output in Nm.\n        This is calculated using motor current, k_t, and the gear ratio.\n        \"\"\"\n        return self.motor_torque * self.gear_ratio\n\n    @property\n    def case_temperature(self) -&gt; float:\n        if self._data is not None:\n            return float(self._data[0].values[MoteusRegister.TEMPERATURE])\n        else:\n            LOGGER.warning(\n                msg=\"Actuator data is none, please ensure that the actuator is connected and streaming. Returning 0.0.\"\n            )\n            return 0.0\n\n    @property\n    def winding_temperature(self) -&gt; float:\n        \"\"\"\n        ESTIMATED temperature of the windings in celsius.\n        This is calculated based on the thermal model using motor current.\n        \"\"\"\n        if self._data is not None:\n            return float(self._thermal_model.winding_temperature)\n        else:\n            return 0.0\n\n    @property\n    def thermal_scaling_factor(self) -&gt; float:\n        \"\"\"\n        Scale factor to use in torque control, in [0,1].\n        If you scale the torque command by this factor, the motor temperature will\n        never exceed max allowable temperature.\n        For a proof, see paper referenced in thermal model.\n        \"\"\"\n        return self._thermal_scale\n</code></pre>"},{"location":"api/actuators/moteus/#opensourceleg.actuators.moteus.MoteusActuator.battery_current","title":"<code>battery_current</code>  <code>property</code>","text":"<p>Battery current in mA.</p>"},{"location":"api/actuators/moteus/#opensourceleg.actuators.moteus.MoteusActuator.battery_voltage","title":"<code>battery_voltage</code>  <code>property</code>","text":"<p>Battery voltage in mV.</p>"},{"location":"api/actuators/moteus/#opensourceleg.actuators.moteus.MoteusActuator.joint_torque","title":"<code>joint_torque</code>  <code>property</code>","text":"<p>Torque at the joint output in Nm. This is calculated using motor current, k_t, and the gear ratio.</p>"},{"location":"api/actuators/moteus/#opensourceleg.actuators.moteus.MoteusActuator.motor_voltage","title":"<code>motor_voltage</code>  <code>property</code>","text":"<p>Q-axis motor voltage in mV.</p>"},{"location":"api/actuators/moteus/#opensourceleg.actuators.moteus.MoteusActuator.thermal_scaling_factor","title":"<code>thermal_scaling_factor</code>  <code>property</code>","text":"<p>Scale factor to use in torque control, in [0,1]. If you scale the torque command by this factor, the motor temperature will never exceed max allowable temperature. For a proof, see paper referenced in thermal model.</p>"},{"location":"api/actuators/moteus/#opensourceleg.actuators.moteus.MoteusActuator.winding_temperature","title":"<code>winding_temperature</code>  <code>property</code>","text":"<p>ESTIMATED temperature of the windings in celsius. This is calculated based on the thermal model using motor current.</p>"},{"location":"api/actuators/moteus/#opensourceleg.actuators.moteus.MoteusActuator.set_current_gains","title":"<code>set_current_gains(kp=DEFAULT_CURRENT_GAINS.kp, ki=DEFAULT_CURRENT_GAINS.ki, kd=DEFAULT_CURRENT_GAINS.kd, ff=DEFAULT_CURRENT_GAINS.ff)</code>","text":"<p>Sets the current gains in arbitrary Moteus units.</p> <p>Parameters:</p> Name Type Description Default <code>kp</code> <code>float</code> <p>The proportional gain</p> <code>kp</code> <code>ki</code> <code>float</code> <p>The integral gain</p> <code>ki</code> <code>kd</code> <code>float</code> <p>The derivative gain</p> <code>kd</code> <code>ff</code> <code>float</code> <p>The feedforward gain</p> <code>ff</code> Source code in <code>opensourceleg/actuators/moteus.py</code> <pre><code>def set_current_gains(\n    self,\n    kp: float = DEFAULT_CURRENT_GAINS.kp,\n    ki: float = DEFAULT_CURRENT_GAINS.ki,\n    kd: float = DEFAULT_CURRENT_GAINS.kd,\n    ff: float = DEFAULT_CURRENT_GAINS.ff,\n) -&gt; None:\n    \"\"\"\n    Sets the current gains in arbitrary Moteus units.\n\n    Args:\n        kp (float): The proportional gain\n        ki (float): The integral gain\n        kd (float): The derivative gain\n        ff (float): The feedforward gain\n    \"\"\"\n    LOGGER.info(msg=f\"[{self.__repr__()}] Current mode not implemented.\")\n</code></pre>"},{"location":"api/actuators/moteus/#opensourceleg.actuators.moteus.MoteusActuator.set_motor_position","title":"<code>set_motor_position(value)</code>","text":"<p>Sets the motor position in radians. If in impedance mode, this sets the equilibrium angle in radians.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The position to set</p> required Source code in <code>opensourceleg/actuators/moteus.py</code> <pre><code>def set_motor_position(self, value: float) -&gt; None:\n    \"\"\"\n    Sets the motor position in radians.\n    If in impedance mode, this sets the equilibrium angle in radians.\n\n    Args:\n        value (float): The position to set\n    \"\"\"\n    self._command = self.make_position(\n        position=float((value) / (2 * np.pi)),  # TODO: Verify this conversion, are we converting from rad to rev?\n        query=True,\n        watchdog_timeout=math.nan,\n    )\n\n    if self._interface.batch:\n        self.enqueue_command()\n</code></pre>"},{"location":"api/actuators/moteus/#opensourceleg.actuators.moteus.MoteusActuator.set_motor_torque","title":"<code>set_motor_torque(value)</code>","text":"<p>Sets the motor torque in Nm.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The torque to set in Nm.</p> required Source code in <code>opensourceleg/actuators/moteus.py</code> <pre><code>def set_motor_torque(self, value: float) -&gt; None:\n    \"\"\"\n    Sets the motor torque in Nm.\n\n    Args:\n        value (float): The torque to set in Nm.\n    \"\"\"\n    self._command = self.make_position(\n        position=math.nan,\n        velocity=math.nan,\n        feedforward_torque=value,\n        kp_scale=0,\n        kd_scale=0,\n        ilimit_scale=0,\n        watchdog_timeout=math.nan,\n        query=True,\n    )\n\n    if self._interface.batch:\n        self.enqueue_command()\n</code></pre>"},{"location":"api/actuators/moteus/#opensourceleg.actuators.moteus.MoteusActuator.set_motor_voltage","title":"<code>set_motor_voltage(value)</code>","text":"<p>Sets the motor voltage in mV.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The voltage to set in mV.</p> required Source code in <code>opensourceleg/actuators/moteus.py</code> <pre><code>def set_motor_voltage(self, value: float) -&gt; None:\n    \"\"\"\n    Sets the motor voltage in mV.\n\n    Args:\n        value (float): The voltage to set in mV.\n    \"\"\"\n    LOGGER.info(\"Voltage Mode Not Implemented\")\n</code></pre>"},{"location":"api/actuators/moteus/#opensourceleg.actuators.moteus.MoteusActuator.set_output_torque","title":"<code>set_output_torque(value)</code>","text":"<p>Set the output torque of the actuator. This is the torque that is applied to the joint, not the motor.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>torque in N_m</p> required Source code in <code>opensourceleg/actuators/moteus.py</code> <pre><code>def set_output_torque(self, value: float) -&gt; None:\n    \"\"\"\n    Set the output torque of the actuator.\n    This is the torque that is applied to the joint, not the motor.\n\n    Args:\n        value (float): torque in N_m\n    \"\"\"\n    self.set_motor_torque(value=value / self.gear_ratio)\n</code></pre>"},{"location":"api/actuators/moteus/#opensourceleg.actuators.moteus.MoteusActuator.set_position_gains","title":"<code>set_position_gains(kp=DEFAULT_POSITION_GAINS.kp, ki=DEFAULT_POSITION_GAINS.ki, kd=DEFAULT_POSITION_GAINS.kd, ff=DEFAULT_POSITION_GAINS.ff)</code>  <code>async</code>","text":"<p>Sets the position gains in arbitrary Moteus units.</p> <p>Parameters:</p> Name Type Description Default <code>kp</code> <code>float</code> <p>The proportional gain</p> <code>kp</code> <code>ki</code> <code>float</code> <p>The integral gain</p> <code>ki</code> <code>kd</code> <code>float</code> <p>The derivative gain</p> <code>kd</code> <code>ff</code> <code>float</code> <p>The feedforward gain</p> <code>ff</code> Source code in <code>opensourceleg/actuators/moteus.py</code> <pre><code>async def set_position_gains(\n    self,\n    kp: float = DEFAULT_POSITION_GAINS.kp,\n    ki: float = DEFAULT_POSITION_GAINS.ki,\n    kd: float = DEFAULT_POSITION_GAINS.kd,\n    ff: float = DEFAULT_POSITION_GAINS.ff,\n) -&gt; None:\n    \"\"\"\n    Sets the position gains in arbitrary Moteus units.\n\n    Args:\n        kp (float): The proportional gain\n        ki (float): The integral gain\n        kd (float): The derivative gain\n        ff (float): The feedforward gain\n    \"\"\"\n    await self._stream.command(f\"conf set servo.pid_position.kp {kp}\".encode())\n    await self._stream.command(f\"conf set servo.pid_position.ki {ki}\".encode())\n    await self._stream.command(f\"conf set servo.pid_position.kd {kd}\".encode())\n</code></pre>"},{"location":"api/actuators/moteus/#opensourceleg.actuators.moteus.MoteusActuator.set_torque_gains","title":"<code>set_torque_gains(kp=DEFAULT_TORQUE_GAINS.kp, ki=DEFAULT_TORQUE_GAINS.ki)</code>  <code>async</code>","text":"<p>Sets the position gains in arbitrary Moteus units.</p> <p>Parameters:</p> Name Type Description Default <code>kp</code> <code>float</code> <p>The proportional gain</p> <code>kp</code> <code>ki</code> <code>float</code> <p>The integral gain</p> <code>ki</code> Source code in <code>opensourceleg/actuators/moteus.py</code> <pre><code>async def set_torque_gains(\n    self,\n    kp: float = DEFAULT_TORQUE_GAINS.kp,\n    ki: float = DEFAULT_TORQUE_GAINS.ki,\n) -&gt; None:\n    \"\"\"\n    Sets the position gains in arbitrary Moteus units.\n\n    Args:\n        kp (float): The proportional gain\n        ki (float): The integral gain\n    \"\"\"\n    await self._stream.command(f\"conf set servo.pid_dq.kp {kp}\".encode())\n    await self._stream.command(f\"conf set servo.pid_dq.ki {ki}\".encode())\n</code></pre>"},{"location":"api/actuators/moteus/#opensourceleg.actuators.moteus.MoteusActuator.set_velocity_gains","title":"<code>set_velocity_gains(kp=DEFAULT_VELOCITY_GAINS.kp, ki=DEFAULT_VELOCITY_GAINS.ki, kd=DEFAULT_VELOCITY_GAINS.kd, ff=DEFAULT_VELOCITY_GAINS.ff)</code>  <code>async</code>","text":"<p>Sets the position gains in arbitrary Moteus units.</p> <p>Parameters:</p> Name Type Description Default <code>kp</code> <code>float</code> <p>The proportional gain</p> <code>kp</code> <code>ki</code> <code>float</code> <p>The integral gain</p> <code>ki</code> <code>kd</code> <code>float</code> <p>The derivative gain</p> <code>kd</code> <code>ff</code> <code>float</code> <p>The feedforward gain</p> <code>ff</code> Source code in <code>opensourceleg/actuators/moteus.py</code> <pre><code>async def set_velocity_gains(\n    self,\n    kp: float = DEFAULT_VELOCITY_GAINS.kp,\n    ki: float = DEFAULT_VELOCITY_GAINS.ki,\n    kd: float = DEFAULT_VELOCITY_GAINS.kd,\n    ff: float = DEFAULT_VELOCITY_GAINS.ff,\n) -&gt; None:\n    \"\"\"\n    Sets the position gains in arbitrary Moteus units.\n\n    Args:\n        kp (float): The proportional gain\n        ki (float): The integral gain\n        kd (float): The derivative gain\n        ff (float): The feedforward gain\n    \"\"\"\n    await self._stream.command(f\"conf set servo.pid_position.kp {kp}\".encode())\n    await self._stream.command(f\"conf set servo.pid_position.ki {ki}\".encode())\n    await self._stream.command(f\"conf set servo.pid_position.kd {kd}\".encode())\n</code></pre>"},{"location":"api/actuators/moteus/#opensourceleg.actuators.moteus.MoteusInterface","title":"<code>MoteusInterface</code>","text":"<p>Singleton Class as Communication Portal between Moteus Controller and Moteus PiHat</p> Source code in <code>opensourceleg/actuators/moteus.py</code> <pre><code>class MoteusInterface:\n    \"\"\"\n    Singleton Class as Communication Portal between Moteus Controller and Moteus PiHat\n    \"\"\"\n\n    _instance = None\n\n    def __new__(cls, *args, **kwargs):\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            cls.bus_map: dict[int, list[int]] = {}\n            cls.actuator_map: dict[int, MoteusActuator] = {}\n            cls._command_map: dict[int, Command] = {}\n            cls._stop_servos: list[MoteusActuator] = []\n            cls.transport = None\n\n            batch = kwargs.pop(\"batch\", False)  # default to false\n            cls.batch = batch\n\n        return cls._instance\n\n    def __init__(self):\n        pass\n\n    def __repr__(self):\n        return \"MoteusInterface\"\n\n    def _add2map(self, servo_id, bus_id) -&gt; None:\n        if bus_id in self.bus_map:\n            self.bus_map[bus_id].append(servo_id)\n        else:\n            self.bus_map[bus_id] = [servo_id]\n\n    def start(self):\n        \"\"\"\n        Initialization of Pi3HatRouter\n        \"\"\"\n        if self.transport is None:\n            if not _PIHAT_AVAILABLE:\n                LOGGER.error(msg=\"Moteus PiHat not found. Please install the moteus_pi3hat package.\")\n                raise ImportError(\"moteus_pi3hat package is required for MoteusRouter\")\n            self.transport = pihat.Pi3HatRouter(servo_bus_map=self.bus_map)\n\n    async def update(self):\n        if not self.batch:\n            LOGGER.warning(\"Batching is disabled. Use the update method of MoteusActuator\")\n\n        commands = []\n        for servo_id in self.actuator_map:\n            if servo_id in self._command_map:\n                # Command has been set for this cycle\n                commands.append(self._command_map[servo_id])\n            else:\n                # Default to query\n                actuator = self.actuator_map.get(servo_id)\n                commands.append(actuator.make_query())\n\n        results = await self.transport.cycle(commands)\n\n        for result in results:\n            actuator = self.actuator_map.get(result.id)\n            if actuator:\n                actuator._data = result\n                actuator.check_thermals()\n\n        self._command_map.clear()\n\n    async def stop(self):\n        if not self.batch:\n            LOGGER.warning(\"Batching is disabled. Use the stop method of MoteusActuator\")\n\n        if not self._stop_servos:\n            return\n\n        stopCommands = []\n\n        for actuator in self._stop_servos:\n            actuator.set_control_mode(mode=CONTROL_MODES.IDLE)\n            stopCommands.append(actuator.make_stop(query=True))\n\n        await self.transport.cycle(stopCommands)\n        self._stop_servos.clear()\n</code></pre>"},{"location":"api/actuators/moteus/#opensourceleg.actuators.moteus.MoteusInterface.start","title":"<code>start()</code>","text":"<p>Initialization of Pi3HatRouter</p> Source code in <code>opensourceleg/actuators/moteus.py</code> <pre><code>def start(self):\n    \"\"\"\n    Initialization of Pi3HatRouter\n    \"\"\"\n    if self.transport is None:\n        if not _PIHAT_AVAILABLE:\n            LOGGER.error(msg=\"Moteus PiHat not found. Please install the moteus_pi3hat package.\")\n            raise ImportError(\"moteus_pi3hat package is required for MoteusRouter\")\n        self.transport = pihat.Pi3HatRouter(servo_bus_map=self.bus_map)\n</code></pre>"},{"location":"api/actuators/tmotor/","title":"TMotor","text":""},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.CANManagerServo","title":"<code>CANManagerServo</code>","text":"<p>TMotor servo mode CAN communication manager</p> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>class CANManagerServo:\n    \"\"\"TMotor servo mode CAN communication manager\"\"\"\n\n    _instance: Optional[\"CANManagerServo\"] = None\n    debug: bool = False\n    _initialized: bool = False\n\n    def __new__(cls) -&gt; \"CANManagerServo\":\n        if not cls._instance:\n            cls._instance = super().__new__(cls)\n            cls._instance._initialized = False\n        return cls._instance\n\n    def __init__(self) -&gt; None:\n        if hasattr(self, \"_initialized\") and self._initialized:\n            return\n\n        LOGGER.info(\"Initializing CAN Manager for TMotor Servo Mode\")\n        try:\n            # NOTE: CAN interface must be configured before running this code.\n            # Please run the following commands before using TMotor servo mode:\n            # sudo /sbin/ip link set can0 down\n            # sudo /sbin/ip link set can0 up type can bitrate 1000000\n            # sudo ifconfig can0 txqueuelen 1000\n\n            self.bus = can.interface.Bus(channel=\"can0\", bustype=\"socketcan\")\n            self.notifier = can.Notifier(bus=self.bus, listeners=[])\n\n            LOGGER.info(f\"CAN bus connected: {self.bus}\")\n            self._initialized = True\n\n        except Exception as e:\n            LOGGER.error(f\"CAN bus initialization failed: {e}\")\n            LOGGER.error(\"Please ensure CAN interface is configured. Run:\")\n            LOGGER.error(\"sudo /sbin/ip link set can0 down\")\n            LOGGER.error(\"sudo /sbin/ip link set can0 up type can bitrate 1000000\")\n            LOGGER.error(\"sudo ifconfig can0 txqueuelen 1000\")\n            raise RuntimeError(\"CAN bus initialization failed. Please configure CAN interface first.\") from e\n\n    def __del__(self) -&gt; None:\n        try:\n            if hasattr(self, \"bus\"):\n                self.bus.shutdown()\n        except Exception as e:\n            LOGGER.warning(f\"Error shutting down CAN bus: {e}\")\n\n    def send_message(self, motor_id: int, data: list, data_len: int) -&gt; None:\n        \"\"\"Send CAN message\"\"\"\n        if data_len &gt; 8:\n            raise ValueError(f\"Data too long in message for motor {motor_id}\")\n\n        if self.debug:\n            LOGGER.info(f'ID: {hex(motor_id)} Data: [{\", \".join(hex(d) for d in data)}]')\n\n        message = can.Message(arbitration_id=motor_id, data=data, is_extended_id=True)\n\n        try:\n            self.bus.send(message)\n        except can.CanError as e:\n            LOGGER.error(f\"Failed to send CAN message: {e}\")\n\n    def power_on(self, motor_id: int) -&gt; None:\n        \"\"\"Send power on command\"\"\"\n        self.send_message(motor_id, [0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC], 8)\n\n    def power_off(self, motor_id: int) -&gt; None:\n        \"\"\"Send power off command\"\"\"\n        self.send_message(motor_id, [0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD], 8)\n\n    def set_current(self, controller_id: int, current: float) -&gt; None:\n        \"\"\"Send current control command\"\"\"\n        current_protocol = int(current * 1000.0)  # Convert to protocol units\n        buffer = self._pack_int32(current_protocol)\n        message_id = (CAN_PACKET_ID[\"SET_CURRENT\"] &lt;&lt; 8) | controller_id\n        self.send_message(message_id, buffer, len(buffer))\n\n    def set_velocity(self, controller_id: int, velocity: float) -&gt; None:\n        \"\"\"Send velocity control command\"\"\"\n        buffer = self._pack_int32(int(velocity))\n        message_id = (CAN_PACKET_ID[\"SET_RPM\"] &lt;&lt; 8) | controller_id\n        self.send_message(message_id, buffer, len(buffer))\n\n    def set_position(self, controller_id: int, position: float) -&gt; None:\n        \"\"\"Send position control command\"\"\"\n        # NOTE(IMPORTANT): TMotor spec uses 1,000,000 scale (0.000001\u00b0 resolution) per documentation\n        # Current implementation uses 10 scale (0.1\u00b0 resolution) for simplicity\n        # To enable high-precision position control, change to: int(position * 1000000.0)\n        buffer = self._pack_int32(int(position * 10.0))  # 0.1 degree resolution\n        message_id = (CAN_PACKET_ID[\"SET_POS\"] &lt;&lt; 8) | controller_id\n        self.send_message(message_id, buffer, len(buffer))\n\n    def set_origin(self, controller_id: int, mode: int = 1) -&gt; None:\n        \"\"\"Set motor origin\"\"\"\n        buffer = [mode]\n        message_id = (CAN_PACKET_ID[\"SET_ORIGIN_HERE\"] &lt;&lt; 8) | controller_id\n        self.send_message(message_id, buffer, len(buffer))\n\n    def set_control_mode(self, controller_id: int, mode: int) -&gt; None:\n        \"\"\"Send control mode switch command\"\"\"\n        buffer = [mode]\n        message_id = (7 &lt;&lt; 8) | controller_id  # Assume packet_id=7 for mode switching\n        self.send_message(message_id, buffer, len(buffer))\n\n    @staticmethod\n    def _pack_int32(number: int) -&gt; list:\n        \"\"\"Pack 32-bit integer to byte list (big-endian, MSB first)\"\"\"\n        if number &lt; 0:\n            number = (1 &lt;&lt; 32) + number\n        # TMotor expects big-endian (MSB first) per documentation\n        return [(number &gt;&gt; 24) &amp; 0xFF, (number &gt;&gt; 16) &amp; 0xFF, (number &gt;&gt; 8) &amp; 0xFF, number &amp; 0xFF]\n\n    def parse_servo_message(self, data: bytes) -&gt; ServoMotorState:\n        \"\"\"Parse servo message to motor state\"\"\"\n        if len(data) &lt; 8:\n            raise ValueError(f\"Invalid message length: {len(data)}\")\n\n        # Fix endian issue: TMotor packs as big-endian (Data[n]&lt;&lt;8 | Data[n+1])\n        pos_int = int.from_bytes(data[0:2], byteorder=\"big\", signed=True)\n        spd_int = int.from_bytes(data[2:4], byteorder=\"big\", signed=True)\n        cur_int = int.from_bytes(data[4:6], byteorder=\"big\", signed=True)\n\n        motor_pos = float(pos_int * 0.1)  # position (degrees)\n        motor_spd = float(spd_int * 10.0)  # velocity (ERPM)\n        motor_cur = float(cur_int * 0.01)  # current (amps)\n        motor_temp = float(data[6])  # temperature (celsius)\n        motor_error = int(data[7])  # error code\n\n        return ServoMotorState(motor_pos, motor_spd, motor_cur, motor_temp, motor_error)\n\n    def add_motor_listener(self, motor: \"TMotorServoActuator\") -&gt; None:\n        \"\"\"Add motor listener\"\"\"\n        listener = MotorListener(self, motor)\n        self.notifier.add_listener(listener)\n\n    def enable_debug(self, enable: bool = True) -&gt; None:\n        \"\"\"Enable/disable debug mode\"\"\"\n        self.debug = enable\n        if enable:\n            LOGGER.info(\"CAN debug mode enabled\")\n</code></pre>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.CANManagerServo.add_motor_listener","title":"<code>add_motor_listener(motor)</code>","text":"<p>Add motor listener</p> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>def add_motor_listener(self, motor: \"TMotorServoActuator\") -&gt; None:\n    \"\"\"Add motor listener\"\"\"\n    listener = MotorListener(self, motor)\n    self.notifier.add_listener(listener)\n</code></pre>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.CANManagerServo.enable_debug","title":"<code>enable_debug(enable=True)</code>","text":"<p>Enable/disable debug mode</p> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>def enable_debug(self, enable: bool = True) -&gt; None:\n    \"\"\"Enable/disable debug mode\"\"\"\n    self.debug = enable\n    if enable:\n        LOGGER.info(\"CAN debug mode enabled\")\n</code></pre>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.CANManagerServo.parse_servo_message","title":"<code>parse_servo_message(data)</code>","text":"<p>Parse servo message to motor state</p> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>def parse_servo_message(self, data: bytes) -&gt; ServoMotorState:\n    \"\"\"Parse servo message to motor state\"\"\"\n    if len(data) &lt; 8:\n        raise ValueError(f\"Invalid message length: {len(data)}\")\n\n    # Fix endian issue: TMotor packs as big-endian (Data[n]&lt;&lt;8 | Data[n+1])\n    pos_int = int.from_bytes(data[0:2], byteorder=\"big\", signed=True)\n    spd_int = int.from_bytes(data[2:4], byteorder=\"big\", signed=True)\n    cur_int = int.from_bytes(data[4:6], byteorder=\"big\", signed=True)\n\n    motor_pos = float(pos_int * 0.1)  # position (degrees)\n    motor_spd = float(spd_int * 10.0)  # velocity (ERPM)\n    motor_cur = float(cur_int * 0.01)  # current (amps)\n    motor_temp = float(data[6])  # temperature (celsius)\n    motor_error = int(data[7])  # error code\n\n    return ServoMotorState(motor_pos, motor_spd, motor_cur, motor_temp, motor_error)\n</code></pre>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.CANManagerServo.power_off","title":"<code>power_off(motor_id)</code>","text":"<p>Send power off command</p> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>def power_off(self, motor_id: int) -&gt; None:\n    \"\"\"Send power off command\"\"\"\n    self.send_message(motor_id, [0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD], 8)\n</code></pre>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.CANManagerServo.power_on","title":"<code>power_on(motor_id)</code>","text":"<p>Send power on command</p> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>def power_on(self, motor_id: int) -&gt; None:\n    \"\"\"Send power on command\"\"\"\n    self.send_message(motor_id, [0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC], 8)\n</code></pre>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.CANManagerServo.send_message","title":"<code>send_message(motor_id, data, data_len)</code>","text":"<p>Send CAN message</p> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>def send_message(self, motor_id: int, data: list, data_len: int) -&gt; None:\n    \"\"\"Send CAN message\"\"\"\n    if data_len &gt; 8:\n        raise ValueError(f\"Data too long in message for motor {motor_id}\")\n\n    if self.debug:\n        LOGGER.info(f'ID: {hex(motor_id)} Data: [{\", \".join(hex(d) for d in data)}]')\n\n    message = can.Message(arbitration_id=motor_id, data=data, is_extended_id=True)\n\n    try:\n        self.bus.send(message)\n    except can.CanError as e:\n        LOGGER.error(f\"Failed to send CAN message: {e}\")\n</code></pre>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.CANManagerServo.set_control_mode","title":"<code>set_control_mode(controller_id, mode)</code>","text":"<p>Send control mode switch command</p> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>def set_control_mode(self, controller_id: int, mode: int) -&gt; None:\n    \"\"\"Send control mode switch command\"\"\"\n    buffer = [mode]\n    message_id = (7 &lt;&lt; 8) | controller_id  # Assume packet_id=7 for mode switching\n    self.send_message(message_id, buffer, len(buffer))\n</code></pre>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.CANManagerServo.set_current","title":"<code>set_current(controller_id, current)</code>","text":"<p>Send current control command</p> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>def set_current(self, controller_id: int, current: float) -&gt; None:\n    \"\"\"Send current control command\"\"\"\n    current_protocol = int(current * 1000.0)  # Convert to protocol units\n    buffer = self._pack_int32(current_protocol)\n    message_id = (CAN_PACKET_ID[\"SET_CURRENT\"] &lt;&lt; 8) | controller_id\n    self.send_message(message_id, buffer, len(buffer))\n</code></pre>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.CANManagerServo.set_origin","title":"<code>set_origin(controller_id, mode=1)</code>","text":"<p>Set motor origin</p> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>def set_origin(self, controller_id: int, mode: int = 1) -&gt; None:\n    \"\"\"Set motor origin\"\"\"\n    buffer = [mode]\n    message_id = (CAN_PACKET_ID[\"SET_ORIGIN_HERE\"] &lt;&lt; 8) | controller_id\n    self.send_message(message_id, buffer, len(buffer))\n</code></pre>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.CANManagerServo.set_position","title":"<code>set_position(controller_id, position)</code>","text":"<p>Send position control command</p> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>def set_position(self, controller_id: int, position: float) -&gt; None:\n    \"\"\"Send position control command\"\"\"\n    # NOTE(IMPORTANT): TMotor spec uses 1,000,000 scale (0.000001\u00b0 resolution) per documentation\n    # Current implementation uses 10 scale (0.1\u00b0 resolution) for simplicity\n    # To enable high-precision position control, change to: int(position * 1000000.0)\n    buffer = self._pack_int32(int(position * 10.0))  # 0.1 degree resolution\n    message_id = (CAN_PACKET_ID[\"SET_POS\"] &lt;&lt; 8) | controller_id\n    self.send_message(message_id, buffer, len(buffer))\n</code></pre>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.CANManagerServo.set_velocity","title":"<code>set_velocity(controller_id, velocity)</code>","text":"<p>Send velocity control command</p> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>def set_velocity(self, controller_id: int, velocity: float) -&gt; None:\n    \"\"\"Send velocity control command\"\"\"\n    buffer = self._pack_int32(int(velocity))\n    message_id = (CAN_PACKET_ID[\"SET_RPM\"] &lt;&lt; 8) | controller_id\n    self.send_message(message_id, buffer, len(buffer))\n</code></pre>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.MotorListener","title":"<code>MotorListener</code>","text":"<p>               Bases: <code>Listener</code></p> <p>CAN message listener</p> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>class MotorListener(can.Listener):\n    \"\"\"CAN message listener\"\"\"\n\n    def __init__(self, canman: CANManagerServo, motor: \"TMotorServoActuator\") -&gt; None:\n        self.canman = canman\n        self.motor = motor\n\n    def on_message_received(self, msg: can.Message) -&gt; None:\n        \"\"\"Handle received CAN message\"\"\"\n        data = bytes(msg.data)\n        motor_id = msg.arbitration_id &amp; 0x00000FF\n        if motor_id == self.motor.motor_id:\n            self.motor._update_state_async(self.canman.parse_servo_message(data))\n</code></pre>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.MotorListener.on_message_received","title":"<code>on_message_received(msg)</code>","text":"<p>Handle received CAN message</p> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>def on_message_received(self, msg: can.Message) -&gt; None:\n    \"\"\"Handle received CAN message\"\"\"\n    data = bytes(msg.data)\n    motor_id = msg.arbitration_id &amp; 0x00000FF\n    if motor_id == self.motor.motor_id:\n        self.motor._update_state_async(self.canman.parse_servo_message(data))\n</code></pre>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.ServoControlMode","title":"<code>ServoControlMode</code>","text":"<p>               Bases: <code>Enum</code></p> <p>TMotor servo control modes</p> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>class ServoControlMode(Enum):\n    \"\"\"TMotor servo control modes\"\"\"\n\n    POSITION = 4\n    VELOCITY = 3\n    CURRENT = 1\n    IDLE = 7\n</code></pre>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.ServoMotorState","title":"<code>ServoMotorState</code>  <code>dataclass</code>","text":"<p>Motor state data structure</p> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>@dataclass\nclass ServoMotorState:\n    \"\"\"Motor state data structure\"\"\"\n\n    position: float = 0.0  # degrees\n    velocity: float = 0.0  # ERPM\n    current: float = 0.0  # amps\n    temperature: float = 0.0  # celsius\n    error: int = 0\n</code></pre>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorServoActuator","title":"<code>TMotorServoActuator</code>","text":"<p>               Bases: <code>ActuatorBase</code></p> <p>TMotor servo mode actuator for AK series motors.</p> Before using this actuator, the CAN interface must be configured: <p>sudo /sbin/ip link set can0 down sudo /sbin/ip link set can0 up type can bitrate 1000000</p> <p>For detailed setup instructions, see docs/tutorials/actuators/tmotor_servo_setup.md</p> Example <p>with TMotorServoActuator(motor_type=\"AK80-9\", motor_id=1) as motor: ...     motor.set_control_mode(CONTROL_MODES.CURRENT) ...     motor.set_output_torque(2.5) ...     motor.update()</p> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>class TMotorServoActuator(ActuatorBase):\n    \"\"\"\n    TMotor servo mode actuator for AK series motors.\n\n    Important: Before using this actuator, the CAN interface must be configured:\n        sudo /sbin/ip link set can0 down\n        sudo /sbin/ip link set can0 up type can bitrate 1000000\n\n    For detailed setup instructions, see docs/tutorials/actuators/tmotor_servo_setup.md\n\n    Example:\n        &gt;&gt;&gt; with TMotorServoActuator(motor_type=\"AK80-9\", motor_id=1) as motor:\n        ...     motor.set_control_mode(CONTROL_MODES.CURRENT)\n        ...     motor.set_output_torque(2.5)\n        ...     motor.update()\n    \"\"\"\n\n    def __init__(\n        self,\n        tag: str = \"TMotorServoActuator\",\n        motor_type: str = \"AK80-9\",\n        motor_id: int = 104,\n        gear_ratio: float = 1.0,\n        frequency: int = 1000,\n        offline: bool = False,\n        max_temperature: float = 80.0,\n        current_mode: str = \"driver\",\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        Initialize TMotor servo actuator\n\n        Args:\n            tag: actuator identifier\n            motor_type: motor model (AK80-9, AK10-9)\n            motor_id: CAN ID\n            gear_ratio: gear ratio\n            frequency: control frequency Hz\n            offline: offline mode\n            max_temperature: maximum temperature\n            current_mode: current convention ('driver', 'amplitude-invariant', 'power-invariant')\n                - 'driver': use driver's native current (default)\n                - 'amplitude-invariant': true phase current convention\n                - 'power-invariant': power-invariant current convention\n        \"\"\"\n        # Validate motor type\n        if motor_type not in TMOTOR_MODELS:\n            raise ValueError(f\"Unsupported motor type: {motor_type}\")\n\n        # Validate current mode\n        if current_mode not in [\"driver\", \"amplitude-invariant\", \"power-invariant\"]:\n            raise ValueError(\n                f\"Invalid current_mode: {current_mode}. Must be 'driver', 'amplitude-invariant', or 'power-invariant'\"\n            )\n\n        super().__init__(\n            tag=tag,\n            gear_ratio=gear_ratio,\n            motor_constants=TMOTOR_SERVO_CONSTANTS,\n            frequency=frequency,\n            offline=offline,\n            **kwargs,\n        )\n\n        # Motor configuration\n        self.motor_type = motor_type\n        self.motor_id = motor_id\n        self.max_temperature = max_temperature\n        self._motor_params = TMOTOR_MODELS[motor_type]\n        self.current_mode = current_mode\n\n        # Current conversion factors\n        # Physical: I_drv (line current) = K * I_user\n        # Code: driver_current = user_current / self._current_scale\n        # So: I_drv = I_user / scale, which means scale = I_user / I_drv = 1 / K\n        # Kt relationship: \u03c4 = Kt_drv * I_drv = Kt_user * I_user\n        # So: Kt_user = Kt_drv * (I_drv / I_user) = Kt_drv * K\n        if current_mode == \"amplitude-invariant\":\n            # I_drv (line) = \u221a3 * I_phase, so scale = I_phase / I_drv = 1/\u221a3\n            # Kt_amp = Kt_drv * \u221a3\n            self._current_scale = 1.0 / np.sqrt(3.0)\n            self._kt_scale = np.sqrt(3.0)\n        elif current_mode == \"power-invariant\":\n            # I_drv (line) = \u221a2 * I_pwr, so scale = I_pwr / I_drv = 1/\u221a2\n            # Kt_pwr = Kt_drv * \u221a2\n            self._current_scale = 1.0 / np.sqrt(2.0)\n            self._kt_scale = np.sqrt(2.0)\n        else:  # driver\n            self._current_scale = 1.0\n            self._kt_scale = 1.0\n\n        # CAN communication\n        self._canman: Optional[CANManagerServo] = None\n        if not self.is_offline:\n            self._canman = CANManagerServo()\n            self._canman.add_motor_listener(self)\n\n        # State management\n        self._motor_state = ServoMotorState()\n        self._motor_state_async = ServoMotorState()\n        self._servo_mode = ServoControlMode.IDLE\n\n        # Error handling\n        self._error_code: Optional[int] = None\n        self._error_message: Optional[str] = None\n\n        # Time management\n        self._start_time = time.time()\n        self._last_update_time = self._start_time\n        self._last_command_time: Optional[float] = None\n\n        # Thermal management\n        self._thermal_model = ThermalModel(\n            motor_constants=self._MOTOR_CONSTANTS,\n            actuator_tag=self.tag,\n        )\n\n        LOGGER.info(f\"Initialized TMotor servo: {self.motor_type} ID:{self.motor_id} (current_mode: {current_mode})\")\n\n    @property\n    def _CONTROL_MODE_CONFIGS(self) -&gt; CONTROL_MODE_CONFIGS:\n        return TMOTOR_SERVO_CONTROL_MODE_CONFIGS\n\n    def device_info_string(self) -&gt; str:\n        return f\"{self.motor_type} ID:{self.motor_id}\"\n\n    @check_actuator_connection\n    def start(self) -&gt; None:\n        \"\"\"Start motor\"\"\"\n        LOGGER.info(f\"Starting {self.device_info_string()}\")\n\n        if not self.is_offline and self._canman:\n            self._canman.power_on(self.motor_id)\n\n            # Poll for motor readiness (max 1 second timeout)\n            start_time = time.time()\n            timeout = 1.0\n            poll_interval = 0.01  # 10ms polling interval\n            motor_ready = False\n\n            while time.time() - start_time &lt; timeout:\n                # The motor should start sending status messages after power on\n                # Check if we've received valid data by checking if position/velocity/current are non-zero\n                # or if the motor_state has been updated (timestamp check could be added)\n                if (\n                    self._motor_state_async.position != 0.0\n                    or self._motor_state_async.velocity != 0.0\n                    or self._motor_state_async.current != 0.0\n                    or self._motor_state_async.temperature &gt; 0.0\n                ):\n                    motor_ready = True\n                    LOGGER.debug(f\"Motor ready after {time.time() - start_time:.3f} seconds\")\n                    break\n                time.sleep(poll_interval)\n\n            if not motor_ready:\n                # Fall back to minimum wait time if no status received\n                LOGGER.warning(\"No status received from motor, using fallback delay\")\n                time.sleep(0.1)  # Minimum wait time\n\n            # Set initial control mode to IDLE\n            self._canman.set_control_mode(self.motor_id, ServoControlMode.IDLE.value)\n\n            # Poll for mode switch confirmation (max 200ms timeout)\n            mode_start_time = time.time()\n            mode_timeout = 0.2\n\n            while time.time() - mode_start_time &lt; mode_timeout:\n                self.update()  # Read status\n                if self._motor_state.error == 0:\n                    LOGGER.debug(f\"Mode switch confirmed after {time.time() - mode_start_time:.3f} seconds\")\n                    break\n                time.sleep(poll_interval)\n\n            # Final status check\n            if self._motor_state.error != 0:\n                raise RuntimeError(f\"Motor startup failed with error: {self._motor_state.error}\")\n\n        self._is_open = True\n        self._is_streaming = True\n\n    @check_actuator_stream\n    @check_actuator_open\n    def stop(self) -&gt; None:\n        \"\"\"Stop motor\"\"\"\n        LOGGER.info(f\"Stopping {self.device_info_string()}\")\n\n        if not self.is_offline and self._canman:\n            self._canman.power_off(self.motor_id)\n\n        self._is_open = False\n        self._is_streaming = False\n\n    def update(self) -&gt; None:\n        \"\"\"Update motor state\"\"\"\n        # Temperature check\n        if self.case_temperature &gt; self.max_temperature:\n            raise RuntimeError(f\"Temperature {self.case_temperature}\u00b0C exceeds limit\")\n\n        # Update state\n        self._motor_state.position = self._motor_state_async.position\n        self._motor_state.velocity = self._motor_state_async.velocity\n        self._motor_state.current = self._motor_state_async.current\n        self._motor_state.temperature = self._motor_state_async.temperature\n        self._motor_state.error = self._motor_state_async.error\n\n        # Communication timeout check\n        now = time.time()\n        if (\n            self._last_command_time is not None\n            and (now - self._last_command_time) &lt; 0.25\n            and (now - self._last_update_time) &gt; 0.1\n        ):\n            warnings.warn(f\"No data from motor: {self.device_info_string()}\", RuntimeWarning, stacklevel=2)\n\n        self._last_update_time = now\n\n    def _update_state_async(self, servo_state: ServoMotorState) -&gt; None:\n        \"\"\"Asynchronously update state\"\"\"\n        # More detailed error handling\n        if servo_state.error != 0:\n            error_codes = TMOTOR_ERROR_CODES\n            error_msg = error_codes.get(servo_state.error, f\"Unknown error code: {servo_state.error}\")\n            self._error_code = servo_state.error\n            self._error_message = error_msg\n\n            # Take different actions based on error type\n            if servo_state.error in [1, 2]:  # Voltage errors\n                LOGGER.error(f\"Voltage error {servo_state.error}: {error_msg}\")\n            elif servo_state.error in [4, 5, 6]:  # Overcurrent or overtemperature\n                LOGGER.critical(f\"Critical error {servo_state.error}: {error_msg}\")\n                # Auto-stop motor\n                if self._canman:\n                    self._canman.set_current(self.motor_id, 0.0)\n            else:\n                LOGGER.warning(f\"Motor error {servo_state.error}: {error_msg}\")\n        else:\n            self._error_code = None\n            self._error_message = None\n\n        self._motor_state_async = servo_state\n\n    @property\n    def error_info(self) -&gt; Optional[tuple[int, str]]:\n        \"\"\"Get error information\"\"\"\n        if self._error_code is not None and self._error_message is not None:\n            return (self._error_code, self._error_message)\n        return None\n\n    def home(\n        self,\n        homing_voltage: int = 0,\n        homing_frequency: Optional[int] = None,\n        homing_direction: int = 0,\n        output_position_offset: float = 0.0,\n        current_threshold: int = 0,\n        velocity_threshold: float = 0.0,\n    ) -&gt; None:\n        \"\"\"Home motor\"\"\"\n        if not self.is_offline and self._canman:\n            self._canman.set_origin(self.motor_id, 1)\n            time.sleep(0.1)\n        self._is_homed = True\n        LOGGER.info(f\"Homed {self.device_info_string()}\")\n\n    # ============ Control Interface ============\n\n    def set_motor_voltage(self, value: float) -&gt; None:\n        \"\"\"Set motor voltage (not directly supported in servo mode)\"\"\"\n        LOGGER.warning(\"Voltage control not supported in servo mode\")\n\n    def set_motor_current(self, value: float) -&gt; None:\n        \"\"\"Set motor current with clamping to motor limits\"\"\"\n        if not self.is_offline and self._canman:\n            # Convert from desired current convention to driver current\n            driver_current = value / self._current_scale\n\n            # Get current limits from motor parameters (these are in driver convention)\n            motor_params = cast(dict[str, Any], self._motor_params)\n            max_current = motor_params[\"Curr_max\"] / 1000.0  # Convert from protocol units to amps\n            min_current = motor_params[\"Curr_min\"] / 1000.0  # Convert from protocol units to amps\n\n            # Clamp current to safe limits\n            clamped_driver_current = np.clip(driver_current, min_current, max_current)\n\n            # Log warning if clamping occurred (show in user's convention)\n            if driver_current != clamped_driver_current:\n                clamped_user_current = clamped_driver_current * self._current_scale\n                LOGGER.warning(\n                    f\"Current command {value:.2f}A clamped to {clamped_user_current:.2f}A \"\n                    f\"(limits: [{min_current * self._current_scale:.1f}, {max_current * self._current_scale:.1f}]A)\"\n                )\n\n            self._canman.set_current(self.motor_id, clamped_driver_current)\n            self._last_command_time = time.time()\n\n    def set_motor_position(self, value: float) -&gt; None:\n        \"\"\"Set motor position (radians) with clamping to motor limits\"\"\"\n        position_deg = radians_to_degrees(value)\n\n        if not self.is_offline and self._canman:\n            # Get position limits from motor parameters\n            motor_params = cast(dict[str, Any], self._motor_params)\n            max_position = motor_params[\"P_max\"] / 10.0  # Convert from protocol units to degrees\n            min_position = motor_params[\"P_min\"] / 10.0  # Convert from protocol units to degrees\n\n            # Clamp position to safe limits\n            clamped_position = np.clip(position_deg, min_position, max_position)\n\n            # Log warning if clamping occurred\n            if position_deg != clamped_position:\n                LOGGER.warning(\n                    f\"Position command {position_deg:.1f}\u00b0 clamped to {clamped_position:.1f}\u00b0 \"\n                    f\"(limits: [{min_position:.0f}, {max_position:.0f}]\u00b0)\"\n                )\n\n            self._canman.set_position(self.motor_id, clamped_position)\n            self._last_command_time = time.time()\n\n    def set_motor_torque(self, value: float) -&gt; None:\n        \"\"\"Set motor torque (Nm) - core functionality as requested by user\"\"\"\n        # Torque to current: T = I * Kt\n        # Kt_user = Kt_drv * kt_scale\n        kt_user = self._motor_params[\"Kt_actual\"] * self._kt_scale\n        current = value / kt_user\n        self.set_motor_current(current)\n\n    def set_output_torque(self, value: float) -&gt; None:\n        \"\"\"Set output torque (Nm) - core functionality as requested by user\"\"\"\n        # Output torque to motor torque: T_motor = T_output * gear_ratio\n        motor_torque = value * self.gear_ratio\n        self.set_motor_torque(motor_torque)\n\n    def set_motor_velocity(self, value: float) -&gt; None:\n        \"\"\"Set motor velocity (rad/s) with clamping to motor limits\"\"\"\n        motor_params = cast(dict[str, Any], self._motor_params)\n        velocity_erpm = rad_per_sec_to_erpm(value, self.num_pole_pairs)\n\n        if not self.is_offline and self._canman:\n            # Get velocity limits from motor parameters\n            max_velocity = motor_params[\"V_max\"]  # Already in ERPM\n            min_velocity = motor_params[\"V_min\"]  # Already in ERPM\n\n            # Clamp velocity to safe limits\n            clamped_velocity = np.clip(velocity_erpm, min_velocity, max_velocity)\n\n            # Log warning if clamping occurred\n            if velocity_erpm != clamped_velocity:\n                LOGGER.warning(\n                    f\"Velocity command {velocity_erpm:.0f} ERPM clamped to {clamped_velocity:.0f} ERPM \"\n                    f\"(limits: [{min_velocity}, {max_velocity}] ERPM)\"\n                )\n\n            self._canman.set_velocity(self.motor_id, clamped_velocity)\n            self._last_command_time = time.time()\n\n    def set_motor_impedance(self, position: float, velocity: float, kp: float, kd: float, torque_ff: float) -&gt; None:\n        \"\"\"TMotor servo mode does not support impedance control\"\"\"\n        LOGGER.error(\n            \"TMotor servo mode does not support impedance control. \"\n            \"Use position, velocity, or current control modes instead.\"\n        )\n        raise NotImplementedError(\"TMotor servo mode does not support impedance control.\")\n\n    def set_output_impedance(self, position: float, velocity: float, kp: float, kd: float, torque_ff: float) -&gt; None:\n        \"\"\"TMotor servo mode does not support impedance control\"\"\"\n        LOGGER.error(\n            \"TMotor servo mode does not support impedance control. \"\n            \"Use position, velocity, or current control modes instead.\"\n        )\n        raise NotImplementedError(\"TMotor servo mode does not support impedance control.\")\n\n    def set_output_velocity(self, value: float) -&gt; None:\n        \"\"\"Set output velocity (rad/s)\"\"\"\n        motor_velocity = value * self.gear_ratio\n        self.set_motor_velocity(motor_velocity)\n\n    # ============ Unsupported PID Functions - TMotor Servo Mode Handles All Control Loops Internally ============\n\n    def set_current_gains(self, kp: float, ki: float, kd: float, ff: float) -&gt; None:\n        \"\"\"TMotor servo mode does not support external current PID gains - motor handles current control internally\"\"\"\n        LOGGER.debug(\n            \"TMotor servo mode handles current control internally. \" \"External current PID gains are not used.\"\n        )\n        # Motor handles current control internally, no action needed\n\n    def set_position_gains(self, kp: float, ki: float, kd: float, ff: float) -&gt; None:\n        \"\"\"TMotor servo mode does not support external position PID gains - motor handles position control internally\"\"\"\n        LOGGER.debug(\n            \"TMotor servo mode handles position control internally. \" \"External position PID gains are not used.\"\n        )\n        # Motor handles position control internally, no action needed\n\n    def set_impedance_gains(self, kp: float, ki: float, kd: float, k: float, b: float, ff: float) -&gt; None:\n        \"\"\"TMotor servo mode does not support impedance control\"\"\"\n        LOGGER.debug(\n            \"TMotor servo mode does not support impedance control. \"\n            \"Use position, velocity, or current control modes instead.\"\n        )\n        # Impedance control not supported in servo mode, no action needed\n\n    def _set_impedance_gains(self, k: float, b: float) -&gt; None:\n        \"\"\"Internal method for impedance gains - not supported in TMotor servo mode\"\"\"\n        LOGGER.debug(\"TMotor servo mode handles control internally. \" \"Impedance gains are not used.\")\n        # Motor handles control internally, no action needed\n\n    # ============ State Properties ============\n\n    @property\n    def motor_position(self) -&gt; float:\n        \"\"\"Motor position (radians)\"\"\"\n        return degrees_to_radians(self._motor_state.position)\n\n    @property\n    def output_position(self) -&gt; float:\n        \"\"\"Output position (radians)\"\"\"\n        return self.motor_position / self.gear_ratio\n\n    @property\n    def motor_velocity(self) -&gt; float:\n        \"\"\"Motor velocity (rad/s)\"\"\"\n        return erpm_to_rad_per_sec(self._motor_state.velocity, self.num_pole_pairs)\n\n    @property\n    def output_velocity(self) -&gt; float:\n        \"\"\"Output velocity (rad/s)\"\"\"\n        return self.motor_velocity / self.gear_ratio\n\n    @property\n    def num_pole_pairs(self) -&gt; int:\n        \"\"\"Number of motor pole pairs\"\"\"\n        motor_params = cast(dict[str, Any], self._motor_params)\n        return motor_params[\"NUM_POLE_PAIRS\"]\n\n    @property\n    def motor_voltage(self) -&gt; float:\n        \"\"\"Motor voltage - not available in servo mode\"\"\"\n        raise NotImplementedError(\n            \"Motor voltage reading is not available in TMotor servo mode. \"\n            \"The motor does not provide voltage feedback through the CAN protocol.\"\n        )\n\n    @property\n    def motor_current(self) -&gt; float:\n        \"\"\"Motor current (A) - converted to selected current convention\"\"\"\n        return self._motor_state.current * self._current_scale\n\n    @property\n    def motor_torque(self) -&gt; float:\n        \"\"\"Motor torque (Nm)\"\"\"\n        motor_params = cast(dict[str, Any], self._motor_params)\n        kt_user = cast(float, motor_params[\"Kt_actual\"]) * self._kt_scale\n        return self.motor_current * kt_user\n\n    @property\n    def output_torque(self) -&gt; float:\n        \"\"\"Output torque (Nm)\"\"\"\n        return self.motor_torque / self.gear_ratio\n\n    @property\n    def case_temperature(self) -&gt; float:\n        \"\"\"Case temperature (\u00b0C)\"\"\"\n        return self._motor_state.temperature\n\n    @property\n    def winding_temperature(self) -&gt; float:\n        \"\"\"Winding temperature (\u00b0C)\"\"\"\n        return cast(float, getattr(self._thermal_model, \"T_w\", self.case_temperature))\n\n    def __str__(self) -&gt; str:\n        \"\"\"State string\"\"\"\n        return (\n            f\"{self.device_info_string()} | \"\n            f\"Pos: {self.output_position:.3f}rad | \"\n            f\"Vel: {self.output_velocity:.3f}rad/s | \"\n            f\"Torque: {self.output_torque:.3f}Nm | \"\n            f\"Current: {self.motor_current:.3f}A | \"\n            f\"Temp: {self.case_temperature:.1f}\u00b0C\"\n        )\n</code></pre>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorServoActuator.case_temperature","title":"<code>case_temperature</code>  <code>property</code>","text":"<p>Case temperature (\u00b0C)</p>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorServoActuator.error_info","title":"<code>error_info</code>  <code>property</code>","text":"<p>Get error information</p>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorServoActuator.motor_current","title":"<code>motor_current</code>  <code>property</code>","text":"<p>Motor current (A) - converted to selected current convention</p>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorServoActuator.motor_position","title":"<code>motor_position</code>  <code>property</code>","text":"<p>Motor position (radians)</p>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorServoActuator.motor_torque","title":"<code>motor_torque</code>  <code>property</code>","text":"<p>Motor torque (Nm)</p>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorServoActuator.motor_velocity","title":"<code>motor_velocity</code>  <code>property</code>","text":"<p>Motor velocity (rad/s)</p>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorServoActuator.motor_voltage","title":"<code>motor_voltage</code>  <code>property</code>","text":"<p>Motor voltage - not available in servo mode</p>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorServoActuator.num_pole_pairs","title":"<code>num_pole_pairs</code>  <code>property</code>","text":"<p>Number of motor pole pairs</p>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorServoActuator.output_position","title":"<code>output_position</code>  <code>property</code>","text":"<p>Output position (radians)</p>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorServoActuator.output_torque","title":"<code>output_torque</code>  <code>property</code>","text":"<p>Output torque (Nm)</p>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorServoActuator.output_velocity","title":"<code>output_velocity</code>  <code>property</code>","text":"<p>Output velocity (rad/s)</p>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorServoActuator.winding_temperature","title":"<code>winding_temperature</code>  <code>property</code>","text":"<p>Winding temperature (\u00b0C)</p>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorServoActuator.__init__","title":"<code>__init__(tag='TMotorServoActuator', motor_type='AK80-9', motor_id=104, gear_ratio=1.0, frequency=1000, offline=False, max_temperature=80.0, current_mode='driver', **kwargs)</code>","text":"<p>Initialize TMotor servo actuator</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>actuator identifier</p> <code>'TMotorServoActuator'</code> <code>motor_type</code> <code>str</code> <p>motor model (AK80-9, AK10-9)</p> <code>'AK80-9'</code> <code>motor_id</code> <code>int</code> <p>CAN ID</p> <code>104</code> <code>gear_ratio</code> <code>float</code> <p>gear ratio</p> <code>1.0</code> <code>frequency</code> <code>int</code> <p>control frequency Hz</p> <code>1000</code> <code>offline</code> <code>bool</code> <p>offline mode</p> <code>False</code> <code>max_temperature</code> <code>float</code> <p>maximum temperature</p> <code>80.0</code> <code>current_mode</code> <code>str</code> <p>current convention ('driver', 'amplitude-invariant', 'power-invariant') - 'driver': use driver's native current (default) - 'amplitude-invariant': true phase current convention - 'power-invariant': power-invariant current convention</p> <code>'driver'</code> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>def __init__(\n    self,\n    tag: str = \"TMotorServoActuator\",\n    motor_type: str = \"AK80-9\",\n    motor_id: int = 104,\n    gear_ratio: float = 1.0,\n    frequency: int = 1000,\n    offline: bool = False,\n    max_temperature: float = 80.0,\n    current_mode: str = \"driver\",\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Initialize TMotor servo actuator\n\n    Args:\n        tag: actuator identifier\n        motor_type: motor model (AK80-9, AK10-9)\n        motor_id: CAN ID\n        gear_ratio: gear ratio\n        frequency: control frequency Hz\n        offline: offline mode\n        max_temperature: maximum temperature\n        current_mode: current convention ('driver', 'amplitude-invariant', 'power-invariant')\n            - 'driver': use driver's native current (default)\n            - 'amplitude-invariant': true phase current convention\n            - 'power-invariant': power-invariant current convention\n    \"\"\"\n    # Validate motor type\n    if motor_type not in TMOTOR_MODELS:\n        raise ValueError(f\"Unsupported motor type: {motor_type}\")\n\n    # Validate current mode\n    if current_mode not in [\"driver\", \"amplitude-invariant\", \"power-invariant\"]:\n        raise ValueError(\n            f\"Invalid current_mode: {current_mode}. Must be 'driver', 'amplitude-invariant', or 'power-invariant'\"\n        )\n\n    super().__init__(\n        tag=tag,\n        gear_ratio=gear_ratio,\n        motor_constants=TMOTOR_SERVO_CONSTANTS,\n        frequency=frequency,\n        offline=offline,\n        **kwargs,\n    )\n\n    # Motor configuration\n    self.motor_type = motor_type\n    self.motor_id = motor_id\n    self.max_temperature = max_temperature\n    self._motor_params = TMOTOR_MODELS[motor_type]\n    self.current_mode = current_mode\n\n    # Current conversion factors\n    # Physical: I_drv (line current) = K * I_user\n    # Code: driver_current = user_current / self._current_scale\n    # So: I_drv = I_user / scale, which means scale = I_user / I_drv = 1 / K\n    # Kt relationship: \u03c4 = Kt_drv * I_drv = Kt_user * I_user\n    # So: Kt_user = Kt_drv * (I_drv / I_user) = Kt_drv * K\n    if current_mode == \"amplitude-invariant\":\n        # I_drv (line) = \u221a3 * I_phase, so scale = I_phase / I_drv = 1/\u221a3\n        # Kt_amp = Kt_drv * \u221a3\n        self._current_scale = 1.0 / np.sqrt(3.0)\n        self._kt_scale = np.sqrt(3.0)\n    elif current_mode == \"power-invariant\":\n        # I_drv (line) = \u221a2 * I_pwr, so scale = I_pwr / I_drv = 1/\u221a2\n        # Kt_pwr = Kt_drv * \u221a2\n        self._current_scale = 1.0 / np.sqrt(2.0)\n        self._kt_scale = np.sqrt(2.0)\n    else:  # driver\n        self._current_scale = 1.0\n        self._kt_scale = 1.0\n\n    # CAN communication\n    self._canman: Optional[CANManagerServo] = None\n    if not self.is_offline:\n        self._canman = CANManagerServo()\n        self._canman.add_motor_listener(self)\n\n    # State management\n    self._motor_state = ServoMotorState()\n    self._motor_state_async = ServoMotorState()\n    self._servo_mode = ServoControlMode.IDLE\n\n    # Error handling\n    self._error_code: Optional[int] = None\n    self._error_message: Optional[str] = None\n\n    # Time management\n    self._start_time = time.time()\n    self._last_update_time = self._start_time\n    self._last_command_time: Optional[float] = None\n\n    # Thermal management\n    self._thermal_model = ThermalModel(\n        motor_constants=self._MOTOR_CONSTANTS,\n        actuator_tag=self.tag,\n    )\n\n    LOGGER.info(f\"Initialized TMotor servo: {self.motor_type} ID:{self.motor_id} (current_mode: {current_mode})\")\n</code></pre>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorServoActuator.__str__","title":"<code>__str__()</code>","text":"<p>State string</p> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"State string\"\"\"\n    return (\n        f\"{self.device_info_string()} | \"\n        f\"Pos: {self.output_position:.3f}rad | \"\n        f\"Vel: {self.output_velocity:.3f}rad/s | \"\n        f\"Torque: {self.output_torque:.3f}Nm | \"\n        f\"Current: {self.motor_current:.3f}A | \"\n        f\"Temp: {self.case_temperature:.1f}\u00b0C\"\n    )\n</code></pre>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorServoActuator.home","title":"<code>home(homing_voltage=0, homing_frequency=None, homing_direction=0, output_position_offset=0.0, current_threshold=0, velocity_threshold=0.0)</code>","text":"<p>Home motor</p> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>def home(\n    self,\n    homing_voltage: int = 0,\n    homing_frequency: Optional[int] = None,\n    homing_direction: int = 0,\n    output_position_offset: float = 0.0,\n    current_threshold: int = 0,\n    velocity_threshold: float = 0.0,\n) -&gt; None:\n    \"\"\"Home motor\"\"\"\n    if not self.is_offline and self._canman:\n        self._canman.set_origin(self.motor_id, 1)\n        time.sleep(0.1)\n    self._is_homed = True\n    LOGGER.info(f\"Homed {self.device_info_string()}\")\n</code></pre>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorServoActuator.set_current_gains","title":"<code>set_current_gains(kp, ki, kd, ff)</code>","text":"<p>TMotor servo mode does not support external current PID gains - motor handles current control internally</p> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>def set_current_gains(self, kp: float, ki: float, kd: float, ff: float) -&gt; None:\n    \"\"\"TMotor servo mode does not support external current PID gains - motor handles current control internally\"\"\"\n    LOGGER.debug(\n        \"TMotor servo mode handles current control internally. \" \"External current PID gains are not used.\"\n    )\n</code></pre>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorServoActuator.set_impedance_gains","title":"<code>set_impedance_gains(kp, ki, kd, k, b, ff)</code>","text":"<p>TMotor servo mode does not support impedance control</p> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>def set_impedance_gains(self, kp: float, ki: float, kd: float, k: float, b: float, ff: float) -&gt; None:\n    \"\"\"TMotor servo mode does not support impedance control\"\"\"\n    LOGGER.debug(\n        \"TMotor servo mode does not support impedance control. \"\n        \"Use position, velocity, or current control modes instead.\"\n    )\n</code></pre>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorServoActuator.set_motor_current","title":"<code>set_motor_current(value)</code>","text":"<p>Set motor current with clamping to motor limits</p> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>def set_motor_current(self, value: float) -&gt; None:\n    \"\"\"Set motor current with clamping to motor limits\"\"\"\n    if not self.is_offline and self._canman:\n        # Convert from desired current convention to driver current\n        driver_current = value / self._current_scale\n\n        # Get current limits from motor parameters (these are in driver convention)\n        motor_params = cast(dict[str, Any], self._motor_params)\n        max_current = motor_params[\"Curr_max\"] / 1000.0  # Convert from protocol units to amps\n        min_current = motor_params[\"Curr_min\"] / 1000.0  # Convert from protocol units to amps\n\n        # Clamp current to safe limits\n        clamped_driver_current = np.clip(driver_current, min_current, max_current)\n\n        # Log warning if clamping occurred (show in user's convention)\n        if driver_current != clamped_driver_current:\n            clamped_user_current = clamped_driver_current * self._current_scale\n            LOGGER.warning(\n                f\"Current command {value:.2f}A clamped to {clamped_user_current:.2f}A \"\n                f\"(limits: [{min_current * self._current_scale:.1f}, {max_current * self._current_scale:.1f}]A)\"\n            )\n\n        self._canman.set_current(self.motor_id, clamped_driver_current)\n        self._last_command_time = time.time()\n</code></pre>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorServoActuator.set_motor_impedance","title":"<code>set_motor_impedance(position, velocity, kp, kd, torque_ff)</code>","text":"<p>TMotor servo mode does not support impedance control</p> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>def set_motor_impedance(self, position: float, velocity: float, kp: float, kd: float, torque_ff: float) -&gt; None:\n    \"\"\"TMotor servo mode does not support impedance control\"\"\"\n    LOGGER.error(\n        \"TMotor servo mode does not support impedance control. \"\n        \"Use position, velocity, or current control modes instead.\"\n    )\n    raise NotImplementedError(\"TMotor servo mode does not support impedance control.\")\n</code></pre>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorServoActuator.set_motor_position","title":"<code>set_motor_position(value)</code>","text":"<p>Set motor position (radians) with clamping to motor limits</p> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>def set_motor_position(self, value: float) -&gt; None:\n    \"\"\"Set motor position (radians) with clamping to motor limits\"\"\"\n    position_deg = radians_to_degrees(value)\n\n    if not self.is_offline and self._canman:\n        # Get position limits from motor parameters\n        motor_params = cast(dict[str, Any], self._motor_params)\n        max_position = motor_params[\"P_max\"] / 10.0  # Convert from protocol units to degrees\n        min_position = motor_params[\"P_min\"] / 10.0  # Convert from protocol units to degrees\n\n        # Clamp position to safe limits\n        clamped_position = np.clip(position_deg, min_position, max_position)\n\n        # Log warning if clamping occurred\n        if position_deg != clamped_position:\n            LOGGER.warning(\n                f\"Position command {position_deg:.1f}\u00b0 clamped to {clamped_position:.1f}\u00b0 \"\n                f\"(limits: [{min_position:.0f}, {max_position:.0f}]\u00b0)\"\n            )\n\n        self._canman.set_position(self.motor_id, clamped_position)\n        self._last_command_time = time.time()\n</code></pre>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorServoActuator.set_motor_torque","title":"<code>set_motor_torque(value)</code>","text":"<p>Set motor torque (Nm) - core functionality as requested by user</p> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>def set_motor_torque(self, value: float) -&gt; None:\n    \"\"\"Set motor torque (Nm) - core functionality as requested by user\"\"\"\n    # Torque to current: T = I * Kt\n    # Kt_user = Kt_drv * kt_scale\n    kt_user = self._motor_params[\"Kt_actual\"] * self._kt_scale\n    current = value / kt_user\n    self.set_motor_current(current)\n</code></pre>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorServoActuator.set_motor_velocity","title":"<code>set_motor_velocity(value)</code>","text":"<p>Set motor velocity (rad/s) with clamping to motor limits</p> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>def set_motor_velocity(self, value: float) -&gt; None:\n    \"\"\"Set motor velocity (rad/s) with clamping to motor limits\"\"\"\n    motor_params = cast(dict[str, Any], self._motor_params)\n    velocity_erpm = rad_per_sec_to_erpm(value, self.num_pole_pairs)\n\n    if not self.is_offline and self._canman:\n        # Get velocity limits from motor parameters\n        max_velocity = motor_params[\"V_max\"]  # Already in ERPM\n        min_velocity = motor_params[\"V_min\"]  # Already in ERPM\n\n        # Clamp velocity to safe limits\n        clamped_velocity = np.clip(velocity_erpm, min_velocity, max_velocity)\n\n        # Log warning if clamping occurred\n        if velocity_erpm != clamped_velocity:\n            LOGGER.warning(\n                f\"Velocity command {velocity_erpm:.0f} ERPM clamped to {clamped_velocity:.0f} ERPM \"\n                f\"(limits: [{min_velocity}, {max_velocity}] ERPM)\"\n            )\n\n        self._canman.set_velocity(self.motor_id, clamped_velocity)\n        self._last_command_time = time.time()\n</code></pre>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorServoActuator.set_motor_voltage","title":"<code>set_motor_voltage(value)</code>","text":"<p>Set motor voltage (not directly supported in servo mode)</p> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>def set_motor_voltage(self, value: float) -&gt; None:\n    \"\"\"Set motor voltage (not directly supported in servo mode)\"\"\"\n    LOGGER.warning(\"Voltage control not supported in servo mode\")\n</code></pre>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorServoActuator.set_output_impedance","title":"<code>set_output_impedance(position, velocity, kp, kd, torque_ff)</code>","text":"<p>TMotor servo mode does not support impedance control</p> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>def set_output_impedance(self, position: float, velocity: float, kp: float, kd: float, torque_ff: float) -&gt; None:\n    \"\"\"TMotor servo mode does not support impedance control\"\"\"\n    LOGGER.error(\n        \"TMotor servo mode does not support impedance control. \"\n        \"Use position, velocity, or current control modes instead.\"\n    )\n    raise NotImplementedError(\"TMotor servo mode does not support impedance control.\")\n</code></pre>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorServoActuator.set_output_torque","title":"<code>set_output_torque(value)</code>","text":"<p>Set output torque (Nm) - core functionality as requested by user</p> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>def set_output_torque(self, value: float) -&gt; None:\n    \"\"\"Set output torque (Nm) - core functionality as requested by user\"\"\"\n    # Output torque to motor torque: T_motor = T_output * gear_ratio\n    motor_torque = value * self.gear_ratio\n    self.set_motor_torque(motor_torque)\n</code></pre>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorServoActuator.set_output_velocity","title":"<code>set_output_velocity(value)</code>","text":"<p>Set output velocity (rad/s)</p> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>def set_output_velocity(self, value: float) -&gt; None:\n    \"\"\"Set output velocity (rad/s)\"\"\"\n    motor_velocity = value * self.gear_ratio\n    self.set_motor_velocity(motor_velocity)\n</code></pre>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorServoActuator.set_position_gains","title":"<code>set_position_gains(kp, ki, kd, ff)</code>","text":"<p>TMotor servo mode does not support external position PID gains - motor handles position control internally</p> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>def set_position_gains(self, kp: float, ki: float, kd: float, ff: float) -&gt; None:\n    \"\"\"TMotor servo mode does not support external position PID gains - motor handles position control internally\"\"\"\n    LOGGER.debug(\n        \"TMotor servo mode handles position control internally. \" \"External position PID gains are not used.\"\n    )\n</code></pre>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorServoActuator.start","title":"<code>start()</code>","text":"<p>Start motor</p> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>@check_actuator_connection\ndef start(self) -&gt; None:\n    \"\"\"Start motor\"\"\"\n    LOGGER.info(f\"Starting {self.device_info_string()}\")\n\n    if not self.is_offline and self._canman:\n        self._canman.power_on(self.motor_id)\n\n        # Poll for motor readiness (max 1 second timeout)\n        start_time = time.time()\n        timeout = 1.0\n        poll_interval = 0.01  # 10ms polling interval\n        motor_ready = False\n\n        while time.time() - start_time &lt; timeout:\n            # The motor should start sending status messages after power on\n            # Check if we've received valid data by checking if position/velocity/current are non-zero\n            # or if the motor_state has been updated (timestamp check could be added)\n            if (\n                self._motor_state_async.position != 0.0\n                or self._motor_state_async.velocity != 0.0\n                or self._motor_state_async.current != 0.0\n                or self._motor_state_async.temperature &gt; 0.0\n            ):\n                motor_ready = True\n                LOGGER.debug(f\"Motor ready after {time.time() - start_time:.3f} seconds\")\n                break\n            time.sleep(poll_interval)\n\n        if not motor_ready:\n            # Fall back to minimum wait time if no status received\n            LOGGER.warning(\"No status received from motor, using fallback delay\")\n            time.sleep(0.1)  # Minimum wait time\n\n        # Set initial control mode to IDLE\n        self._canman.set_control_mode(self.motor_id, ServoControlMode.IDLE.value)\n\n        # Poll for mode switch confirmation (max 200ms timeout)\n        mode_start_time = time.time()\n        mode_timeout = 0.2\n\n        while time.time() - mode_start_time &lt; mode_timeout:\n            self.update()  # Read status\n            if self._motor_state.error == 0:\n                LOGGER.debug(f\"Mode switch confirmed after {time.time() - mode_start_time:.3f} seconds\")\n                break\n            time.sleep(poll_interval)\n\n        # Final status check\n        if self._motor_state.error != 0:\n            raise RuntimeError(f\"Motor startup failed with error: {self._motor_state.error}\")\n\n    self._is_open = True\n    self._is_streaming = True\n</code></pre>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorServoActuator.stop","title":"<code>stop()</code>","text":"<p>Stop motor</p> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>@check_actuator_stream\n@check_actuator_open\ndef stop(self) -&gt; None:\n    \"\"\"Stop motor\"\"\"\n    LOGGER.info(f\"Stopping {self.device_info_string()}\")\n\n    if not self.is_offline and self._canman:\n        self._canman.power_off(self.motor_id)\n\n    self._is_open = False\n    self._is_streaming = False\n</code></pre>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.TMotorServoActuator.update","title":"<code>update()</code>","text":"<p>Update motor state</p> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>def update(self) -&gt; None:\n    \"\"\"Update motor state\"\"\"\n    # Temperature check\n    if self.case_temperature &gt; self.max_temperature:\n        raise RuntimeError(f\"Temperature {self.case_temperature}\u00b0C exceeds limit\")\n\n    # Update state\n    self._motor_state.position = self._motor_state_async.position\n    self._motor_state.velocity = self._motor_state_async.velocity\n    self._motor_state.current = self._motor_state_async.current\n    self._motor_state.temperature = self._motor_state_async.temperature\n    self._motor_state.error = self._motor_state_async.error\n\n    # Communication timeout check\n    now = time.time()\n    if (\n        self._last_command_time is not None\n        and (now - self._last_command_time) &lt; 0.25\n        and (now - self._last_update_time) &gt; 0.1\n    ):\n        warnings.warn(f\"No data from motor: {self.device_info_string()}\", RuntimeWarning, stacklevel=2)\n\n    self._last_update_time = now\n</code></pre>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.degrees_to_radians","title":"<code>degrees_to_radians(degrees)</code>","text":"<p>Convert degrees to radians</p> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>def degrees_to_radians(degrees: float) -&gt; float:\n    \"\"\"Convert degrees to radians\"\"\"\n    return degrees * np.pi / 180.0\n</code></pre>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.erpm_to_rad_per_sec","title":"<code>erpm_to_rad_per_sec(erpm, num_pole_pairs)</code>","text":"<p>Convert ERPM to rad/s</p> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>def erpm_to_rad_per_sec(erpm: float, num_pole_pairs: int) -&gt; float:\n    \"\"\"Convert ERPM to rad/s\"\"\"\n    return erpm * 2 * np.pi / (60 * num_pole_pairs)\n</code></pre>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.rad_per_sec_to_erpm","title":"<code>rad_per_sec_to_erpm(rad_per_sec, num_pole_pairs)</code>","text":"<p>Convert rad/s to ERPM</p> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>def rad_per_sec_to_erpm(rad_per_sec: float, num_pole_pairs: int) -&gt; float:\n    \"\"\"Convert rad/s to ERPM\"\"\"\n    return rad_per_sec * 60 * num_pole_pairs / (2 * np.pi)\n</code></pre>"},{"location":"api/actuators/tmotor/#opensourceleg.actuators.tmotor.radians_to_degrees","title":"<code>radians_to_degrees(radians)</code>","text":"<p>Convert radians to degrees</p> Source code in <code>opensourceleg/actuators/tmotor.py</code> <pre><code>def radians_to_degrees(radians: float) -&gt; float:\n    \"\"\"Convert radians to degrees\"\"\"\n    return radians * 180.0 / np.pi\n</code></pre>"},{"location":"api/control/compiled/","title":"Compiled Controller","text":""},{"location":"api/control/compiled/#opensourceleg.control.compiled.CompiledController","title":"<code>CompiledController</code>","text":"<p>Controller class to handle using compiled controllers. This class expects that your function has the form: myFunction(inputs, outputs) where inputs is a pointer to an inputs structure and outputs is a pointer to an outputs structure. You can define these input and output structures however you please. See examples folder of repo for examples.</p> <p>Parameters:</p> Name Type Description Default <code>library_name</code> <code>string</code> <p>The name of the compiled library file, without the *.so</p> required <code>library_path</code> <code>string</code> <p>The path to the directory containing the library. See examples for how to get working directory of parent script.</p> required <code>main_function_name</code> <code>string</code> <p>Name of the main function to call within the library. This is the function that will get called via the run() method initialization_function_name (string): Name of an initialization function for your library. This gets called only once when the library is loaded. If you don't have an initialization function, pass None.</p> required <code>cleanup_function_name</code> <code>string</code> <p>Name of a cleanup function for your library. This gets called when the CompiledController class has gone out of scope and is garbage collected. Again, pass None if you don't need this functionality.</p> <code>None</code> Authors <p>Kevin Best, Senthur Raj Ayyappan Neurobionics Lab Robotics Department University of Michigan October 2023</p> Source code in <code>opensourceleg/control/compiled.py</code> <pre><code>class CompiledController:\n    \"\"\"\n    Controller class to handle using compiled controllers.\n    This class expects that your function has the form: myFunction(*inputs, *outputs)\n    where *inputs is a pointer to an inputs structure and\n    *outputs is a pointer to an outputs structure.\n    You can define these input and output structures however you please.\n    See examples folder of repo for examples.\n\n    Args:\n        library_name (string): The name of the compiled library file, without the *.so\n        library_path (string): The path to the directory containing the library.\n            See examples for how to get working directory of parent script.\n        main_function_name (string): Name of the main function to call within the library.\n            This is the function that will get called via the run() method initialization_function_name (string): Name\n            of an initialization function for your library. This gets called only once when the library is loaded. If\n            you don't have an initialization function, pass None.\n        cleanup_function_name (string): Name of a cleanup function for your library.\n            This gets called when the CompiledController class has gone out of scope and is garbage collected.\n            Again, pass None if you don't need this functionality.\n\n    Authors:\n        Kevin Best, Senthur Raj Ayyappan\n        Neurobionics Lab\n        Robotics Department\n        University of Michigan\n        October 2023\n    \"\"\"\n\n    def __init__(\n        self,\n        library_name: str,\n        library_path: str,\n        main_function_name: str,\n        initialization_function_name: Optional[str] = None,\n        cleanup_function_name: Optional[str] = None,\n    ) -&gt; None:\n        self.lib: Any = ctl.load_library(library_name, library_path)\n        self.cleanup_func: Callable = self._load_function(cleanup_function_name)\n        self.main_function: Callable = self._load_function(main_function_name)\n        self.init_function: Callable = self._load_function(initialization_function_name)\n        # Note if requested function name is None, returned handle is also none\n\n        if self.init_function is not None:\n            self.init_function()\n\n        # This alias makes defining types from top script easier without second import\n        self.types = ctypes\n\n        self.DEFAULT_SENSOR_LIST = [\n            (\"knee_angle\", self.types.c_double),\n            (\"ankle_angle\", self.types.c_double),\n            (\"knee_velocity\", self.types.c_double),\n            (\"ankle_velocity\", self.types.c_double),\n            (\"Fz\", self.types.c_double),\n        ]\n\n        self._input_type: Optional[type[ctypes.Structure]] = None\n        self.inputs: Optional[ctypes.Structure] = None\n        self._output_type: Optional[type[ctypes.Structure]] = None\n        self.outputs: Optional[ctypes.Structure] = None\n\n    def __del__(self) -&gt; None:\n        if hasattr(self, \"cleanup_func\") and self.cleanup_func is not None:\n            self.cleanup_func()\n\n    def __repr__(self) -&gt; str:\n        return \"CompiledController\"\n\n    def _load_function(self, function_name: Optional[str]) -&gt; Any:\n        if function_name is None:\n            return None\n        else:\n            try:\n                function_handle = getattr(self.lib, function_name)\n            except AttributeError:\n                LOGGER.warning(f\"Function {function_name} not found in library {self.lib}\")\n            return function_handle\n\n    def _register_type(self, name: str, typ: type[ctypes.Structure]) -&gt; None:\n        \"\"\"Register a ctypes Structure type on the `types` namespace.\n\n        Use setattr to avoid static attribute checks on the underlying module object.\n        \"\"\"\n        setattr(self.types, name, typ)\n\n    def define_inputs(\n        self, input_list: list[Any] | None = None, input_type: type[ctypes.Structure] | None = None\n    ) -&gt; None:\n        \"\"\"\n        This method defines the input structure to your function.\n        Provide either and input_list or an input_type.\n        See example folder and tutorials for help on using this method.\n\n        Parameters\n        -----------\n        input_list: A list of [('field_name', field_type)...] defining the input structure.\n            Use this when you want to define a new ctypes type to use as the input.\n            field_name is a string you choose as the title of the field.\n            field_type is a type either given by a native c_types value or\n                a custom type defined via the define_type() method.\n                All types can be accessed as CompiledController.types.(type_name)\n        input_type: A ctypes.Structure class reference to use directly as the input type.\n            Use this if you have a ctype object already defined.\n\n        Raises\n        ------\n        ValueError: If both input_list and input_type are provided, or if neither is provided.\n        \"\"\"\n        if input_type is not None and input_list is not None:\n            raise ValueError(\"Only one of input_list or input_type should be provided.\")\n        elif input_type is not None:\n            self._input_type = input_type\n            self._register_type(\"inputs\", input_type)\n        elif input_list is not None:\n            self._input_type = self.define_type(\"inputs\", input_list)\n        else:\n            raise ValueError(\"Must provide either input_list or input_type.\")\n\n        if self._input_type is None:\n            raise ValueError(\"Input type not defined properly. Check define_type() method.\")\n\n        self.inputs = self._input_type()\n\n    def define_outputs(\n        self, output_list: list[Any] | None = None, output_type: type[ctypes.Structure] | None = None\n    ) -&gt; None:\n        \"\"\"\n        This method defines the output structure to your function.\n        Provide either an output_list or an output_type.\n        See example folder and tutorials for help on using this method.\n\n        Parameters\n        -----------\n        output_list: A list of [('field_name', field_type)...] defining the output structure.\n            field_name is a string you choose as the title of the field.\n            field_type is a type either given by a native c_types value or\n                a custom type defined via the define_type() method.\n                All types can be accessed as CompiledController.types.(type_name)\n        output_type: A ctypes.Structure class reference to use directly as the output type.\n            Use this if you have a ctype object already defined somewhere.\n\n        Raises\n        ------\n        ValueError: If both output_list and output_type are provided, or if neither is provided.\n        \"\"\"\n        if output_type is not None and output_list is not None:\n            raise ValueError(\"Only one of output_list or output_type should be provided.\")\n        elif output_type is not None:\n            self._output_type = output_type\n            self._register_type(\"outputs\", output_type)\n        elif output_list is not None:\n            self._output_type = self.define_type(\"outputs\", output_list)\n        else:\n            raise ValueError(\"Must provide either output_list or output_type.\")\n\n        if self._output_type is None:\n            raise ValueError(\"Output type not defined properly. Check define_type() method.\")\n\n        self.outputs = self._output_type()\n\n    def define_type(self, type_name: str, parameter_list: list[Any]) -&gt; Any:\n        \"\"\"\n        This method defines a new type to be used in the compiled controller.\n        After calling this method, the datatype with name type_name will be\n        available in my_controller.types.type_name for use.\n        See example folder and tutorials for help on using this method.\n\n        Parameters\n        ------------\n        type_name : A string defining the name of your new datatype\n        parameter_list: A list of [('field_name', field_type)...]\n            field_name is a string you choose as the title of the field.\n            field_type is a type either given by a native c_types value or\n                a custom type defined via the define_type() method.\n                All types can be accessed as CompiledController.types.(type_name)\n\n        Example Usage\n        ------------\n            my_controller.DefineType('vector3D', [('x', my_controller.types.c_double),\n                                                  ('y', my_controller.types.c_double),\n                                                  ('z', my_controller.types.c_double)])\n        \"\"\"\n        slots = []\n        for param in parameter_list:\n            slots.append(param[0])\n\n        class CustomStructure(ctypes.Structure):\n            _fields_ = parameter_list\n            __slots__ = slots\n\n        self._register_type(type_name, CustomStructure)\n        return getattr(self.types, type_name)\n\n    def run(self) -&gt; Any:\n        \"\"\"\n        This method calls the main controller function of the library.\n        Under the hood, it calls library_name.main_function_name(*inputs, *outputs),\n        where library_name and main_function_name were given in the constructor.\n\n        Parameters -&gt; None\n\n        Returns:\n            The output structure as defined by the define_outputs() method.\n\n        Raises:\n            ValueError: If define_inputs() or define_outputs() have not been called.\n        \"\"\"\n        if self.inputs is None:\n            raise ValueError(\"Must define input type before calling controller.run(). Use define_inputs() method.\")\n        if self.outputs is None:\n            raise ValueError(\"Must define output type before calling controller.run(). Use define_outputs() method.\")\n        self.main_function(ctypes.byref(self.inputs), ctypes.byref(self.outputs))\n        return self.outputs\n</code></pre>"},{"location":"api/control/compiled/#opensourceleg.control.compiled.CompiledController.define_inputs","title":"<code>define_inputs(input_list=None, input_type=None)</code>","text":"<p>This method defines the input structure to your function. Provide either and input_list or an input_type. See example folder and tutorials for help on using this method.</p>"},{"location":"api/control/compiled/#opensourceleg.control.compiled.CompiledController.define_inputs--parameters","title":"Parameters","text":"<p>input_list: A list of [('field_name', field_type)...] defining the input structure.     Use this when you want to define a new ctypes type to use as the input.     field_name is a string you choose as the title of the field.     field_type is a type either given by a native c_types value or         a custom type defined via the define_type() method.         All types can be accessed as CompiledController.types.(type_name) input_type: A ctypes.Structure class reference to use directly as the input type.     Use this if you have a ctype object already defined.</p>"},{"location":"api/control/compiled/#opensourceleg.control.compiled.CompiledController.define_inputs--raises","title":"Raises","text":"<p>ValueError: If both input_list and input_type are provided, or if neither is provided.</p> Source code in <code>opensourceleg/control/compiled.py</code> <pre><code>def define_inputs(\n    self, input_list: list[Any] | None = None, input_type: type[ctypes.Structure] | None = None\n) -&gt; None:\n    \"\"\"\n    This method defines the input structure to your function.\n    Provide either and input_list or an input_type.\n    See example folder and tutorials for help on using this method.\n\n    Parameters\n    -----------\n    input_list: A list of [('field_name', field_type)...] defining the input structure.\n        Use this when you want to define a new ctypes type to use as the input.\n        field_name is a string you choose as the title of the field.\n        field_type is a type either given by a native c_types value or\n            a custom type defined via the define_type() method.\n            All types can be accessed as CompiledController.types.(type_name)\n    input_type: A ctypes.Structure class reference to use directly as the input type.\n        Use this if you have a ctype object already defined.\n\n    Raises\n    ------\n    ValueError: If both input_list and input_type are provided, or if neither is provided.\n    \"\"\"\n    if input_type is not None and input_list is not None:\n        raise ValueError(\"Only one of input_list or input_type should be provided.\")\n    elif input_type is not None:\n        self._input_type = input_type\n        self._register_type(\"inputs\", input_type)\n    elif input_list is not None:\n        self._input_type = self.define_type(\"inputs\", input_list)\n    else:\n        raise ValueError(\"Must provide either input_list or input_type.\")\n\n    if self._input_type is None:\n        raise ValueError(\"Input type not defined properly. Check define_type() method.\")\n\n    self.inputs = self._input_type()\n</code></pre>"},{"location":"api/control/compiled/#opensourceleg.control.compiled.CompiledController.define_outputs","title":"<code>define_outputs(output_list=None, output_type=None)</code>","text":"<p>This method defines the output structure to your function. Provide either an output_list or an output_type. See example folder and tutorials for help on using this method.</p>"},{"location":"api/control/compiled/#opensourceleg.control.compiled.CompiledController.define_outputs--parameters","title":"Parameters","text":"<p>output_list: A list of [('field_name', field_type)...] defining the output structure.     field_name is a string you choose as the title of the field.     field_type is a type either given by a native c_types value or         a custom type defined via the define_type() method.         All types can be accessed as CompiledController.types.(type_name) output_type: A ctypes.Structure class reference to use directly as the output type.     Use this if you have a ctype object already defined somewhere.</p>"},{"location":"api/control/compiled/#opensourceleg.control.compiled.CompiledController.define_outputs--raises","title":"Raises","text":"<p>ValueError: If both output_list and output_type are provided, or if neither is provided.</p> Source code in <code>opensourceleg/control/compiled.py</code> <pre><code>def define_outputs(\n    self, output_list: list[Any] | None = None, output_type: type[ctypes.Structure] | None = None\n) -&gt; None:\n    \"\"\"\n    This method defines the output structure to your function.\n    Provide either an output_list or an output_type.\n    See example folder and tutorials for help on using this method.\n\n    Parameters\n    -----------\n    output_list: A list of [('field_name', field_type)...] defining the output structure.\n        field_name is a string you choose as the title of the field.\n        field_type is a type either given by a native c_types value or\n            a custom type defined via the define_type() method.\n            All types can be accessed as CompiledController.types.(type_name)\n    output_type: A ctypes.Structure class reference to use directly as the output type.\n        Use this if you have a ctype object already defined somewhere.\n\n    Raises\n    ------\n    ValueError: If both output_list and output_type are provided, or if neither is provided.\n    \"\"\"\n    if output_type is not None and output_list is not None:\n        raise ValueError(\"Only one of output_list or output_type should be provided.\")\n    elif output_type is not None:\n        self._output_type = output_type\n        self._register_type(\"outputs\", output_type)\n    elif output_list is not None:\n        self._output_type = self.define_type(\"outputs\", output_list)\n    else:\n        raise ValueError(\"Must provide either output_list or output_type.\")\n\n    if self._output_type is None:\n        raise ValueError(\"Output type not defined properly. Check define_type() method.\")\n\n    self.outputs = self._output_type()\n</code></pre>"},{"location":"api/control/compiled/#opensourceleg.control.compiled.CompiledController.define_type","title":"<code>define_type(type_name, parameter_list)</code>","text":"<p>This method defines a new type to be used in the compiled controller. After calling this method, the datatype with name type_name will be available in my_controller.types.type_name for use. See example folder and tutorials for help on using this method.</p>"},{"location":"api/control/compiled/#opensourceleg.control.compiled.CompiledController.define_type--parameters","title":"Parameters","text":"<p>type_name : A string defining the name of your new datatype parameter_list: A list of [('field_name', field_type)...]     field_name is a string you choose as the title of the field.     field_type is a type either given by a native c_types value or         a custom type defined via the define_type() method.         All types can be accessed as CompiledController.types.(type_name)</p>"},{"location":"api/control/compiled/#opensourceleg.control.compiled.CompiledController.define_type--example-usage","title":"Example Usage","text":"<pre><code>my_controller.DefineType('vector3D', [('x', my_controller.types.c_double),\n                                      ('y', my_controller.types.c_double),\n                                      ('z', my_controller.types.c_double)])\n</code></pre> Source code in <code>opensourceleg/control/compiled.py</code> <pre><code>def define_type(self, type_name: str, parameter_list: list[Any]) -&gt; Any:\n    \"\"\"\n    This method defines a new type to be used in the compiled controller.\n    After calling this method, the datatype with name type_name will be\n    available in my_controller.types.type_name for use.\n    See example folder and tutorials for help on using this method.\n\n    Parameters\n    ------------\n    type_name : A string defining the name of your new datatype\n    parameter_list: A list of [('field_name', field_type)...]\n        field_name is a string you choose as the title of the field.\n        field_type is a type either given by a native c_types value or\n            a custom type defined via the define_type() method.\n            All types can be accessed as CompiledController.types.(type_name)\n\n    Example Usage\n    ------------\n        my_controller.DefineType('vector3D', [('x', my_controller.types.c_double),\n                                              ('y', my_controller.types.c_double),\n                                              ('z', my_controller.types.c_double)])\n    \"\"\"\n    slots = []\n    for param in parameter_list:\n        slots.append(param[0])\n\n    class CustomStructure(ctypes.Structure):\n        _fields_ = parameter_list\n        __slots__ = slots\n\n    self._register_type(type_name, CustomStructure)\n    return getattr(self.types, type_name)\n</code></pre>"},{"location":"api/control/compiled/#opensourceleg.control.compiled.CompiledController.run","title":"<code>run()</code>","text":"<p>This method calls the main controller function of the library. Under the hood, it calls library_name.main_function_name(inputs, outputs), where library_name and main_function_name were given in the constructor.</p> <p>Parameters -&gt; None</p> <p>Returns:</p> Type Description <code>Any</code> <p>The output structure as defined by the define_outputs() method.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If define_inputs() or define_outputs() have not been called.</p> Source code in <code>opensourceleg/control/compiled.py</code> <pre><code>def run(self) -&gt; Any:\n    \"\"\"\n    This method calls the main controller function of the library.\n    Under the hood, it calls library_name.main_function_name(*inputs, *outputs),\n    where library_name and main_function_name were given in the constructor.\n\n    Parameters -&gt; None\n\n    Returns:\n        The output structure as defined by the define_outputs() method.\n\n    Raises:\n        ValueError: If define_inputs() or define_outputs() have not been called.\n    \"\"\"\n    if self.inputs is None:\n        raise ValueError(\"Must define input type before calling controller.run(). Use define_inputs() method.\")\n    if self.outputs is None:\n        raise ValueError(\"Must define output type before calling controller.run(). Use define_outputs() method.\")\n    self.main_function(ctypes.byref(self.inputs), ctypes.byref(self.outputs))\n    return self.outputs\n</code></pre>"},{"location":"api/control/fsm/","title":"State Machine","text":"<p>(c) 2025 Open-Source Leg</p> <p>A simple and scalable Finite State Machine module. It includes the State, Event, Transition, and StateMachine classes.</p> <p>Usage: 1. Use the <code>State</code> class to represent a state in the FSM. 2. Utilize the <code>Event</code> class to define events that trigger state transitions. 3. Create transitions between states using the <code>Transition</code> class. Add criteria and actions as needed. 4. Instantiate the <code>StateMachine</code> class, add states, events, and transitions, and start the FSM. 5. Use the \"main\" function as an example to see how to use the FSM.</p> Author <ul> <li>Senthur Ayyappan senthura@umich.edu</li> </ul>"},{"location":"api/control/fsm/#opensourceleg.control.fsm.Event","title":"<code>Event</code>","text":"Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>class Event:\n    def __init__(self, name: str) -&gt; None:\n        \"\"\"\n        A class to represent an event in a finite state machine.\n        This is a simple label to identify an event that triggers a transition.\n\n        Args:\n            name: The name of the event.\n\n        Example:\n            &gt;&gt;&gt; event = Event(\"walk\")\n        \"\"\"\n        self._name: str = name\n\n    def __eq__(self, __o: Any) -&gt; bool:\n        return bool(__o.name == self._name)\n\n    def __ne__(self, __o: Any) -&gt; bool:\n        return not self.__eq__(__o)  # TODO: Check this fix\n\n    def __repr__(self) -&gt; str:\n        return f\"Event[{self._name}]\"\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"\n        Get the name of the event.\n\n        Returns:\n            str: The name of the event\n        \"\"\"\n        return self._name\n</code></pre>"},{"location":"api/control/fsm/#opensourceleg.control.fsm.Event.name","title":"<code>name</code>  <code>property</code>","text":"<p>Get the name of the event.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the event</p>"},{"location":"api/control/fsm/#opensourceleg.control.fsm.Event.__init__","title":"<code>__init__(name)</code>","text":"<p>A class to represent an event in a finite state machine. This is a simple label to identify an event that triggers a transition.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the event.</p> required Example <p>event = Event(\"walk\")</p> Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>def __init__(self, name: str) -&gt; None:\n    \"\"\"\n    A class to represent an event in a finite state machine.\n    This is a simple label to identify an event that triggers a transition.\n\n    Args:\n        name: The name of the event.\n\n    Example:\n        &gt;&gt;&gt; event = Event(\"walk\")\n    \"\"\"\n    self._name: str = name\n</code></pre>"},{"location":"api/control/fsm/#opensourceleg.control.fsm.State","title":"<code>State</code>","text":"Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>class State:\n    def __init__(\n        self,\n        name: str = \"state\",\n        minimum_time_in_state: float = 0.0,\n        entry_callbacks: Optional[list[Callable[[Any], None]]] = None,\n        exit_callbacks: Optional[list[Callable[[Any], None]]] = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        A class to represent a state in a finite state machine.\n        Custom attributes can be added to the state using keyword arguments.\n\n        Args:\n            name: Name of the state\n            minimum_time_in_state: Minimum time spent in the state in seconds. \\\n                Transition to the next state will not occur until this time has elapsed.\n                Defaults to 0.0 seconds.\n            entry_callbacks: List of functions to call when entering the state.\n            exit_callbacks: List of functions to call when exiting the state.\n            **kwargs: Additional attributes to set on the state\n\n        Example:\n            &gt;&gt;&gt; state = State(\n            ...     name=\"idle\",\n            ...     minimum_time_in_state=2.0,\n            ...     entry_callbacks=[print(\"Entering idle state\")],\n            ...     exit_callbacks=[print(\"Exiting idle state\")],\n            ... )\n        \"\"\"\n        self._name: str = name\n        self._time_entered: float = 0.0\n        self._time_exited: float = 0.0\n        self._min_time_in_state: float = minimum_time_in_state\n        self._entry_callbacks: list[Callable[[Any], None]] = entry_callbacks or []\n        self._exit_callbacks: list[Callable[[Any], None]] = exit_callbacks or []\n\n        for key, value in kwargs.items():\n            setattr(self, key, value)\n\n    def __eq__(self, __o: Any) -&gt; bool:\n        return bool(__o.name == self._name)\n\n    def __ne__(self, __o: Any) -&gt; bool:\n        return not self.__eq__(__o)\n\n    def __hash__(self) -&gt; int:\n        return hash(self._name)\n\n    def __repr__(self) -&gt; str:\n        return f\"State[{self._name}]\"\n\n    def set_minimum_time_spent_in_state(self, time: float) -&gt; None:\n        \"\"\"\n        Set the minimum time spent in the state\n\n        Args:\n            time: Minimum time spent in the state in seconds\n\n        Example:\n            &gt;&gt;&gt; state.set_minimum_time_spent_in_state(2.0)\n        \"\"\"\n        self._min_time_in_state = time\n\n    def add_entry_callback(self, callback: Callable[[Any], None]) -&gt; None:\n        \"\"\"\n        Add a callback function to be called when entering the state.\n\n        Args:\n            callback: Function to be called when entering the state\n\n        Example:\n            &gt;&gt;&gt; state.add_entry_callback(lambda: if t &gt; 0: print(\"Entering idle state\"))\n        \"\"\"\n        self._entry_callbacks.append(callback)\n\n    def add_exit_callback(self, callback: Callable[[Any], None]) -&gt; None:\n        \"\"\"\n        Add a callback function to be called when exiting the state.\n\n        Args:\n            callback: Function to be called when exiting the state\n\n        Example:\n            &gt;&gt;&gt; state.add_exit_callback(lambda: if t &gt; 1: print(\"Exiting idle state\"))\n        \"\"\"\n        self._exit_callbacks.append(callback)\n\n    def enter(self, *args: Any, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Enter the state.\n\n        Args:\n            *args: Arguments to pass to the entry callbacks\n            **kwargs: Keyword arguments to pass to the entry callbacks\n\n        Example:\n            &gt;&gt;&gt; state.enter(x=1)\n        \"\"\"\n        self._time_entered = time.monotonic()\n        for c in self._entry_callbacks:\n            c(*args, **kwargs)\n\n    def exit(self, *args: Any, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Exit the state.\n\n        Args:\n            *args: Arguments to pass to the exit callbacks\n            **kwargs: Keyword arguments to pass to the exit callbacks\n\n        Example:\n            &gt;&gt;&gt; state.exit(x=1)\n        \"\"\"\n        self._time_exited = time.monotonic()\n        for c in self._exit_callbacks:\n            c(*args, **kwargs)\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"\n        Get the name of the state.\n\n        Returns:\n            str: The name of the state\n        \"\"\"\n        return self._name\n\n    @property\n    def minimum_time_spent_in_state(self) -&gt; float:\n        \"\"\"\n        Get the minimum time spent in the state.\n\n        Returns:\n            float: The minimum time spent in the state\n        \"\"\"\n        return self._min_time_in_state\n\n    @property\n    def current_time_in_state(self) -&gt; float:\n        \"\"\"\n        Get the current time spent in the state.\n\n        Returns:\n            float: The current time spent in the state\n        \"\"\"\n        return time.monotonic() - self._time_entered\n\n    @property\n    def time_spent_in_state(self) -&gt; float:\n        \"\"\"\n        Get the time spent in the state.\n\n        Returns:\n            float: The time spent in the state\n        \"\"\"\n        return self._time_exited - self._time_entered\n</code></pre>"},{"location":"api/control/fsm/#opensourceleg.control.fsm.State.current_time_in_state","title":"<code>current_time_in_state</code>  <code>property</code>","text":"<p>Get the current time spent in the state.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The current time spent in the state</p>"},{"location":"api/control/fsm/#opensourceleg.control.fsm.State.minimum_time_spent_in_state","title":"<code>minimum_time_spent_in_state</code>  <code>property</code>","text":"<p>Get the minimum time spent in the state.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The minimum time spent in the state</p>"},{"location":"api/control/fsm/#opensourceleg.control.fsm.State.name","title":"<code>name</code>  <code>property</code>","text":"<p>Get the name of the state.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the state</p>"},{"location":"api/control/fsm/#opensourceleg.control.fsm.State.time_spent_in_state","title":"<code>time_spent_in_state</code>  <code>property</code>","text":"<p>Get the time spent in the state.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The time spent in the state</p>"},{"location":"api/control/fsm/#opensourceleg.control.fsm.State.__init__","title":"<code>__init__(name='state', minimum_time_in_state=0.0, entry_callbacks=None, exit_callbacks=None, **kwargs)</code>","text":"<p>A class to represent a state in a finite state machine. Custom attributes can be added to the state using keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the state</p> <code>'state'</code> <code>minimum_time_in_state</code> <code>float</code> <p>Minimum time spent in the state in seconds.                 Transition to the next state will not occur until this time has elapsed. Defaults to 0.0 seconds.</p> <code>0.0</code> <code>entry_callbacks</code> <code>Optional[list[Callable[[Any], None]]]</code> <p>List of functions to call when entering the state.</p> <code>None</code> <code>exit_callbacks</code> <code>Optional[list[Callable[[Any], None]]]</code> <p>List of functions to call when exiting the state.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional attributes to set on the state</p> <code>{}</code> Example <p>state = State( ...     name=\"idle\", ...     minimum_time_in_state=2.0, ...     entry_callbacks=[print(\"Entering idle state\")], ...     exit_callbacks=[print(\"Exiting idle state\")], ... )</p> Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>def __init__(\n    self,\n    name: str = \"state\",\n    minimum_time_in_state: float = 0.0,\n    entry_callbacks: Optional[list[Callable[[Any], None]]] = None,\n    exit_callbacks: Optional[list[Callable[[Any], None]]] = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    A class to represent a state in a finite state machine.\n    Custom attributes can be added to the state using keyword arguments.\n\n    Args:\n        name: Name of the state\n        minimum_time_in_state: Minimum time spent in the state in seconds. \\\n            Transition to the next state will not occur until this time has elapsed.\n            Defaults to 0.0 seconds.\n        entry_callbacks: List of functions to call when entering the state.\n        exit_callbacks: List of functions to call when exiting the state.\n        **kwargs: Additional attributes to set on the state\n\n    Example:\n        &gt;&gt;&gt; state = State(\n        ...     name=\"idle\",\n        ...     minimum_time_in_state=2.0,\n        ...     entry_callbacks=[print(\"Entering idle state\")],\n        ...     exit_callbacks=[print(\"Exiting idle state\")],\n        ... )\n    \"\"\"\n    self._name: str = name\n    self._time_entered: float = 0.0\n    self._time_exited: float = 0.0\n    self._min_time_in_state: float = minimum_time_in_state\n    self._entry_callbacks: list[Callable[[Any], None]] = entry_callbacks or []\n    self._exit_callbacks: list[Callable[[Any], None]] = exit_callbacks or []\n\n    for key, value in kwargs.items():\n        setattr(self, key, value)\n</code></pre>"},{"location":"api/control/fsm/#opensourceleg.control.fsm.State.add_entry_callback","title":"<code>add_entry_callback(callback)</code>","text":"<p>Add a callback function to be called when entering the state.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[Any], None]</code> <p>Function to be called when entering the state</p> required Example <p>state.add_entry_callback(lambda: if t &gt; 0: print(\"Entering idle state\"))</p> Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>def add_entry_callback(self, callback: Callable[[Any], None]) -&gt; None:\n    \"\"\"\n    Add a callback function to be called when entering the state.\n\n    Args:\n        callback: Function to be called when entering the state\n\n    Example:\n        &gt;&gt;&gt; state.add_entry_callback(lambda: if t &gt; 0: print(\"Entering idle state\"))\n    \"\"\"\n    self._entry_callbacks.append(callback)\n</code></pre>"},{"location":"api/control/fsm/#opensourceleg.control.fsm.State.add_exit_callback","title":"<code>add_exit_callback(callback)</code>","text":"<p>Add a callback function to be called when exiting the state.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[Any], None]</code> <p>Function to be called when exiting the state</p> required Example <p>state.add_exit_callback(lambda: if t &gt; 1: print(\"Exiting idle state\"))</p> Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>def add_exit_callback(self, callback: Callable[[Any], None]) -&gt; None:\n    \"\"\"\n    Add a callback function to be called when exiting the state.\n\n    Args:\n        callback: Function to be called when exiting the state\n\n    Example:\n        &gt;&gt;&gt; state.add_exit_callback(lambda: if t &gt; 1: print(\"Exiting idle state\"))\n    \"\"\"\n    self._exit_callbacks.append(callback)\n</code></pre>"},{"location":"api/control/fsm/#opensourceleg.control.fsm.State.enter","title":"<code>enter(*args, **kwargs)</code>","text":"<p>Enter the state.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Arguments to pass to the entry callbacks</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to pass to the entry callbacks</p> <code>{}</code> Example <p>state.enter(x=1)</p> Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>def enter(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Enter the state.\n\n    Args:\n        *args: Arguments to pass to the entry callbacks\n        **kwargs: Keyword arguments to pass to the entry callbacks\n\n    Example:\n        &gt;&gt;&gt; state.enter(x=1)\n    \"\"\"\n    self._time_entered = time.monotonic()\n    for c in self._entry_callbacks:\n        c(*args, **kwargs)\n</code></pre>"},{"location":"api/control/fsm/#opensourceleg.control.fsm.State.exit","title":"<code>exit(*args, **kwargs)</code>","text":"<p>Exit the state.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Arguments to pass to the exit callbacks</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to pass to the exit callbacks</p> <code>{}</code> Example <p>state.exit(x=1)</p> Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>def exit(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Exit the state.\n\n    Args:\n        *args: Arguments to pass to the exit callbacks\n        **kwargs: Keyword arguments to pass to the exit callbacks\n\n    Example:\n        &gt;&gt;&gt; state.exit(x=1)\n    \"\"\"\n    self._time_exited = time.monotonic()\n    for c in self._exit_callbacks:\n        c(*args, **kwargs)\n</code></pre>"},{"location":"api/control/fsm/#opensourceleg.control.fsm.State.set_minimum_time_spent_in_state","title":"<code>set_minimum_time_spent_in_state(time)</code>","text":"<p>Set the minimum time spent in the state</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float</code> <p>Minimum time spent in the state in seconds</p> required Example <p>state.set_minimum_time_spent_in_state(2.0)</p> Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>def set_minimum_time_spent_in_state(self, time: float) -&gt; None:\n    \"\"\"\n    Set the minimum time spent in the state\n\n    Args:\n        time: Minimum time spent in the state in seconds\n\n    Example:\n        &gt;&gt;&gt; state.set_minimum_time_spent_in_state(2.0)\n    \"\"\"\n    self._min_time_in_state = time\n</code></pre>"},{"location":"api/control/fsm/#opensourceleg.control.fsm.StateMachine","title":"<code>StateMachine</code>","text":"Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>class StateMachine:\n    def __init__(\n        self,\n        states: Optional[list[State]] = None,\n        initial_state_name: Optional[str] = None,\n    ) -&gt; None:\n        \"\"\"\n        A flexible finite state machine class that supports:\n        - Multiple states with transitions between them\n        - Events that trigger transitions\n        - Entry and exit actions for states\n        - Minimum time constraints for states\n\n        Args:\n            states: List of states to add to the state machine\n            initial_state_name: Name of the initial state to set\n\n        Example:\n            &gt;&gt;&gt; sm = StateMachine(states=[State(\"idle\"), State(\"walking\"), State(\"running\")],\n            ...     initial_state_name=\"idle\")\n        \"\"\"\n        self._states: list[State] = []\n        self._events: list[Event] = []\n        self._transitions: list[Transition] = []\n        self._transition_map: dict[State, list[Transition]] = {}\n\n        self._initial_state: Optional[State] = None\n        self._current_state: Optional[State] = None\n\n        if states:\n            self.add_states(states, initial_state_name)\n\n    def __repr__(self) -&gt; str:\n        return \"StateMachine\"\n\n    def add_states(self, states: list[State], initial_state_name: Optional[str] = None) -&gt; None:\n        \"\"\"\n        Add multiple states to the state machine at once.\n\n        Args:\n            states: List of states to add\n            initial_state_name: Name of the state to set as initial state\n\n        Example:\n            &gt;&gt;&gt; sm.add_states([State(\"idle\"), State(\"walking\"), State(\"running\")], initial_state_name=\"idle\")\n        \"\"\"\n        for state in states:\n            if state not in self._states:\n                self._states.append(state)\n                # Set up transition map entry\n                if state not in self._transition_map:\n                    self._transition_map[state] = []\n            else:\n                LOGGER.warning(f\"State {state.name} already exists in state machine\")\n\n        # Set initial state if specified and warn if overwriting\n        if initial_state_name:\n            user_defined_initial_state = self.get_state_by_name(initial_state_name)\n            if user_defined_initial_state:\n                if self.initial_state is not None:\n                    LOGGER.warning(f\"Overwriting initial state from {self.initial_state.name} to {initial_state_name}\")\n                self._initial_state = user_defined_initial_state\n            else:\n                LOGGER.warning(f\"Initial state {initial_state_name} not found in added states\")\n\n    def add_events(self, events: list[Event]) -&gt; None:\n        \"\"\"\n        Add multiple events to the state machine at once.\n\n        Args:\n            events: List of events to add\n\n        Example:\n            &gt;&gt;&gt; sm.add_events([Event(\"walk\"), Event(\"run\"), Event(\"stop\")])\n        \"\"\"\n        for event in events:\n            if event not in self._events:\n                self._events.append(event)\n            else:\n                LOGGER.warning(f\"Event {event.name} already exists in state machine\")\n\n    def create_state(self, name: str, **kwargs: Any) -&gt; State:\n        \"\"\"\n        Create a new state and add it to the state machine.\n\n        Args:\n            name: Name of the state\n            **kwargs: Additional arguments to pass to the State constructor\n\n        Returns:\n            State: The created state\n\n        Example:\n            &gt;&gt;&gt; sm.create_state(\n            ...     name=\"idle\",\n            ...     minimum_time_spent_in_state=2.0,\n            ...     entry_callbacks=[print(\"Entering idle state\")],\n            ...     exit_callbacks=[print(\"Exiting idle state\")],\n            ... )\n        \"\"\"\n        state = State(name=name, **kwargs)\n        self.add_states([state])\n        return state\n\n    def create_event(self, name: str) -&gt; Event:\n        \"\"\"\n        Create a new event and add it to the state machine.\n\n        Args:\n            name: Name of the event\n\n        Returns:\n            Event: The created event\n\n        Example:\n            &gt;&gt;&gt; sm.create_event(\"walk\")\n        \"\"\"\n        event = Event(name=name)\n        self.add_events([event])\n        return event\n\n    def add_transition(\n        self,\n        source: State,\n        destination: State,\n        event_name: str,\n        criteria: Optional[Callable[[Any], bool]] = None,\n        action: Optional[Callable[[Any], None]] = None,\n    ) -&gt; Optional[Transition]:\n        \"\"\"\n        Add a transition to the state machine. If multiple transitions exist from the same source state,\n        precedence is given to the first added transition.\n\n        Args:\n            source: The source state\n            destination: The destination state\n            event_name: The name of the event that triggers the transition\n            criteria: A callback function that returns a boolean value, which determines whether the transition is valid\n            action: A callback function to execute during the transition\n\n        Returns:\n            Optional[Transition]: The created transition, or None if the transition couldn't be created\n\n        Example:\n            &gt;&gt;&gt; sm.add_transition(\n            ...     source=State(\"idle\"),\n            ...     destination=State(\"walking\"),\n            ...     event_name=\"walk\",\n            ...     criteria=lambda: True,\n            ...     action=lambda: print(\"Walking\"),\n            ... )\n        \"\"\"\n        transition = None\n        event = self.create_event(event_name)\n\n        if source in self._states and destination in self._states and event in self._events:\n            transition = Transition(\n                event=event,\n                source=source,\n                destination=destination,\n                criteria=criteria,\n                action=action,\n            )\n            self._transitions.append(transition)\n\n            # Add to transition map for faster lookup\n            if source not in self._transition_map:\n                self._transition_map[source] = []\n            self._transition_map[source].append(transition)\n\n        return transition\n\n    def update(self, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Update the state machine, checking all possible transitions from the current state.\n        If any transition's criteria are met, the state machine will transition automatically. If multiple\n        transitions exist from the same source state, precedence is given to the first added transition.\n\n        Args:\n            **kwargs: Named arguments to pass to transition criteria and actions\n\n        Example:\n            &gt;&gt;&gt; sm.update(t=t)\n        \"\"\"\n        if not self._current_state:\n            raise ValueError(\"State machine isn't active.\")\n\n        # Check if minimum time in state has elapsed\n        if self._current_state.current_time_in_state &lt; self._current_state.minimum_time_spent_in_state:\n            return\n\n        transitions = self._transition_map.get(self._current_state, [])\n\n        if not transitions:\n            LOGGER.debug(f\"No transitions defined for state {self._current_state.name}\")\n            return\n\n        for transition in transitions:\n            next_state = transition(**kwargs)\n\n            # If state changed, update current state and exit\n            if next_state != self._current_state:\n                self._current_state = next_state\n\n                return\n\n        LOGGER.debug(f\"No valid transitions from state {self._current_state.name}\")\n\n    def start(self, *args: Any, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Start the state machine.\n\n        Args:\n            *args: Arguments to pass to the initial state\n            **kwargs: Keyword arguments to pass to the initial state\n\n        Example:\n            &gt;&gt;&gt; sm.start(x=1)\n        \"\"\"\n        if not self._initial_state:\n            raise ValueError(\n                \"No initial state set. Add at least one state with initial_state=True or add a non-exit state.\"\n            )\n\n        self._current_state = self._initial_state\n        self._current_state.enter(*args, **kwargs)\n\n    def stop(self, *args: Any, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Stop the state machine.\n\n        Args:\n            *args: Arguments to pass to the exit state\n            **kwargs: Keyword arguments to pass to the exit state\n\n        Example:\n            &gt;&gt;&gt; sm.stop(x=1)\n        \"\"\"\n        if not self._current_state:\n            raise ValueError(\"State machine isn't active.\")\n\n        self._current_state.exit(*args, **kwargs)\n\n    def __enter__(self) -&gt; \"StateMachine\":\n        \"\"\"\n        Enter the context manager for the state machine.\n\n        Returns:\n            StateMachine: The state machine\n\n        Example:\n            &gt;&gt;&gt; with sm:\n            ...     # Use the state machine\n            ...     pass\n        \"\"\"\n        self.start()\n        return self\n\n    def __exit__(self, *args: Any, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Exit the context manager for the state machine.\n\n        Args:\n            *args: Arguments to pass to the exit state\n            **kwargs: Keyword arguments to pass to the exit state\n\n        Example:\n            &gt;&gt;&gt; with sm:\n            ...     # Use the state machine\n            ...     pass\n        \"\"\"\n        self.stop()\n\n    def __del__(self) -&gt; None:\n        self.stop()\n\n    def __iter__(self) -&gt; Iterator[State]:\n        return iter(self._states)\n\n    def __next__(self) -&gt; State:\n        try:\n            return next(iter(self._states))\n        except StopIteration as e:\n            raise StopIteration(\"No states in state machine\") from e\n\n    @property\n    def current_state(self) -&gt; Optional[State]:\n        \"\"\"\n        Get the current state of the state machine.\n\n        Returns:\n            State: The current state of the state machine\n        \"\"\"\n        return self._current_state\n\n    @property\n    def initial_state(self) -&gt; Optional[State]:\n        \"\"\"\n        Get the initial state of the state machine.\n\n        Returns:\n            State: The initial state of the state machine\n        \"\"\"\n        return self._initial_state\n\n    @property\n    def states(self) -&gt; list[str]:\n        \"\"\"\n        Get the names of all states in the state machine.\n\n        Returns:\n            list[str]: The names of all states in the state machine\n        \"\"\"\n        return [state.name for state in self._states]\n\n    def get_state_by_name(self, name: str) -&gt; Optional[State]:\n        \"\"\"\n        Get a state by its name.\n\n        Args:\n            name: The name of the state to find\n\n        Returns:\n            Optional[State]: The state with the given name, or None if not found\n        \"\"\"\n        for state in self._states:\n            if state.name == name:\n                return state\n        return None\n</code></pre>"},{"location":"api/control/fsm/#opensourceleg.control.fsm.StateMachine.current_state","title":"<code>current_state</code>  <code>property</code>","text":"<p>Get the current state of the state machine.</p> <p>Returns:</p> Name Type Description <code>State</code> <code>Optional[State]</code> <p>The current state of the state machine</p>"},{"location":"api/control/fsm/#opensourceleg.control.fsm.StateMachine.initial_state","title":"<code>initial_state</code>  <code>property</code>","text":"<p>Get the initial state of the state machine.</p> <p>Returns:</p> Name Type Description <code>State</code> <code>Optional[State]</code> <p>The initial state of the state machine</p>"},{"location":"api/control/fsm/#opensourceleg.control.fsm.StateMachine.states","title":"<code>states</code>  <code>property</code>","text":"<p>Get the names of all states in the state machine.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: The names of all states in the state machine</p>"},{"location":"api/control/fsm/#opensourceleg.control.fsm.StateMachine.__enter__","title":"<code>__enter__()</code>","text":"<p>Enter the context manager for the state machine.</p> <p>Returns:</p> Name Type Description <code>StateMachine</code> <code>StateMachine</code> <p>The state machine</p> Example <p>with sm: ...     # Use the state machine ...     pass</p> Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>def __enter__(self) -&gt; \"StateMachine\":\n    \"\"\"\n    Enter the context manager for the state machine.\n\n    Returns:\n        StateMachine: The state machine\n\n    Example:\n        &gt;&gt;&gt; with sm:\n        ...     # Use the state machine\n        ...     pass\n    \"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"api/control/fsm/#opensourceleg.control.fsm.StateMachine.__exit__","title":"<code>__exit__(*args, **kwargs)</code>","text":"<p>Exit the context manager for the state machine.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Arguments to pass to the exit state</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to pass to the exit state</p> <code>{}</code> Example <p>with sm: ...     # Use the state machine ...     pass</p> Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>def __exit__(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Exit the context manager for the state machine.\n\n    Args:\n        *args: Arguments to pass to the exit state\n        **kwargs: Keyword arguments to pass to the exit state\n\n    Example:\n        &gt;&gt;&gt; with sm:\n        ...     # Use the state machine\n        ...     pass\n    \"\"\"\n    self.stop()\n</code></pre>"},{"location":"api/control/fsm/#opensourceleg.control.fsm.StateMachine.__init__","title":"<code>__init__(states=None, initial_state_name=None)</code>","text":"<p>A flexible finite state machine class that supports: - Multiple states with transitions between them - Events that trigger transitions - Entry and exit actions for states - Minimum time constraints for states</p> <p>Parameters:</p> Name Type Description Default <code>states</code> <code>Optional[list[State]]</code> <p>List of states to add to the state machine</p> <code>None</code> <code>initial_state_name</code> <code>Optional[str]</code> <p>Name of the initial state to set</p> <code>None</code> Example <p>sm = StateMachine(states=[State(\"idle\"), State(\"walking\"), State(\"running\")], ...     initial_state_name=\"idle\")</p> Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>def __init__(\n    self,\n    states: Optional[list[State]] = None,\n    initial_state_name: Optional[str] = None,\n) -&gt; None:\n    \"\"\"\n    A flexible finite state machine class that supports:\n    - Multiple states with transitions between them\n    - Events that trigger transitions\n    - Entry and exit actions for states\n    - Minimum time constraints for states\n\n    Args:\n        states: List of states to add to the state machine\n        initial_state_name: Name of the initial state to set\n\n    Example:\n        &gt;&gt;&gt; sm = StateMachine(states=[State(\"idle\"), State(\"walking\"), State(\"running\")],\n        ...     initial_state_name=\"idle\")\n    \"\"\"\n    self._states: list[State] = []\n    self._events: list[Event] = []\n    self._transitions: list[Transition] = []\n    self._transition_map: dict[State, list[Transition]] = {}\n\n    self._initial_state: Optional[State] = None\n    self._current_state: Optional[State] = None\n\n    if states:\n        self.add_states(states, initial_state_name)\n</code></pre>"},{"location":"api/control/fsm/#opensourceleg.control.fsm.StateMachine.add_events","title":"<code>add_events(events)</code>","text":"<p>Add multiple events to the state machine at once.</p> <p>Parameters:</p> Name Type Description Default <code>events</code> <code>list[Event]</code> <p>List of events to add</p> required Example <p>sm.add_events([Event(\"walk\"), Event(\"run\"), Event(\"stop\")])</p> Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>def add_events(self, events: list[Event]) -&gt; None:\n    \"\"\"\n    Add multiple events to the state machine at once.\n\n    Args:\n        events: List of events to add\n\n    Example:\n        &gt;&gt;&gt; sm.add_events([Event(\"walk\"), Event(\"run\"), Event(\"stop\")])\n    \"\"\"\n    for event in events:\n        if event not in self._events:\n            self._events.append(event)\n        else:\n            LOGGER.warning(f\"Event {event.name} already exists in state machine\")\n</code></pre>"},{"location":"api/control/fsm/#opensourceleg.control.fsm.StateMachine.add_states","title":"<code>add_states(states, initial_state_name=None)</code>","text":"<p>Add multiple states to the state machine at once.</p> <p>Parameters:</p> Name Type Description Default <code>states</code> <code>list[State]</code> <p>List of states to add</p> required <code>initial_state_name</code> <code>Optional[str]</code> <p>Name of the state to set as initial state</p> <code>None</code> Example <p>sm.add_states([State(\"idle\"), State(\"walking\"), State(\"running\")], initial_state_name=\"idle\")</p> Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>def add_states(self, states: list[State], initial_state_name: Optional[str] = None) -&gt; None:\n    \"\"\"\n    Add multiple states to the state machine at once.\n\n    Args:\n        states: List of states to add\n        initial_state_name: Name of the state to set as initial state\n\n    Example:\n        &gt;&gt;&gt; sm.add_states([State(\"idle\"), State(\"walking\"), State(\"running\")], initial_state_name=\"idle\")\n    \"\"\"\n    for state in states:\n        if state not in self._states:\n            self._states.append(state)\n            # Set up transition map entry\n            if state not in self._transition_map:\n                self._transition_map[state] = []\n        else:\n            LOGGER.warning(f\"State {state.name} already exists in state machine\")\n\n    # Set initial state if specified and warn if overwriting\n    if initial_state_name:\n        user_defined_initial_state = self.get_state_by_name(initial_state_name)\n        if user_defined_initial_state:\n            if self.initial_state is not None:\n                LOGGER.warning(f\"Overwriting initial state from {self.initial_state.name} to {initial_state_name}\")\n            self._initial_state = user_defined_initial_state\n        else:\n            LOGGER.warning(f\"Initial state {initial_state_name} not found in added states\")\n</code></pre>"},{"location":"api/control/fsm/#opensourceleg.control.fsm.StateMachine.add_transition","title":"<code>add_transition(source, destination, event_name, criteria=None, action=None)</code>","text":"<p>Add a transition to the state machine. If multiple transitions exist from the same source state, precedence is given to the first added transition.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>State</code> <p>The source state</p> required <code>destination</code> <code>State</code> <p>The destination state</p> required <code>event_name</code> <code>str</code> <p>The name of the event that triggers the transition</p> required <code>criteria</code> <code>Optional[Callable[[Any], bool]]</code> <p>A callback function that returns a boolean value, which determines whether the transition is valid</p> <code>None</code> <code>action</code> <code>Optional[Callable[[Any], None]]</code> <p>A callback function to execute during the transition</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Transition]</code> <p>Optional[Transition]: The created transition, or None if the transition couldn't be created</p> Example <p>sm.add_transition( ...     source=State(\"idle\"), ...     destination=State(\"walking\"), ...     event_name=\"walk\", ...     criteria=lambda: True, ...     action=lambda: print(\"Walking\"), ... )</p> Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>def add_transition(\n    self,\n    source: State,\n    destination: State,\n    event_name: str,\n    criteria: Optional[Callable[[Any], bool]] = None,\n    action: Optional[Callable[[Any], None]] = None,\n) -&gt; Optional[Transition]:\n    \"\"\"\n    Add a transition to the state machine. If multiple transitions exist from the same source state,\n    precedence is given to the first added transition.\n\n    Args:\n        source: The source state\n        destination: The destination state\n        event_name: The name of the event that triggers the transition\n        criteria: A callback function that returns a boolean value, which determines whether the transition is valid\n        action: A callback function to execute during the transition\n\n    Returns:\n        Optional[Transition]: The created transition, or None if the transition couldn't be created\n\n    Example:\n        &gt;&gt;&gt; sm.add_transition(\n        ...     source=State(\"idle\"),\n        ...     destination=State(\"walking\"),\n        ...     event_name=\"walk\",\n        ...     criteria=lambda: True,\n        ...     action=lambda: print(\"Walking\"),\n        ... )\n    \"\"\"\n    transition = None\n    event = self.create_event(event_name)\n\n    if source in self._states and destination in self._states and event in self._events:\n        transition = Transition(\n            event=event,\n            source=source,\n            destination=destination,\n            criteria=criteria,\n            action=action,\n        )\n        self._transitions.append(transition)\n\n        # Add to transition map for faster lookup\n        if source not in self._transition_map:\n            self._transition_map[source] = []\n        self._transition_map[source].append(transition)\n\n    return transition\n</code></pre>"},{"location":"api/control/fsm/#opensourceleg.control.fsm.StateMachine.create_event","title":"<code>create_event(name)</code>","text":"<p>Create a new event and add it to the state machine.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the event</p> required <p>Returns:</p> Name Type Description <code>Event</code> <code>Event</code> <p>The created event</p> Example <p>sm.create_event(\"walk\")</p> Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>def create_event(self, name: str) -&gt; Event:\n    \"\"\"\n    Create a new event and add it to the state machine.\n\n    Args:\n        name: Name of the event\n\n    Returns:\n        Event: The created event\n\n    Example:\n        &gt;&gt;&gt; sm.create_event(\"walk\")\n    \"\"\"\n    event = Event(name=name)\n    self.add_events([event])\n    return event\n</code></pre>"},{"location":"api/control/fsm/#opensourceleg.control.fsm.StateMachine.create_state","title":"<code>create_state(name, **kwargs)</code>","text":"<p>Create a new state and add it to the state machine.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the state</p> required <code>**kwargs</code> <code>Any</code> <p>Additional arguments to pass to the State constructor</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>State</code> <code>State</code> <p>The created state</p> Example <p>sm.create_state( ...     name=\"idle\", ...     minimum_time_spent_in_state=2.0, ...     entry_callbacks=[print(\"Entering idle state\")], ...     exit_callbacks=[print(\"Exiting idle state\")], ... )</p> Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>def create_state(self, name: str, **kwargs: Any) -&gt; State:\n    \"\"\"\n    Create a new state and add it to the state machine.\n\n    Args:\n        name: Name of the state\n        **kwargs: Additional arguments to pass to the State constructor\n\n    Returns:\n        State: The created state\n\n    Example:\n        &gt;&gt;&gt; sm.create_state(\n        ...     name=\"idle\",\n        ...     minimum_time_spent_in_state=2.0,\n        ...     entry_callbacks=[print(\"Entering idle state\")],\n        ...     exit_callbacks=[print(\"Exiting idle state\")],\n        ... )\n    \"\"\"\n    state = State(name=name, **kwargs)\n    self.add_states([state])\n    return state\n</code></pre>"},{"location":"api/control/fsm/#opensourceleg.control.fsm.StateMachine.get_state_by_name","title":"<code>get_state_by_name(name)</code>","text":"<p>Get a state by its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the state to find</p> required <p>Returns:</p> Type Description <code>Optional[State]</code> <p>Optional[State]: The state with the given name, or None if not found</p> Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>def get_state_by_name(self, name: str) -&gt; Optional[State]:\n    \"\"\"\n    Get a state by its name.\n\n    Args:\n        name: The name of the state to find\n\n    Returns:\n        Optional[State]: The state with the given name, or None if not found\n    \"\"\"\n    for state in self._states:\n        if state.name == name:\n            return state\n    return None\n</code></pre>"},{"location":"api/control/fsm/#opensourceleg.control.fsm.StateMachine.start","title":"<code>start(*args, **kwargs)</code>","text":"<p>Start the state machine.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Arguments to pass to the initial state</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to pass to the initial state</p> <code>{}</code> Example <p>sm.start(x=1)</p> Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>def start(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Start the state machine.\n\n    Args:\n        *args: Arguments to pass to the initial state\n        **kwargs: Keyword arguments to pass to the initial state\n\n    Example:\n        &gt;&gt;&gt; sm.start(x=1)\n    \"\"\"\n    if not self._initial_state:\n        raise ValueError(\n            \"No initial state set. Add at least one state with initial_state=True or add a non-exit state.\"\n        )\n\n    self._current_state = self._initial_state\n    self._current_state.enter(*args, **kwargs)\n</code></pre>"},{"location":"api/control/fsm/#opensourceleg.control.fsm.StateMachine.stop","title":"<code>stop(*args, **kwargs)</code>","text":"<p>Stop the state machine.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Arguments to pass to the exit state</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to pass to the exit state</p> <code>{}</code> Example <p>sm.stop(x=1)</p> Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>def stop(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Stop the state machine.\n\n    Args:\n        *args: Arguments to pass to the exit state\n        **kwargs: Keyword arguments to pass to the exit state\n\n    Example:\n        &gt;&gt;&gt; sm.stop(x=1)\n    \"\"\"\n    if not self._current_state:\n        raise ValueError(\"State machine isn't active.\")\n\n    self._current_state.exit(*args, **kwargs)\n</code></pre>"},{"location":"api/control/fsm/#opensourceleg.control.fsm.StateMachine.update","title":"<code>update(**kwargs)</code>","text":"<p>Update the state machine, checking all possible transitions from the current state. If any transition's criteria are met, the state machine will transition automatically. If multiple transitions exist from the same source state, precedence is given to the first added transition.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Named arguments to pass to transition criteria and actions</p> <code>{}</code> Example <p>sm.update(t=t)</p> Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>def update(self, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Update the state machine, checking all possible transitions from the current state.\n    If any transition's criteria are met, the state machine will transition automatically. If multiple\n    transitions exist from the same source state, precedence is given to the first added transition.\n\n    Args:\n        **kwargs: Named arguments to pass to transition criteria and actions\n\n    Example:\n        &gt;&gt;&gt; sm.update(t=t)\n    \"\"\"\n    if not self._current_state:\n        raise ValueError(\"State machine isn't active.\")\n\n    # Check if minimum time in state has elapsed\n    if self._current_state.current_time_in_state &lt; self._current_state.minimum_time_spent_in_state:\n        return\n\n    transitions = self._transition_map.get(self._current_state, [])\n\n    if not transitions:\n        LOGGER.debug(f\"No transitions defined for state {self._current_state.name}\")\n        return\n\n    for transition in transitions:\n        next_state = transition(**kwargs)\n\n        # If state changed, update current state and exit\n        if next_state != self._current_state:\n            self._current_state = next_state\n\n            return\n\n    LOGGER.debug(f\"No valid transitions from state {self._current_state.name}\")\n</code></pre>"},{"location":"api/control/fsm/#opensourceleg.control.fsm.Transition","title":"<code>Transition</code>","text":"Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>class Transition:\n    def __init__(\n        self,\n        event: Event,\n        source: State,\n        destination: State,\n        criteria: Optional[Callable[..., bool]] = None,\n        action: Optional[Callable[..., None]] = None,\n    ) -&gt; None:\n        \"\"\"\n        Transition class that handles state transitions in a finite state machine.\n        A transition connects a source state to a destination state and is triggered by an event.\n        It should include criteria that must be met for the transition to occur and actions to execute\n        during the transition.\n\n        Args:\n            event: The event that triggers this transition\n            source: The source state\n            destination: The destination state\n            criteria: Optional function that returns True if transition should occur\n            action: Optional function to execute during transition\n\n        Example:\n            &gt;&gt;&gt; transition = Transition(\n            ...     event=Event(\"walk\"),\n            ...     source=State(\"idle\"),\n            ...     destination=State(\"walking\"),\n            ...     criteria=lambda: True,\n            ...     action=lambda: print(\"Walking\")\n            ... )\n        \"\"\"\n        self._event: Event = event\n        self._source_state: State = source\n        self._destination_state: State = destination\n\n        self._criteria: Optional[Callable[..., bool]] = criteria\n        self._action: Optional[Callable[..., None]] = action\n\n    def __call__(self, **kwargs: Any) -&gt; State:\n        if not self._criteria:\n            criteria_met = True\n        else:\n            try:\n                import inspect\n\n                # Filter kwargs to only include parameters the function expects\n                criteria_params = inspect.signature(self._criteria).parameters\n                filtered_kwargs = {k: v for k, v in kwargs.items() if k in criteria_params}\n\n                criteria_met = self._criteria(**filtered_kwargs)\n            except Exception as e:\n                LOGGER.warning(f\"Failed to call criteria function for transition {self}: {e}\")\n                return self._source_state\n\n        if criteria_met:\n            if self._action:\n                try:\n                    import inspect\n\n                    # Filter kwargs to only include parameters the function expects\n                    action_params = inspect.signature(self._action).parameters\n                    filtered_kwargs = {k: v for k, v in kwargs.items() if k in action_params}\n\n                    self._action(**filtered_kwargs)\n                except Exception as e:\n                    LOGGER.warning(f\"Failed to call action function for transition {self}: {e}\")\n\n            self._source_state.exit(**kwargs)\n            self._destination_state.enter(**kwargs)\n\n            return self._destination_state\n        else:\n            return self._source_state\n\n    def __repr__(self) -&gt; str:\n        return f\"Transition[{self._source_state.name} -&gt; {self._destination_state.name}]\"\n\n    def add_criteria(self, callback: Callable[[Any], bool]) -&gt; None:\n        \"\"\"\n        Add a criteria function to the transition.\n\n        Args:\n            callback: Function that returns True if transition should occur\n\n        Example:\n            &gt;&gt;&gt; transition.add_criteria(lambda: if t &gt; 0: True)\n        \"\"\"\n        self._criteria = callback\n\n    def add_action(self, callback: Callable[[Any], Any]) -&gt; None:\n        \"\"\"\n        Add an action function to the transition.\n\n        Args:\n            callback: Function to execute during transition\n\n        Example:\n            &gt;&gt;&gt; transition.add_action(lambda: print(\"Walking\"))\n        \"\"\"\n        self._action = callback\n\n    @property\n    def event(self) -&gt; Event:\n        \"\"\"\n        Get the event that triggers this transition.\n\n        Returns:\n            Event: The event that triggers this transition\n        \"\"\"\n        return self._event\n\n    @property\n    def source_state(self) -&gt; State:\n        \"\"\"\n        Get the source state of this transition.\n\n        Returns:\n            State: The source state of this transition\n        \"\"\"\n        return self._source_state\n\n    @property\n    def destination_state(self) -&gt; State:\n        \"\"\"\n        Get the destination state of this transition.\n\n        Returns:\n            State: The destination state of this transition\n        \"\"\"\n        return self._destination_state\n</code></pre>"},{"location":"api/control/fsm/#opensourceleg.control.fsm.Transition.destination_state","title":"<code>destination_state</code>  <code>property</code>","text":"<p>Get the destination state of this transition.</p> <p>Returns:</p> Name Type Description <code>State</code> <code>State</code> <p>The destination state of this transition</p>"},{"location":"api/control/fsm/#opensourceleg.control.fsm.Transition.event","title":"<code>event</code>  <code>property</code>","text":"<p>Get the event that triggers this transition.</p> <p>Returns:</p> Name Type Description <code>Event</code> <code>Event</code> <p>The event that triggers this transition</p>"},{"location":"api/control/fsm/#opensourceleg.control.fsm.Transition.source_state","title":"<code>source_state</code>  <code>property</code>","text":"<p>Get the source state of this transition.</p> <p>Returns:</p> Name Type Description <code>State</code> <code>State</code> <p>The source state of this transition</p>"},{"location":"api/control/fsm/#opensourceleg.control.fsm.Transition.__init__","title":"<code>__init__(event, source, destination, criteria=None, action=None)</code>","text":"<p>Transition class that handles state transitions in a finite state machine. A transition connects a source state to a destination state and is triggered by an event. It should include criteria that must be met for the transition to occur and actions to execute during the transition.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Event</code> <p>The event that triggers this transition</p> required <code>source</code> <code>State</code> <p>The source state</p> required <code>destination</code> <code>State</code> <p>The destination state</p> required <code>criteria</code> <code>Optional[Callable[..., bool]]</code> <p>Optional function that returns True if transition should occur</p> <code>None</code> <code>action</code> <code>Optional[Callable[..., None]]</code> <p>Optional function to execute during transition</p> <code>None</code> Example <p>transition = Transition( ...     event=Event(\"walk\"), ...     source=State(\"idle\"), ...     destination=State(\"walking\"), ...     criteria=lambda: True, ...     action=lambda: print(\"Walking\") ... )</p> Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>def __init__(\n    self,\n    event: Event,\n    source: State,\n    destination: State,\n    criteria: Optional[Callable[..., bool]] = None,\n    action: Optional[Callable[..., None]] = None,\n) -&gt; None:\n    \"\"\"\n    Transition class that handles state transitions in a finite state machine.\n    A transition connects a source state to a destination state and is triggered by an event.\n    It should include criteria that must be met for the transition to occur and actions to execute\n    during the transition.\n\n    Args:\n        event: The event that triggers this transition\n        source: The source state\n        destination: The destination state\n        criteria: Optional function that returns True if transition should occur\n        action: Optional function to execute during transition\n\n    Example:\n        &gt;&gt;&gt; transition = Transition(\n        ...     event=Event(\"walk\"),\n        ...     source=State(\"idle\"),\n        ...     destination=State(\"walking\"),\n        ...     criteria=lambda: True,\n        ...     action=lambda: print(\"Walking\")\n        ... )\n    \"\"\"\n    self._event: Event = event\n    self._source_state: State = source\n    self._destination_state: State = destination\n\n    self._criteria: Optional[Callable[..., bool]] = criteria\n    self._action: Optional[Callable[..., None]] = action\n</code></pre>"},{"location":"api/control/fsm/#opensourceleg.control.fsm.Transition.add_action","title":"<code>add_action(callback)</code>","text":"<p>Add an action function to the transition.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[Any], Any]</code> <p>Function to execute during transition</p> required Example <p>transition.add_action(lambda: print(\"Walking\"))</p> Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>def add_action(self, callback: Callable[[Any], Any]) -&gt; None:\n    \"\"\"\n    Add an action function to the transition.\n\n    Args:\n        callback: Function to execute during transition\n\n    Example:\n        &gt;&gt;&gt; transition.add_action(lambda: print(\"Walking\"))\n    \"\"\"\n    self._action = callback\n</code></pre>"},{"location":"api/control/fsm/#opensourceleg.control.fsm.Transition.add_criteria","title":"<code>add_criteria(callback)</code>","text":"<p>Add a criteria function to the transition.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[Any], bool]</code> <p>Function that returns True if transition should occur</p> required Example <p>transition.add_criteria(lambda: if t &gt; 0: True)</p> Source code in <code>opensourceleg/control/fsm.py</code> <pre><code>def add_criteria(self, callback: Callable[[Any], bool]) -&gt; None:\n    \"\"\"\n    Add a criteria function to the transition.\n\n    Args:\n        callback: Function that returns True if transition should occur\n\n    Example:\n        &gt;&gt;&gt; transition.add_criteria(lambda: if t &gt; 0: True)\n    \"\"\"\n    self._criteria = callback\n</code></pre>"},{"location":"api/extras/collections/validators/","title":"Validators","text":"<p>Module for attribute validation using descriptor classes.</p> <p>This module provides an abstract base class <code>Validator</code> for creating attribute validators that can be used as descriptors. It also includes a concrete implementation, <code>Number</code>, which validates that a given value is a number (int or float) and optionally enforces minimum and/or maximum limits.</p>"},{"location":"api/extras/collections/validators/#opensourceleg.extras.collections.validators.Gains","title":"<code>Gains</code>","text":"<p>Example class using the Number validator to validate gain values.</p> <p>The attribute 'kp' is validated to ensure it is a number between 0 and 100.</p> Source code in <code>opensourceleg/extras/collections/validators.py</code> <pre><code>class Gains:\n    \"\"\"\n    Example class using the Number validator to validate gain values.\n\n    The attribute 'kp' is validated to ensure it is a number between 0 and 100.\n    \"\"\"\n\n    kp = Number(0, 100)\n\n    def __init__(self, kp_value: int) -&gt; None:\n        \"\"\"\n        Initialize the Gains instance.\n\n        Args:\n            kp_value (int): The gain value to be validated and assigned to 'kp'.\n        \"\"\"\n        self.kp = kp_value\n</code></pre>"},{"location":"api/extras/collections/validators/#opensourceleg.extras.collections.validators.Gains.__init__","title":"<code>__init__(kp_value)</code>","text":"<p>Initialize the Gains instance.</p> <p>Parameters:</p> Name Type Description Default <code>kp_value</code> <code>int</code> <p>The gain value to be validated and assigned to 'kp'.</p> required Source code in <code>opensourceleg/extras/collections/validators.py</code> <pre><code>def __init__(self, kp_value: int) -&gt; None:\n    \"\"\"\n    Initialize the Gains instance.\n\n    Args:\n        kp_value (int): The gain value to be validated and assigned to 'kp'.\n    \"\"\"\n    self.kp = kp_value\n</code></pre>"},{"location":"api/extras/collections/validators/#opensourceleg.extras.collections.validators.Number","title":"<code>Number</code>","text":"<p>               Bases: <code>Validator</code></p> <p>Validator for numerical values.</p> <p>Ensures that the value is an integer or a float and optionally enforces a minimum and/or maximum limit.</p> Source code in <code>opensourceleg/extras/collections/validators.py</code> <pre><code>class Number(Validator):\n    \"\"\"\n    Validator for numerical values.\n\n    Ensures that the value is an integer or a float and optionally enforces a minimum\n    and/or maximum limit.\n    \"\"\"\n\n    def __init__(\n        self,\n        min_value: Optional[Union[int, float]] = None,\n        max_value: Optional[Union[int, float]] = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the Number validator.\n\n        Args:\n            min_value (Optional[Union[int, float]]): The minimum acceptable value (inclusive).\n                Defaults to None, meaning no lower bound.\n            max_value (Optional[Union[int, float]]): The maximum acceptable value (inclusive).\n                Defaults to None, meaning no upper bound.\n        \"\"\"\n        self.min_value: Optional[Union[int, float]] = min_value\n        self.max_value: Optional[Union[int, float]] = max_value\n\n    def validate(self, value: Union[int, float]) -&gt; None:\n        \"\"\"\n        Validate that the value is a number and within the specified range.\n\n        Args:\n            value (Union[int, float]): The number to validate.\n\n        Raises:\n            TypeError: If the value is not an int or float.\n            ValueError: If the value is less than min_value or greater than max_value.\n        \"\"\"\n        if not isinstance(value, (int, float)):\n            raise TypeError(\"Value must be an int or float\")\n\n        if self.min_value is not None and value &lt; self.min_value:\n            raise ValueError(f\"Value must be at least {self.min_value}\")\n\n        if self.max_value is not None and value &gt; self.max_value:\n            raise ValueError(f\"Value must be at most {self.max_value}\")\n</code></pre>"},{"location":"api/extras/collections/validators/#opensourceleg.extras.collections.validators.Number.__init__","title":"<code>__init__(min_value=None, max_value=None)</code>","text":"<p>Initialize the Number validator.</p> <p>Parameters:</p> Name Type Description Default <code>min_value</code> <code>Optional[Union[int, float]]</code> <p>The minimum acceptable value (inclusive). Defaults to None, meaning no lower bound.</p> <code>None</code> <code>max_value</code> <code>Optional[Union[int, float]]</code> <p>The maximum acceptable value (inclusive). Defaults to None, meaning no upper bound.</p> <code>None</code> Source code in <code>opensourceleg/extras/collections/validators.py</code> <pre><code>def __init__(\n    self,\n    min_value: Optional[Union[int, float]] = None,\n    max_value: Optional[Union[int, float]] = None,\n) -&gt; None:\n    \"\"\"\n    Initialize the Number validator.\n\n    Args:\n        min_value (Optional[Union[int, float]]): The minimum acceptable value (inclusive).\n            Defaults to None, meaning no lower bound.\n        max_value (Optional[Union[int, float]]): The maximum acceptable value (inclusive).\n            Defaults to None, meaning no upper bound.\n    \"\"\"\n    self.min_value: Optional[Union[int, float]] = min_value\n    self.max_value: Optional[Union[int, float]] = max_value\n</code></pre>"},{"location":"api/extras/collections/validators/#opensourceleg.extras.collections.validators.Number.validate","title":"<code>validate(value)</code>","text":"<p>Validate that the value is a number and within the specified range.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Union[int, float]</code> <p>The number to validate.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If the value is not an int or float.</p> <code>ValueError</code> <p>If the value is less than min_value or greater than max_value.</p> Source code in <code>opensourceleg/extras/collections/validators.py</code> <pre><code>def validate(self, value: Union[int, float]) -&gt; None:\n    \"\"\"\n    Validate that the value is a number and within the specified range.\n\n    Args:\n        value (Union[int, float]): The number to validate.\n\n    Raises:\n        TypeError: If the value is not an int or float.\n        ValueError: If the value is less than min_value or greater than max_value.\n    \"\"\"\n    if not isinstance(value, (int, float)):\n        raise TypeError(\"Value must be an int or float\")\n\n    if self.min_value is not None and value &lt; self.min_value:\n        raise ValueError(f\"Value must be at least {self.min_value}\")\n\n    if self.max_value is not None and value &gt; self.max_value:\n        raise ValueError(f\"Value must be at most {self.max_value}\")\n</code></pre>"},{"location":"api/extras/collections/validators/#opensourceleg.extras.collections.validators.Validator","title":"<code>Validator</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for attribute validators.</p> <p>This descriptor class implements the set_name, get, and set methods to automatically manage a private attribute name and to perform validation when setting an attribute's value. Subclasses must implement the validate() method.</p> Source code in <code>opensourceleg/extras/collections/validators.py</code> <pre><code>class Validator(ABC):\n    \"\"\"\n    Abstract base class for attribute validators.\n\n    This descriptor class implements the __set_name__, __get__, and __set__ methods to\n    automatically manage a private attribute name and to perform validation when setting\n    an attribute's value. Subclasses must implement the validate() method.\n    \"\"\"\n\n    def __set_name__(self, owner: Any, name: str) -&gt; None:\n        \"\"\"\n        Automatically called to set the name of the attribute.\n\n        This method is invoked at class creation time to assign a private name\n        to the attribute being managed by the validator.\n\n        Args:\n            owner (Any): The owner class where the descriptor is defined.\n            name (str): The name of the attribute.\n        \"\"\"\n        self.private_name = f\"_{name}\"\n\n    def __get__(self, instance: Any, objtype: Any = None) -&gt; Any:\n        \"\"\"\n        Retrieve the value of the managed attribute.\n\n        Args:\n            instance (Any): The instance from which the attribute is accessed.\n            objtype (Any, optional): The type of the owner class. Defaults to None.\n\n        Returns:\n            Any: The current value of the attribute.\n        \"\"\"\n        return getattr(instance, self.private_name)\n\n    def __set__(self, instance: Any, value: Any) -&gt; None:\n        \"\"\"\n        Set the value of the managed attribute after validating it.\n\n        The method calls the validate() function to ensure that the provided value meets\n        the criteria defined by the validator. If valid, the value is stored under the\n        private attribute name.\n\n        Args:\n            instance (Any): The instance on which the attribute is being set.\n            value (Any): The new value to set.\n\n        Raises:\n            Any: Any exception raised by the validate() method.\n        \"\"\"\n        self.validate(value)\n        setattr(instance, self.private_name, value)\n\n    @abstractmethod\n    def validate(self, value: Any) -&gt; None:\n        \"\"\"\n        Validate the value being assigned to the attribute.\n\n        Subclasses must implement this method to enforce specific validation rules.\n\n        Args:\n            value (Any): The value to validate.\n\n        Raises:\n            Exception: If the value does not meet the validation criteria.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/extras/collections/validators/#opensourceleg.extras.collections.validators.Validator.__get__","title":"<code>__get__(instance, objtype=None)</code>","text":"<p>Retrieve the value of the managed attribute.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Any</code> <p>The instance from which the attribute is accessed.</p> required <code>objtype</code> <code>Any</code> <p>The type of the owner class. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The current value of the attribute.</p> Source code in <code>opensourceleg/extras/collections/validators.py</code> <pre><code>def __get__(self, instance: Any, objtype: Any = None) -&gt; Any:\n    \"\"\"\n    Retrieve the value of the managed attribute.\n\n    Args:\n        instance (Any): The instance from which the attribute is accessed.\n        objtype (Any, optional): The type of the owner class. Defaults to None.\n\n    Returns:\n        Any: The current value of the attribute.\n    \"\"\"\n    return getattr(instance, self.private_name)\n</code></pre>"},{"location":"api/extras/collections/validators/#opensourceleg.extras.collections.validators.Validator.__set__","title":"<code>__set__(instance, value)</code>","text":"<p>Set the value of the managed attribute after validating it.</p> <p>The method calls the validate() function to ensure that the provided value meets the criteria defined by the validator. If valid, the value is stored under the private attribute name.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Any</code> <p>The instance on which the attribute is being set.</p> required <code>value</code> <code>Any</code> <p>The new value to set.</p> required <p>Raises:</p> Type Description <code>Any</code> <p>Any exception raised by the validate() method.</p> Source code in <code>opensourceleg/extras/collections/validators.py</code> <pre><code>def __set__(self, instance: Any, value: Any) -&gt; None:\n    \"\"\"\n    Set the value of the managed attribute after validating it.\n\n    The method calls the validate() function to ensure that the provided value meets\n    the criteria defined by the validator. If valid, the value is stored under the\n    private attribute name.\n\n    Args:\n        instance (Any): The instance on which the attribute is being set.\n        value (Any): The new value to set.\n\n    Raises:\n        Any: Any exception raised by the validate() method.\n    \"\"\"\n    self.validate(value)\n    setattr(instance, self.private_name, value)\n</code></pre>"},{"location":"api/extras/collections/validators/#opensourceleg.extras.collections.validators.Validator.__set_name__","title":"<code>__set_name__(owner, name)</code>","text":"<p>Automatically called to set the name of the attribute.</p> <p>This method is invoked at class creation time to assign a private name to the attribute being managed by the validator.</p> <p>Parameters:</p> Name Type Description Default <code>owner</code> <code>Any</code> <p>The owner class where the descriptor is defined.</p> required <code>name</code> <code>str</code> <p>The name of the attribute.</p> required Source code in <code>opensourceleg/extras/collections/validators.py</code> <pre><code>def __set_name__(self, owner: Any, name: str) -&gt; None:\n    \"\"\"\n    Automatically called to set the name of the attribute.\n\n    This method is invoked at class creation time to assign a private name\n    to the attribute being managed by the validator.\n\n    Args:\n        owner (Any): The owner class where the descriptor is defined.\n        name (str): The name of the attribute.\n    \"\"\"\n    self.private_name = f\"_{name}\"\n</code></pre>"},{"location":"api/extras/collections/validators/#opensourceleg.extras.collections.validators.Validator.validate","title":"<code>validate(value)</code>  <code>abstractmethod</code>","text":"<p>Validate the value being assigned to the attribute.</p> <p>Subclasses must implement this method to enforce specific validation rules.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to validate.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If the value does not meet the validation criteria.</p> Source code in <code>opensourceleg/extras/collections/validators.py</code> <pre><code>@abstractmethod\ndef validate(self, value: Any) -&gt; None:\n    \"\"\"\n    Validate the value being assigned to the attribute.\n\n    Subclasses must implement this method to enforce specific validation rules.\n\n    Args:\n        value (Any): The value to validate.\n\n    Raises:\n        Exception: If the value does not meet the validation criteria.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/extras/safety/safety/","title":"Safety","text":""},{"location":"api/extras/safety/safety/#opensourceleg.extras.safety.SafetyDecorators","title":"<code>SafetyDecorators</code>  <code>dataclass</code>","text":"<p>Dataclass that contains all safety decorators.</p> <p>Attributes:</p> Name Type Description <code>is_changing</code> <p>Decorator to check if a property's value is changing.</p> <code>is_negative</code> <p>Decorator to check if a property's value is negative.</p> <code>is_positive</code> <p>Decorator to check if a property's value is positive.</p> <code>is_zero</code> <p>Decorator to check if a property's value is zero.</p> <code>is_within_range</code> <p>Decorator to check if a property's value is within a given range.</p> <code>is_greater_than</code> <p>Decorator to check if a property's value is greater than a given value.</p> <code>is_less_than</code> <p>Decorator to check if a property's value is less than a given value.</p> <code>custom_criteria</code> <p>Decorator to check if a property's value meets a custom criteria.</p> Source code in <code>opensourceleg/extras/safety/safety.py</code> <pre><code>@dataclass\nclass SafetyDecorators:\n    \"\"\"\n    Dataclass that contains all safety decorators.\n\n    Attributes:\n        is_changing: Decorator to check if a property's value is changing.\n        is_negative: Decorator to check if a property's value is negative.\n        is_positive: Decorator to check if a property's value is positive.\n        is_zero: Decorator to check if a property's value is zero.\n        is_within_range: Decorator to check if a property's value is within a given range.\n        is_greater_than: Decorator to check if a property's value is greater than a given value.\n        is_less_than: Decorator to check if a property's value is less than a given value.\n        custom_criteria: Decorator to check if a property's value meets a custom criteria.\n    \"\"\"\n\n    is_changing = is_changing\n    is_negative = is_negative\n    is_positive = is_positive\n    is_zero = is_zero\n    is_within_range = is_within_range\n    is_greater_than = is_greater_than\n    is_less_than = is_less_than\n    custom_criteria = custom_criteria\n</code></pre>"},{"location":"api/extras/safety/safety/#opensourceleg.extras.safety.SafetyManager","title":"<code>SafetyManager</code>","text":"<p>The SafetyManager class enables the addition of safety decorators to an object's properties, specifically to their getters. When the 'start' method is invoked, these decorators are applied to the properties of the objects stored in the 'safe_objects' dictionary. The original objects are then replaced with subclasses that incorporate the decorated properties. Invoking the 'update' method accesses the properties of the objects in the 'safe_objects' dictionary, thereby triggering the decorators.</p> Source code in <code>opensourceleg/extras/safety/safety.py</code> <pre><code>class SafetyManager:\n    \"\"\"\n    The SafetyManager class enables the addition of safety decorators to an object's properties,\n    specifically to their getters. When the 'start' method is invoked, these decorators are applied\n    to the properties of the objects stored in the 'safe_objects' dictionary. The original objects\n    are then replaced with subclasses that incorporate the decorated properties.\n    Invoking the 'update' method accesses the properties of the objects in the 'safe_objects' dictionary,\n    thereby triggering the decorators.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self._safe_objects: dict[object, dict[str, list[Callable]]] = {}\n        self._original_classes: dict[object, type] = {}  # NEW: Track original classes before modification\n\n    def add_safety(self, instance: object, attribute: str, decorator: Callable) -&gt; None:\n        \"\"\"\n        Adds a safety decorator to the given object's attribute. The decorator will be applied to the property's getter.\n\n        Args:\n            instance (object): Object that contains the attribute.\n            attribute (str): Name of the attribute.\n            decorator (Callable): Safety decorator to be applied to the attribute.\n\n        Raises:\n            AttributeError: If the attribute does not exist in the given object.\n            Warning: If the attribute is not a property. The SafetyManager only works on properties.\n        \"\"\"\n\n        if not hasattr(instance, attribute):\n            print(f\"Error: The attribute '{attribute}' does not exist in the given object.\")\n            return\n\n        original_attribute = getattr(instance.__class__, attribute, None)\n        if not isinstance(original_attribute, property):\n            print(\n                f\"Warning: The attribute '{attribute}' is not a property. The SafetyManager only works on properties.\"\n            )\n            return\n\n        if instance in self._safe_objects:\n            if attribute in self._safe_objects[instance]:\n                self._safe_objects[instance][attribute].append(decorator)\n            else:\n                self._safe_objects[instance][attribute] = [decorator]\n        else:\n            self._safe_objects[instance] = {attribute: [decorator]}\n\n    def start(self) -&gt; None:\n        \"\"\"\n        Applies all decorators to the properties of the objects in the safe_objects dictionary.\n\n        Example:\n        &gt;&gt;&gt; safety_manager = SafetyManager()\n        &gt;&gt;&gt; safety_manager.add_safety(sensor, \"value\", SafetyDecorators.is_changing(\"value\"))\n        &gt;&gt;&gt; safety_manager.add_safety(sensor, \"a\", SafetyDecorators.is_positive())\n        &gt;&gt;&gt; safety_manager.start()\n        \"\"\"\n        for container, safe_attributes in self.safe_objects.items():\n            if container not in self._original_classes:\n                self._original_classes[container] = container.__class__\n            container_subclass = type(f\"{container.__class__.__name__}:SAFE\", (container.__class__,), {})\n            for attribute_name, attribute_decorators in safe_attributes.items():\n                original_property = getattr(container.__class__, attribute_name)\n                decorated_getter = original_property.fget\n                for attribute_decorator in reversed(attribute_decorators):\n                    decorated_getter = attribute_decorator(decorated_getter)\n\n                setattr(\n                    container_subclass,\n                    attribute_name,\n                    property(decorated_getter, original_property.fset, original_property.fdel),\n                )\n\n            container.__class__ = container_subclass\n\n    def stop(self) -&gt; None:\n        \"\"\"\n        Restores the original classes of the objects, thereby removing the applied safety decorators.\n        \"\"\"\n        for container, original_class in self._original_classes.items():\n            container.__class__ = original_class\n        self._original_classes.clear()\n\n    def update(self) -&gt; None:\n        \"\"\"\n        Accesses the properties of the objects in the safe_objects dictionary, thereby triggering the decorators.\n\n        Example:\n        TODO: Add example\n        \"\"\"\n        for container, safe_attributes in self.safe_objects.items():\n            for attribute_name, _ in safe_attributes.items():\n                getattr(container, attribute_name)\n\n    @property\n    def safe_objects(self) -&gt; dict[object, dict[str, list[Callable]]]:\n        return self._safe_objects\n\n    def with_safety(self) -&gt; \"SafetyManager.SafetyContext\":\n        \"\"\"\n        Context manager for enabling safety on entry, and disabling on exit.\n        Usage:\n            with safety_manager.with_safety():\n                # safety checks active\n                ...\n            # safety checks stopped\n        \"\"\"\n        return SafetyManager.SafetyContext(self)\n\n    class SafetyContext:\n        \"\"\"\n        Context manager for enabling/disabling safety checks using 'with' context.\n        \"\"\"\n\n        def __init__(self, safety_manager: \"SafetyManager\") -&gt; None:\n            self.safety_manager = safety_manager\n\n        def __enter__(self) -&gt; \"SafetyManager.SafetyContext\":\n            self.safety_manager.start()  # Calls start() on enter\n            return self\n\n        def __exit__(\n            self,\n            exc_type: Optional[type[BaseException]],\n            exc_val: Optional[BaseException],\n            exc_tb: Optional[Any],\n        ) -&gt; None:\n            self.safety_manager.stop()  # Calls stop() on exit\n</code></pre>"},{"location":"api/extras/safety/safety/#opensourceleg.extras.safety.SafetyManager.SafetyContext","title":"<code>SafetyContext</code>","text":"<p>Context manager for enabling/disabling safety checks using 'with' context.</p> Source code in <code>opensourceleg/extras/safety/safety.py</code> <pre><code>class SafetyContext:\n    \"\"\"\n    Context manager for enabling/disabling safety checks using 'with' context.\n    \"\"\"\n\n    def __init__(self, safety_manager: \"SafetyManager\") -&gt; None:\n        self.safety_manager = safety_manager\n\n    def __enter__(self) -&gt; \"SafetyManager.SafetyContext\":\n        self.safety_manager.start()  # Calls start() on enter\n        return self\n\n    def __exit__(\n        self,\n        exc_type: Optional[type[BaseException]],\n        exc_val: Optional[BaseException],\n        exc_tb: Optional[Any],\n    ) -&gt; None:\n        self.safety_manager.stop()  # Calls stop() on exit\n</code></pre>"},{"location":"api/extras/safety/safety/#opensourceleg.extras.safety.SafetyManager.add_safety","title":"<code>add_safety(instance, attribute, decorator)</code>","text":"<p>Adds a safety decorator to the given object's attribute. The decorator will be applied to the property's getter.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>object</code> <p>Object that contains the attribute.</p> required <code>attribute</code> <code>str</code> <p>Name of the attribute.</p> required <code>decorator</code> <code>Callable</code> <p>Safety decorator to be applied to the attribute.</p> required <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the attribute does not exist in the given object.</p> <code>Warning</code> <p>If the attribute is not a property. The SafetyManager only works on properties.</p> Source code in <code>opensourceleg/extras/safety/safety.py</code> <pre><code>def add_safety(self, instance: object, attribute: str, decorator: Callable) -&gt; None:\n    \"\"\"\n    Adds a safety decorator to the given object's attribute. The decorator will be applied to the property's getter.\n\n    Args:\n        instance (object): Object that contains the attribute.\n        attribute (str): Name of the attribute.\n        decorator (Callable): Safety decorator to be applied to the attribute.\n\n    Raises:\n        AttributeError: If the attribute does not exist in the given object.\n        Warning: If the attribute is not a property. The SafetyManager only works on properties.\n    \"\"\"\n\n    if not hasattr(instance, attribute):\n        print(f\"Error: The attribute '{attribute}' does not exist in the given object.\")\n        return\n\n    original_attribute = getattr(instance.__class__, attribute, None)\n    if not isinstance(original_attribute, property):\n        print(\n            f\"Warning: The attribute '{attribute}' is not a property. The SafetyManager only works on properties.\"\n        )\n        return\n\n    if instance in self._safe_objects:\n        if attribute in self._safe_objects[instance]:\n            self._safe_objects[instance][attribute].append(decorator)\n        else:\n            self._safe_objects[instance][attribute] = [decorator]\n    else:\n        self._safe_objects[instance] = {attribute: [decorator]}\n</code></pre>"},{"location":"api/extras/safety/safety/#opensourceleg.extras.safety.SafetyManager.start","title":"<code>start()</code>","text":"<p>Applies all decorators to the properties of the objects in the safe_objects dictionary.</p> <p>Example:</p> <p>safety_manager = SafetyManager() safety_manager.add_safety(sensor, \"value\", SafetyDecorators.is_changing(\"value\")) safety_manager.add_safety(sensor, \"a\", SafetyDecorators.is_positive()) safety_manager.start()</p> Source code in <code>opensourceleg/extras/safety/safety.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"\n    Applies all decorators to the properties of the objects in the safe_objects dictionary.\n\n    Example:\n    &gt;&gt;&gt; safety_manager = SafetyManager()\n    &gt;&gt;&gt; safety_manager.add_safety(sensor, \"value\", SafetyDecorators.is_changing(\"value\"))\n    &gt;&gt;&gt; safety_manager.add_safety(sensor, \"a\", SafetyDecorators.is_positive())\n    &gt;&gt;&gt; safety_manager.start()\n    \"\"\"\n    for container, safe_attributes in self.safe_objects.items():\n        if container not in self._original_classes:\n            self._original_classes[container] = container.__class__\n        container_subclass = type(f\"{container.__class__.__name__}:SAFE\", (container.__class__,), {})\n        for attribute_name, attribute_decorators in safe_attributes.items():\n            original_property = getattr(container.__class__, attribute_name)\n            decorated_getter = original_property.fget\n            for attribute_decorator in reversed(attribute_decorators):\n                decorated_getter = attribute_decorator(decorated_getter)\n\n            setattr(\n                container_subclass,\n                attribute_name,\n                property(decorated_getter, original_property.fset, original_property.fdel),\n            )\n\n        container.__class__ = container_subclass\n</code></pre>"},{"location":"api/extras/safety/safety/#opensourceleg.extras.safety.SafetyManager.stop","title":"<code>stop()</code>","text":"<p>Restores the original classes of the objects, thereby removing the applied safety decorators.</p> Source code in <code>opensourceleg/extras/safety/safety.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"\n    Restores the original classes of the objects, thereby removing the applied safety decorators.\n    \"\"\"\n    for container, original_class in self._original_classes.items():\n        container.__class__ = original_class\n    self._original_classes.clear()\n</code></pre>"},{"location":"api/extras/safety/safety/#opensourceleg.extras.safety.SafetyManager.update","title":"<code>update()</code>","text":"<p>Accesses the properties of the objects in the safe_objects dictionary, thereby triggering the decorators.</p> <p>Example: TODO: Add example</p> Source code in <code>opensourceleg/extras/safety/safety.py</code> <pre><code>def update(self) -&gt; None:\n    \"\"\"\n    Accesses the properties of the objects in the safe_objects dictionary, thereby triggering the decorators.\n\n    Example:\n    TODO: Add example\n    \"\"\"\n    for container, safe_attributes in self.safe_objects.items():\n        for attribute_name, _ in safe_attributes.items():\n            getattr(container, attribute_name)\n</code></pre>"},{"location":"api/extras/safety/safety/#opensourceleg.extras.safety.SafetyManager.with_safety","title":"<code>with_safety()</code>","text":"<p>Context manager for enabling safety on entry, and disabling on exit. Usage:     with safety_manager.with_safety():         # safety checks active         ...     # safety checks stopped</p> Source code in <code>opensourceleg/extras/safety/safety.py</code> <pre><code>def with_safety(self) -&gt; \"SafetyManager.SafetyContext\":\n    \"\"\"\n    Context manager for enabling safety on entry, and disabling on exit.\n    Usage:\n        with safety_manager.with_safety():\n            # safety checks active\n            ...\n        # safety checks stopped\n    \"\"\"\n    return SafetyManager.SafetyContext(self)\n</code></pre>"},{"location":"api/extras/safety/safety/#opensourceleg.extras.safety.custom_criteria","title":"<code>custom_criteria(criteria)</code>","text":"<p>Creates a decorator to check if a property's value meets a custom criteria. The criteria is a function that takes the property's value as an argument and returns a boolean.</p> <p>Parameters:</p> Name Type Description Default <code>criteria</code> <code>Callable</code> <p>Custom criteria function.</p> required <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable</code> <p>Decorator function.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the property's value does not meet the custom criteria.</p> Source code in <code>opensourceleg/extras/safety/safety.py</code> <pre><code>def custom_criteria(criteria: Callable) -&gt; Callable:\n    \"\"\"\n    Creates a decorator to check if a property's value meets a custom criteria. The criteria is a\n    function that takes the property's value as an argument and returns a boolean.\n\n    Args:\n        criteria (Callable): Custom criteria function.\n\n    Returns:\n        Callable: Decorator function.\n\n    Raises:\n        ValueError: If the property's value does not meet the custom criteria.\n    \"\"\"\n\n    def decorator(func: Callable) -&gt; Callable:\n        def wrapper(instance: object, *args: Any, **kwargs: Any) -&gt; Any:\n            value = func(instance, *args, **kwargs)\n            if not criteria(value):\n                raise ValueError(\"Value does not meet custom criteria\")\n            return value\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"api/extras/safety/safety/#opensourceleg.extras.safety.is_changing","title":"<code>is_changing(attribute_name, max_points=10, threshold=1e-06, proxy_attribute_name=None)</code>","text":"<p>Creates a decorator to check if a property's value is changing. If the standard deviation of the last 'max_points' values is less than 'threshold', the decorator will raise an error or return a proxy attribute.</p> <p>Parameters:</p> Name Type Description Default <code>attribute_name</code> <code>str</code> <p>Name of the attribute.</p> required <code>max_points</code> <code>int</code> <p>Number of points to consider. Defaults to 10.</p> <code>10</code> <code>threshold</code> <code>float</code> <p>Threshold for the standard deviation. Defaults to 1e-6.</p> <code>1e-06</code> <code>proxy_attribute_name</code> <code>Optional[str]</code> <p>Name of the proxy attribute to return if the property is not changing. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable</code> <p>Decorator function.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the property is not changing and no proxy attribute is provided.</p> Source code in <code>opensourceleg/extras/safety/safety.py</code> <pre><code>def is_changing(\n    attribute_name: str,\n    max_points: int = 10,\n    threshold: float = 1e-6,\n    proxy_attribute_name: Optional[str] = None,\n) -&gt; Callable:\n    \"\"\"\n    Creates a decorator to check if a property's value is changing.\n    If the standard deviation of the last 'max_points' values is less than 'threshold',\n    the decorator will raise an error or return a proxy attribute.\n\n    Args:\n        attribute_name: Name of the attribute.\n        max_points: Number of points to consider. Defaults to 10.\n        threshold: Threshold for the standard deviation. Defaults to 1e-6.\n        proxy_attribute_name: Name of the proxy attribute to return if the property is not changing. Defaults to None.\n\n    Returns:\n        Callable: Decorator function.\n\n    Raises:\n        ValueError: If the property is not changing and no proxy attribute is provided.\n\n    \"\"\"\n\n    history_key = f\"_{attribute_name}_history\"\n    proxy_key = f\"_{attribute_name}_proxy\"\n\n    def decorator(func: Callable) -&gt; Callable:\n        def wrapper(instance: object, *args: Any, **kwargs: Any) -&gt; Any:\n            instance.__dict__.setdefault(history_key, deque(maxlen=max_points))\n\n            if proxy_attribute_name is not None and getattr(instance, proxy_key):\n                return getattr(instance, proxy_attribute_name)\n\n            value = func(instance, *args, **kwargs)\n            history = getattr(instance, history_key)\n            history.append(value)\n            if len(history) == max_points:\n                current_std = np.std(list(history))\n                if current_std &lt; threshold:\n                    if proxy_attribute_name is not None:\n                        print(f\"{attribute_name} isn't changing, returning {proxy_attribute_name}\")\n                        if not hasattr(instance, proxy_key):\n                            setattr(instance, proxy_key, True)\n                        return getattr(instance, proxy_attribute_name)\n                    else:\n                        raise ValueError(f\"{attribute_name} is not changing\")\n            return value\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"api/extras/safety/safety/#opensourceleg.extras.safety.is_greater_than","title":"<code>is_greater_than(min_value, clamp=False, equality=False)</code>","text":"<p>Creates a decorator to check if a property's value is greater than a given value. Gives user choice to implement is_greater_than_or_equal_to with equality bool</p> <p>Parameters:</p> Name Type Description Default <code>min_value</code> <code>float</code> <p>Minimum value to check against.</p> required <code>clamp</code> <code>bool</code> <p>If True, the decorator will return the clamped value instead of raising an error. Defaults to False.</p> <code>False</code> <code>equality</code> <code>bool</code> <p>If True, the decorator will check for is greater than or equal to, instead of is greater than.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable</code> <p>Decorator function.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the property's value is less than or equal to the minimum value</p> Source code in <code>opensourceleg/extras/safety/safety.py</code> <pre><code>def is_greater_than(min_value: float, clamp: bool = False, equality: bool = False) -&gt; Callable:\n    \"\"\"\n    Creates a decorator to check if a property's value is greater than a given value. Gives user\n    choice to implement is_greater_than_or_equal_to with equality bool\n\n    Args:\n        min_value: Minimum value to check against.\n        clamp: If True, the decorator will return the clamped value instead of raising an error. Defaults to False.\n        equality: If True, the decorator will check for is greater than or equal to, instead of is greater than.\n\n    Returns:\n        Callable: Decorator function.\n\n    Raises:\n        ValueError: If the property's value is less than or equal to the minimum value\n    \"\"\"\n\n    def decorator(func: Callable) -&gt; Callable:\n        def wrapper(instance: object, *args: Any, **kwargs: Any) -&gt; Any:\n            value = func(instance, *args, **kwargs)\n            if equality:\n                if value &lt; min_value:\n                    if clamp:\n                        return min_value\n                    raise ValueError(f\"Value must be greater than or equal to {min_value}\")\n            else:\n                if value &lt;= min_value:\n                    if clamp:\n                        return min_value\n                    raise ValueError(f\"Value must be greater than {min_value}\")\n            return value\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"api/extras/safety/safety/#opensourceleg.extras.safety.is_less_than","title":"<code>is_less_than(max_value, clamp=False, equality=False)</code>","text":"<p>Creates a decorator to check if a property's value is less than a given value. Gives user choice to implement is_less_than_or_equal_to with equality bool</p> <p>Parameters:</p> Name Type Description Default <code>max_value</code> <code>float</code> <p>Maximum value to check against.</p> required <code>clamp</code> <code>bool</code> <p>If True, the decorator will return the clamped value instead of raising an error. Defaults to False.</p> <code>False</code> <code>equality</code> <code>bool</code> <p>If True, the decorator will check for is less than or equal to, instead of is less than.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable</code> <p>Decorator function.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the property's value is greater than or equal to the maximum value</p> Source code in <code>opensourceleg/extras/safety/safety.py</code> <pre><code>def is_less_than(max_value: float, clamp: bool = False, equality: bool = False) -&gt; Callable:\n    \"\"\"\n    Creates a decorator to check if a property's value is less than a given value. Gives user\n    choice to implement is_less_than_or_equal_to with equality bool\n\n    Args:\n        max_value: Maximum value to check against.\n        clamp: If True, the decorator will return the clamped value instead of raising an error. Defaults to False.\n        equality: If True, the decorator will check for is less than or equal to, instead of is less than.\n\n    Returns:\n        Callable: Decorator function.\n\n    Raises:\n        ValueError: If the property's value is greater than or equal to the maximum value\n    \"\"\"\n\n    def decorator(func: Callable) -&gt; Callable:\n        def wrapper(instance: object, *args: Any, **kwargs: Any) -&gt; Any:\n            value = func(instance, *args, **kwargs)\n            if equality:\n                if value &gt; max_value:\n                    if clamp:\n                        return max_value\n                    raise ValueError(f\"Value must be less than or equal to {max_value}\")\n            else:\n                if value &gt;= max_value:\n                    if clamp:\n                        return max_value\n                    raise ValueError(f\"Value must be less than {max_value}\")\n            return value\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"api/extras/safety/safety/#opensourceleg.extras.safety.is_negative","title":"<code>is_negative(clamp=False)</code>","text":"<p>Creates a decorator to check if a property's value is negative.</p> <p>Parameters:</p> Name Type Description Default <code>clamp</code> <code>bool</code> <p>If True, the decorator will return 0 instead of raising an error. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable</code> <p>Decorator function.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the property's value is not negative.</p> Source code in <code>opensourceleg/extras/safety/safety.py</code> <pre><code>def is_negative(clamp: bool = False) -&gt; Callable:\n    \"\"\"\n    Creates a decorator to check if a property's value is negative.\n\n    Args:\n        clamp (bool): If True, the decorator will return 0 instead of raising an error. Defaults to False.\n\n    Returns:\n        Callable: Decorator function.\n\n    Raises:\n        ValueError: If the property's value is not negative.\n    \"\"\"\n\n    def decorator(func: Callable) -&gt; Callable:\n        def wrapper(instance: object, *args: Any, **kwargs: Any) -&gt; Any:\n            value = func(instance, *args, **kwargs)\n            if value &gt;= 0:\n                if clamp:\n                    return 0\n                raise ValueError(\"Value must be negative\")\n            return value\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"api/extras/safety/safety/#opensourceleg.extras.safety.is_positive","title":"<code>is_positive(clamp=False)</code>","text":"<p>Creates a decorator to check if a property's value is positive.</p> <p>Parameters:</p> Name Type Description Default <code>clamp</code> <code>bool</code> <p>If True, the decorator will return 0 instead of raising an error. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable</code> <p>Decorator function.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the property's value is not positive.</p> Source code in <code>opensourceleg/extras/safety/safety.py</code> <pre><code>def is_positive(clamp: bool = False) -&gt; Callable:\n    \"\"\"\n    Creates a decorator to check if a property's value is positive.\n\n    Args:\n        clamp (bool): If True, the decorator will return 0 instead of raising an error. Defaults to False.\n\n    Returns:\n        Callable: Decorator function.\n\n    Raises:\n        ValueError: If the property's value is not positive.\n    \"\"\"\n\n    def decorator(func: Callable) -&gt; Callable:\n        def wrapper(instance: object, *args: Any, **kwargs: Any) -&gt; Any:\n            value = func(instance, *args, **kwargs)\n            if value &lt;= 0:\n                if clamp:\n                    return 0\n                raise ValueError(\"Value must be positive\")\n            return value\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"api/extras/safety/safety/#opensourceleg.extras.safety.is_within_range","title":"<code>is_within_range(min_value, max_value, clamp=False)</code>","text":"<p>Creates a decorator to check if a property's value is within a given range.</p> <p>Parameters:</p> Name Type Description Default <code>min_value</code> <code>float</code> <p>Minimum value of the range.</p> required <code>max_value</code> <code>float</code> <p>Maximum value of the range.</p> required <code>clamp</code> <code>bool</code> <p>If True, the decorator will return the clamped value instead of raising an error. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the maximum value is less than or equal to the minimum value.</p> <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable</code> <p>Decorator function.</p> Source code in <code>opensourceleg/extras/safety/safety.py</code> <pre><code>def is_within_range(min_value: float, max_value: float, clamp: bool = False) -&gt; Callable:\n    \"\"\"\n    Creates a decorator to check if a property's value is within a given range.\n\n    Args:\n        min_value: Minimum value of the range.\n        max_value: Maximum value of the range.\n        clamp: If True, the decorator will return the clamped value instead of raising an error. Defaults to False.\n\n    Raises:\n        ValueError: If the maximum value is less than or equal to the minimum value.\n\n    Returns:\n        Callable: Decorator function.\n    \"\"\"\n\n    if max_value &lt;= min_value:\n        raise ValueError(\"Maximum value must be greater than minimum value of range\")\n\n    def decorator(func: Callable) -&gt; Callable:\n        def wrapper(instance: object, *args: Any, **kwargs: Any) -&gt; Any:\n            value = func(instance, *args, **kwargs)\n            if value &lt; min_value or value &gt; max_value:\n                if clamp:\n                    return min(max_value, max(min_value, value))\n                raise ValueError(f\"Value must be within {min_value} and {max_value}\")\n            return value\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"api/extras/safety/safety/#opensourceleg.extras.safety.is_zero","title":"<code>is_zero(clamp=False)</code>","text":"<p>Creates a decorator to check if a property's value is zero.</p> <p>Parameters:</p> Name Type Description Default <code>clamp</code> <code>bool</code> <p>If True, the decorator will return 0 instead of raising an error. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable</code> <p>Decorator function.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the property's value is not zero.</p> Source code in <code>opensourceleg/extras/safety/safety.py</code> <pre><code>def is_zero(clamp: bool = False) -&gt; Callable:\n    \"\"\"\n    Creates a decorator to check if a property's value is zero.\n\n    Args:\n        clamp (bool): If True, the decorator will return 0 instead of raising an error. Defaults to False.\n\n    Returns:\n        Callable: Decorator function.\n\n    Raises:\n        ValueError: If the property's value is not zero.\n    \"\"\"\n\n    def decorator(func: Callable) -&gt; Callable:\n        def wrapper(instance: object, *args: Any, **kwargs: Any) -&gt; Any:\n            value = func(instance, *args, **kwargs)\n            if value != 0:\n                if clamp:\n                    return 0\n                raise ValueError(\"Value must be zero\")\n            return value\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"api/math/math/","title":"Math","text":""},{"location":"api/math/math/#opensourceleg.math.math.Counter","title":"<code>Counter</code>","text":"<p>A simple counter class that increments a counter each time the increment_counter argument is set true. To reset the counter, call update with increment_counter set to false.</p> <p>Author: Kevin Best, 9/25/2024 https://github.com/tkevinbest</p> Source code in <code>opensourceleg/math/math.py</code> <pre><code>class Counter:\n    \"\"\"\n    A simple counter class that increments a counter each time the increment_counter argument is set true.\n    To reset the counter, call update with increment_counter set to false.\n\n    Author: Kevin Best, 9/25/2024\n    https://github.com/tkevinbest\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self._count: int = 0\n\n    def update(self, increment_counter: bool) -&gt; None:\n        if increment_counter:\n            self._count += 1\n        else:\n            self._count = 0\n\n    @property\n    def current_count(self) -&gt; int:\n        \"\"\"Returns the current count\"\"\"\n        return self._count\n</code></pre>"},{"location":"api/math/math/#opensourceleg.math.math.Counter.current_count","title":"<code>current_count</code>  <code>property</code>","text":"<p>Returns the current count</p>"},{"location":"api/math/math/#opensourceleg.math.math.EdgeDetector","title":"<code>EdgeDetector</code>","text":"<p>Used to calculate rising and falling edges of a digital signal in real time. Call edgeDetector.update(digitalSignal) to update the detector. Then read edgeDetector.rising_edge or falling edge to know if the event occurred.</p> <p>Author: Kevin Best https://github.com/tkevinbest</p> Source code in <code>opensourceleg/math/math.py</code> <pre><code>class EdgeDetector:\n    \"\"\"\n    Used to calculate rising and falling edges of a digital signal in real time.\n    Call edgeDetector.update(digitalSignal) to update the detector.\n    Then read edgeDetector.rising_edge or falling edge to know if the event occurred.\n\n    Author: Kevin Best\n    https://github.com/tkevinbest\n    \"\"\"\n\n    def __init__(self, bool_in: bool) -&gt; None:\n        self.cur_state: bool = bool_in\n        self.rising_edge: bool = False\n        self.falling_edge: bool = False\n\n    def __repr__(self) -&gt; str:\n        return \"EdgeDetector\"\n\n    def update(self, bool_in: bool) -&gt; None:\n        self.rising_edge = bool_in and not self.cur_state\n        self.falling_edge = not bool_in and self.cur_state\n        self.cur_state = bool_in\n</code></pre>"},{"location":"api/math/math/#opensourceleg.math.math.SaturatingRamp","title":"<code>SaturatingRamp</code>","text":"<p>Creates a signal that ramps between 0 and 1 at the specified rate. Looks like a trapezoid in the time domain Used to slowly enable joint torque for smooth switching at startup. Call saturatingRamp.update() to update the value of the ramp and return the value. Can also access saturatingRamp.value without updating.</p> Example usage <p>ramp = saturatingRamp(100, 1.0)</p> <p>Author: Kevin Best https://github.com/tkevinbest</p> Source code in <code>opensourceleg/math/math.py</code> <pre><code>class SaturatingRamp:\n    \"\"\"\n    Creates a signal that ramps between 0 and 1 at the specified rate.\n    Looks like a trapezoid in the time domain\n    Used to slowly enable joint torque for smooth switching at startup.\n    Call saturatingRamp.update() to update the value of the ramp and return the value.\n    Can also access saturatingRamp.value without updating.\n\n    Example usage:\n        ramp = saturatingRamp(100, 1.0)\n\n        # In loop\n            torque = torque * ramp.update(enable_ramp)\n\n    Author: Kevin Best\n    https://github.com/tkevinbest\n    \"\"\"\n\n    def __init__(self, loop_frequency: float = 100, ramp_time: float = 1.0) -&gt; None:\n        \"\"\"\n        Args:\n            loop_frequency (int, optional): Rate in Hz (default 100 Hz). Defaults to 100.\n            ramp_time (float, optional): Time to complete the ramp. Defaults to 1.0.\n        \"\"\"\n        self.delta_per_update = 1.0 / (loop_frequency * ramp_time)\n        self.value = 0.0\n\n    def __repr__(self) -&gt; str:\n        return \"SaturatingRamp\"\n\n    def update(self, enable_ramp: bool = False) -&gt; float:\n        \"\"\"\n        Updates the ramp value and returns it as a float.\n        If enable_ramp is true, ramp value increases\n        Otherwise decreases.\n\n        Example usage:\n            torque = torque * ramp.update(enable_ramp)\n\n        Args:\n            enable_ramp (bool, optional): If enable_ramp is true, ramp value increases. Defaults to False.\n\n        Returns:\n            value (float): Scalar between 0 and 1.\n        \"\"\"\n        delta = self.delta_per_update if enable_ramp else -1 * self.delta_per_update\n        self.value += delta\n\n        self.value = min(max(self.value, 0), 1)\n        return self.value\n</code></pre>"},{"location":"api/math/math/#opensourceleg.math.math.SaturatingRamp--in-loop","title":"In loop","text":"<pre><code>torque = torque * ramp.update(enable_ramp)\n</code></pre>"},{"location":"api/math/math/#opensourceleg.math.math.SaturatingRamp.__init__","title":"<code>__init__(loop_frequency=100, ramp_time=1.0)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>loop_frequency</code> <code>int</code> <p>Rate in Hz (default 100 Hz). Defaults to 100.</p> <code>100</code> <code>ramp_time</code> <code>float</code> <p>Time to complete the ramp. Defaults to 1.0.</p> <code>1.0</code> Source code in <code>opensourceleg/math/math.py</code> <pre><code>def __init__(self, loop_frequency: float = 100, ramp_time: float = 1.0) -&gt; None:\n    \"\"\"\n    Args:\n        loop_frequency (int, optional): Rate in Hz (default 100 Hz). Defaults to 100.\n        ramp_time (float, optional): Time to complete the ramp. Defaults to 1.0.\n    \"\"\"\n    self.delta_per_update = 1.0 / (loop_frequency * ramp_time)\n    self.value = 0.0\n</code></pre>"},{"location":"api/math/math/#opensourceleg.math.math.SaturatingRamp.update","title":"<code>update(enable_ramp=False)</code>","text":"<p>Updates the ramp value and returns it as a float. If enable_ramp is true, ramp value increases Otherwise decreases.</p> Example usage <p>torque = torque * ramp.update(enable_ramp)</p> <p>Parameters:</p> Name Type Description Default <code>enable_ramp</code> <code>bool</code> <p>If enable_ramp is true, ramp value increases. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>value</code> <code>float</code> <p>Scalar between 0 and 1.</p> Source code in <code>opensourceleg/math/math.py</code> <pre><code>def update(self, enable_ramp: bool = False) -&gt; float:\n    \"\"\"\n    Updates the ramp value and returns it as a float.\n    If enable_ramp is true, ramp value increases\n    Otherwise decreases.\n\n    Example usage:\n        torque = torque * ramp.update(enable_ramp)\n\n    Args:\n        enable_ramp (bool, optional): If enable_ramp is true, ramp value increases. Defaults to False.\n\n    Returns:\n        value (float): Scalar between 0 and 1.\n    \"\"\"\n    delta = self.delta_per_update if enable_ramp else -1 * self.delta_per_update\n    self.value += delta\n\n    self.value = min(max(self.value, 0), 1)\n    return self.value\n</code></pre>"},{"location":"api/math/math/#opensourceleg.math.math.ThermalModel","title":"<code>ThermalModel</code>","text":"<p>Enhanced thermal model with outlier filtering and soft-limiting safety controller.</p> <p>Based on <code>A Modular Framework for Task-Agnostic, Energy Shaping Control of Lower Limb Exoskeletons</code> by Jianping Lin, Gray C. Thomas, Nikhil V. Divekar, Vamsi Peddinti, &amp; Robert D. Gregg</p> Thermal Circuit Model <p>Two-node lumped system with winding and case temperatures.</p> <p>Equations:     1: Cw * dTw/dt = I\u00b2R(T) + (Th-Tw)/Rwh     2: Ch * dTh/dt = (Tw-Th)/Rwh + (Ta-Th)/Rha</p> Features <ul> <li>Integrated outlier detection for current/temperature sensors</li> <li>Soft-limiting thermal safety controller with formal guarantees</li> <li>Physically sensible value validation with slope-based projection</li> <li>Backward compatible API with enhanced methods</li> <li>Motor-specific parameter configuration via MOTOR_CONSTANTS</li> </ul> Authors <ul> <li>Gray Thomas, Senthur Ayyappan</li> </ul> <p>Parameters:</p> Name Type Description Default <code>motor_constants</code> <code>MOTOR_CONSTANTS</code> <p>MOTOR_CONSTANTS instance with thermal parameters</p> required <code>actuator_tag</code> <code>str</code> <p>Actuator identifier for error messages. Defaults to \"actuator\"</p> <code>'actuator'</code> <code>ambient_temperature</code> <code>float</code> <p>Ambient temperature in \u00b0C. Defaults to 21.0</p> <code>21.0</code> Source code in <code>opensourceleg/math/math.py</code> <pre><code>class ThermalModel:\n    \"\"\"\n    Enhanced thermal model with outlier filtering and soft-limiting safety controller.\n\n    Based on `A Modular Framework for Task-Agnostic, Energy Shaping Control of Lower Limb Exoskeletons`\n    by Jianping Lin, Gray C. Thomas, Nikhil V. Divekar, Vamsi Peddinti, &amp; Robert D. Gregg\n\n    Thermal Circuit Model:\n        Two-node lumped system with winding and case temperatures.\n\n        Equations:\n            1: Cw * dTw/dt = I\u00b2R(T) + (Th-Tw)/Rwh\n            2: Ch * dTh/dt = (Tw-Th)/Rwh + (Ta-Th)/Rha\n\n    Features:\n        - Integrated outlier detection for current/temperature sensors\n        - Soft-limiting thermal safety controller with formal guarantees\n        - Physically sensible value validation with slope-based projection\n        - Backward compatible API with enhanced methods\n        - Motor-specific parameter configuration via MOTOR_CONSTANTS\n\n    Authors:\n        - Gray Thomas, Senthur Ayyappan\n\n    Args:\n        motor_constants: MOTOR_CONSTANTS instance with thermal parameters\n        actuator_tag: Actuator identifier for error messages. Defaults to \"actuator\"\n        ambient_temperature: Ambient temperature in \u00b0C. Defaults to 21.0\n    \"\"\"\n\n    def __init__(\n        self,\n        motor_constants: MOTOR_CONSTANTS,\n        actuator_tag: str = \"actuator\",\n        ambient_temperature: float = 21.0,\n    ) -&gt; None:\n        self.winding_thermal_capacitance = motor_constants.WINDING_THERMAL_CAPACITANCE\n        self.case_thermal_capacitance = motor_constants.CASE_THERMAL_CAPACITANCE\n        self.winding_to_case_resistance = motor_constants.WINDING_TO_CASE_RESISTANCE\n        self.case_to_ambient_resistance = motor_constants.CASE_TO_AMBIENT_RESISTANCE\n        self.copper_temperature_coefficient = motor_constants.COPPER_TEMPERATURE_COEFFICIENT\n        self.reference_temperature = motor_constants.REFERENCE_TEMPERATURE\n        self.reference_resistance = motor_constants.REFERENCE_RESISTANCE\n\n        self.winding_hard_limit = motor_constants.MAX_WINDING_TEMPERATURE\n        self.winding_soft_limit = motor_constants.WINDING_SOFT_LIMIT\n        self.case_hard_limit = motor_constants.MAX_CASE_TEMPERATURE\n        self.case_soft_limit = motor_constants.CASE_SOFT_LIMIT\n\n        self.winding_temperature: float = ambient_temperature\n        self.case_temperature: float = ambient_temperature\n        self.ambient_temperature: float = ambient_temperature\n\n        self.current_history: deque[float] = deque(maxlen=SENSOR_HISTORY_SIZE)\n        self.temperature_history: deque[float] = deque(maxlen=SENSOR_HISTORY_SIZE)\n\n        self.actuator_tag: str = actuator_tag\n\n        self._current_sensor_faults: int = 0\n        self._case_temperature_faults: int = 0\n\n    def __repr__(self) -&gt; str:\n        return f\"ThermalModel(Tw={self.winding_temperature:.1f}\u00b0C, Tc={self.case_temperature:.1f}\u00b0C)\"\n\n    def _is_within_bounds(self, value: float, min_bound: float, max_bound: float) -&gt; bool:\n        \"\"\"Check if value is within physically sensible bounds.\"\"\"\n        return min_bound &lt;= value &lt;= max_bound\n\n    def _get_fallback_value(self, history: deque, default: float) -&gt; float:\n        \"\"\"Get fallback value when sensor reading is invalid.\"\"\"\n        return history[-1] if len(history) &gt; 0 else default\n\n    def _diagnose_sensor_value(\n        self,\n        raw_value: float,\n        history: deque,\n        min_bound: float,\n        max_bound: float,\n        fallback_default: float,\n        dt: float,\n        fault_counter: int,\n    ) -&gt; tuple[float, int]:\n        \"\"\"Generic sensor diagnosis with bounds validation\"\"\"\n        # TODO: Move diagnostics to a separate mixin just like the offline mode\n        # that both actuators and sensors can inherit\n        raw_value = float(raw_value)\n\n        if not self._is_within_bounds(raw_value, min_bound, max_bound):\n            final_value = self._get_fallback_value(history, fallback_default)\n            fault_counter += 1\n\n            if fault_counter &gt;= int(1.0 / (2 * dt)):\n                raise DataPacketCorruptionException(\n                    f\"[{self.actuator_tag.upper()}] data packets have been corrupted for a prolonged period. \"\n                    f\"Please check your connection.\"\n                )\n        else:\n            final_value = raw_value\n            fault_counter = 0  # Reset fault counter on successful read\n\n        history.append(final_value)\n        return final_value, fault_counter\n\n    def update(\n        self,\n        dt: float,\n        motor_current: float,\n        case_temperature: Optional[float] = None,\n        factor_of_safety: float = 1.0,\n    ) -&gt; float:\n        \"\"\"\n        Updates winding and case temperatures with sensor diagnosis and returns scale factor.\n\n        Args:\n            dt: Time step in seconds. Defaults to 1/200 (200Hz)\n            motor_current: Motor current in mA. Defaults to 0\n            case_temperature: External case temperature in \u00b0C. If None, uses thermal model.\n            factor_of_safety: Factor of safety for thermal predictions. Defaults to 1.0\n\n        Returns:\n            float: Thermal scale factor [0,1] for torque/current scaling\n\n        Thermal Dynamics:\n            Cw * dTw/dt = I\u00b2R(T) + (Tc-Tw)/Rwc\n            Cc * dTc/dt = (Tw-Tc)/Rwc + (Ta-Tc)/Rca\n        \"\"\"\n\n        diagnosed_current, self._current_sensor_faults = self._diagnose_sensor_value(\n            motor_current,\n            self.current_history,\n            MIN_SENSIBLE_CURRENT,\n            MAX_SENSIBLE_CURRENT,\n            0.0,\n            dt,\n            self._current_sensor_faults,\n        )\n        if case_temperature is not None:\n            diagnosed_case_temp, self._case_temperature_faults = self._diagnose_sensor_value(\n                case_temperature,\n                self.temperature_history,\n                MIN_SENSIBLE_TEMPERATURE,\n                MAX_SENSIBLE_TEMPERATURE,\n                self.ambient_temperature,\n                dt,\n                self._case_temperature_faults,\n            )\n        else:\n            diagnosed_case_temp = None\n\n        current_amps = diagnosed_current * 1e-3\n\n        # R(T) = R\u2080(1 + alpha(T - T\u2080))\n        resistance_at_temp = self.reference_resistance * (\n            1 + self.copper_temperature_coefficient * (self.winding_temperature - self.reference_temperature)\n        )\n\n        # I\u00b2R\n        joule_heating = factor_of_safety * current_amps**2 * resistance_at_temp\n\n        # Winding temperature dynamics\n        dTw_dt = (\n            joule_heating + (self.case_temperature - self.winding_temperature) / self.winding_to_case_resistance\n        ) / self.winding_thermal_capacitance\n        self.winding_temperature += dt * dTw_dt\n\n        # Case temperature dynamics\n        if diagnosed_case_temp is not None:\n            self.case_temperature = diagnosed_case_temp\n        else:\n            # Compute case temperature from thermal model\n            dTc_dt = (\n                (self.winding_temperature - self.case_temperature) / self.winding_to_case_resistance\n                + (self.ambient_temperature - self.case_temperature) / self.case_to_ambient_resistance\n            ) / self.case_thermal_capacitance\n            self.case_temperature += dt * dTc_dt\n\n        self.check_thermal_limits_and_raise()\n\n        # Return thermal scale factor\n        return self.get_thermal_scale_factor()\n\n    def _soft_limiting_function(self, temperature: float, soft_limit: float, hard_limit: float) -&gt; float:\n        \"\"\"\n        Soft-limiting function\n        \"\"\"\n        if temperature &lt;= soft_limit:\n            return 1.0\n        elif temperature &gt;= hard_limit:\n            return 0.0\n        else:\n            return (hard_limit - temperature) / (hard_limit - soft_limit)\n\n    def get_thermal_scale_factor(self) -&gt; float:\n        \"\"\"\n        Calculate thermal scaling factor using Jianping's soft-limiting approach.\n\n        Returns:\n            float: Scale factor [0,1] for torque/current scaling\n        \"\"\"\n        winding_scale = self._soft_limiting_function(\n            self.winding_temperature, self.winding_soft_limit, self.winding_hard_limit\n        )\n        case_scale = self._soft_limiting_function(self.case_temperature, self.case_soft_limit, self.case_hard_limit)\n\n        # Combined scale factor (\u221a(S_case * S_winding))\n        combined_scale = winding_scale * case_scale\n        return float(np.sqrt(combined_scale)) if combined_scale &gt; 0 else 0.0\n\n    def check_thermal_limits_and_raise(self) -&gt; None:\n        \"\"\"\n        Check thermal limits and raise exceptions if exceeded.\n        This replaces the thermal limit checking logic from actuator update method.\n\n        Raises:\n            ThermalLimitException: If hard thermal limits are exceeded\n        \"\"\"\n        if self.case_temperature &gt;= self.case_hard_limit:\n            raise ThermalLimitException(\n                f\"[{self.actuator_tag.upper()}] Case thermal limit {self.case_hard_limit}\u00b0C reached. \"\n                f\"Current Case Temperature: {self.case_temperature:.1f}\u00b0C. Exiting.\"\n            )\n\n        if self.winding_temperature &gt;= self.winding_hard_limit:\n            raise ThermalLimitException(\n                f\"[{self.actuator_tag.upper()}] Winding thermal limit {self.winding_hard_limit}\u00b0C reached. \"\n                f\"Current Winding Temperature: {self.winding_temperature:.1f}\u00b0C. Exiting.\"\n            )\n</code></pre>"},{"location":"api/math/math/#opensourceleg.math.math.ThermalModel.check_thermal_limits_and_raise","title":"<code>check_thermal_limits_and_raise()</code>","text":"<p>Check thermal limits and raise exceptions if exceeded. This replaces the thermal limit checking logic from actuator update method.</p> <p>Raises:</p> Type Description <code>ThermalLimitException</code> <p>If hard thermal limits are exceeded</p> Source code in <code>opensourceleg/math/math.py</code> <pre><code>def check_thermal_limits_and_raise(self) -&gt; None:\n    \"\"\"\n    Check thermal limits and raise exceptions if exceeded.\n    This replaces the thermal limit checking logic from actuator update method.\n\n    Raises:\n        ThermalLimitException: If hard thermal limits are exceeded\n    \"\"\"\n    if self.case_temperature &gt;= self.case_hard_limit:\n        raise ThermalLimitException(\n            f\"[{self.actuator_tag.upper()}] Case thermal limit {self.case_hard_limit}\u00b0C reached. \"\n            f\"Current Case Temperature: {self.case_temperature:.1f}\u00b0C. Exiting.\"\n        )\n\n    if self.winding_temperature &gt;= self.winding_hard_limit:\n        raise ThermalLimitException(\n            f\"[{self.actuator_tag.upper()}] Winding thermal limit {self.winding_hard_limit}\u00b0C reached. \"\n            f\"Current Winding Temperature: {self.winding_temperature:.1f}\u00b0C. Exiting.\"\n        )\n</code></pre>"},{"location":"api/math/math/#opensourceleg.math.math.ThermalModel.get_thermal_scale_factor","title":"<code>get_thermal_scale_factor()</code>","text":"<p>Calculate thermal scaling factor using Jianping's soft-limiting approach.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Scale factor [0,1] for torque/current scaling</p> Source code in <code>opensourceleg/math/math.py</code> <pre><code>def get_thermal_scale_factor(self) -&gt; float:\n    \"\"\"\n    Calculate thermal scaling factor using Jianping's soft-limiting approach.\n\n    Returns:\n        float: Scale factor [0,1] for torque/current scaling\n    \"\"\"\n    winding_scale = self._soft_limiting_function(\n        self.winding_temperature, self.winding_soft_limit, self.winding_hard_limit\n    )\n    case_scale = self._soft_limiting_function(self.case_temperature, self.case_soft_limit, self.case_hard_limit)\n\n    # Combined scale factor (\u221a(S_case * S_winding))\n    combined_scale = winding_scale * case_scale\n    return float(np.sqrt(combined_scale)) if combined_scale &gt; 0 else 0.0\n</code></pre>"},{"location":"api/math/math/#opensourceleg.math.math.ThermalModel.update","title":"<code>update(dt, motor_current, case_temperature=None, factor_of_safety=1.0)</code>","text":"<p>Updates winding and case temperatures with sensor diagnosis and returns scale factor.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>float</code> <p>Time step in seconds. Defaults to 1/200 (200Hz)</p> required <code>motor_current</code> <code>float</code> <p>Motor current in mA. Defaults to 0</p> required <code>case_temperature</code> <code>Optional[float]</code> <p>External case temperature in \u00b0C. If None, uses thermal model.</p> <code>None</code> <code>factor_of_safety</code> <code>float</code> <p>Factor of safety for thermal predictions. Defaults to 1.0</p> <code>1.0</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Thermal scale factor [0,1] for torque/current scaling</p> Thermal Dynamics <p>Cw * dTw/dt = I\u00b2R(T) + (Tc-Tw)/Rwc Cc * dTc/dt = (Tw-Tc)/Rwc + (Ta-Tc)/Rca</p> Source code in <code>opensourceleg/math/math.py</code> <pre><code>def update(\n    self,\n    dt: float,\n    motor_current: float,\n    case_temperature: Optional[float] = None,\n    factor_of_safety: float = 1.0,\n) -&gt; float:\n    \"\"\"\n    Updates winding and case temperatures with sensor diagnosis and returns scale factor.\n\n    Args:\n        dt: Time step in seconds. Defaults to 1/200 (200Hz)\n        motor_current: Motor current in mA. Defaults to 0\n        case_temperature: External case temperature in \u00b0C. If None, uses thermal model.\n        factor_of_safety: Factor of safety for thermal predictions. Defaults to 1.0\n\n    Returns:\n        float: Thermal scale factor [0,1] for torque/current scaling\n\n    Thermal Dynamics:\n        Cw * dTw/dt = I\u00b2R(T) + (Tc-Tw)/Rwc\n        Cc * dTc/dt = (Tw-Tc)/Rwc + (Ta-Tc)/Rca\n    \"\"\"\n\n    diagnosed_current, self._current_sensor_faults = self._diagnose_sensor_value(\n        motor_current,\n        self.current_history,\n        MIN_SENSIBLE_CURRENT,\n        MAX_SENSIBLE_CURRENT,\n        0.0,\n        dt,\n        self._current_sensor_faults,\n    )\n    if case_temperature is not None:\n        diagnosed_case_temp, self._case_temperature_faults = self._diagnose_sensor_value(\n            case_temperature,\n            self.temperature_history,\n            MIN_SENSIBLE_TEMPERATURE,\n            MAX_SENSIBLE_TEMPERATURE,\n            self.ambient_temperature,\n            dt,\n            self._case_temperature_faults,\n        )\n    else:\n        diagnosed_case_temp = None\n\n    current_amps = diagnosed_current * 1e-3\n\n    # R(T) = R\u2080(1 + alpha(T - T\u2080))\n    resistance_at_temp = self.reference_resistance * (\n        1 + self.copper_temperature_coefficient * (self.winding_temperature - self.reference_temperature)\n    )\n\n    # I\u00b2R\n    joule_heating = factor_of_safety * current_amps**2 * resistance_at_temp\n\n    # Winding temperature dynamics\n    dTw_dt = (\n        joule_heating + (self.case_temperature - self.winding_temperature) / self.winding_to_case_resistance\n    ) / self.winding_thermal_capacitance\n    self.winding_temperature += dt * dTw_dt\n\n    # Case temperature dynamics\n    if diagnosed_case_temp is not None:\n        self.case_temperature = diagnosed_case_temp\n    else:\n        # Compute case temperature from thermal model\n        dTc_dt = (\n            (self.winding_temperature - self.case_temperature) / self.winding_to_case_resistance\n            + (self.ambient_temperature - self.case_temperature) / self.case_to_ambient_resistance\n        ) / self.case_thermal_capacitance\n        self.case_temperature += dt * dTc_dt\n\n    self.check_thermal_limits_and_raise()\n\n    # Return thermal scale factor\n    return self.get_thermal_scale_factor()\n</code></pre>"},{"location":"api/math/math/#opensourceleg.math.math.clamp_within_vector_range","title":"<code>clamp_within_vector_range(input_value, input_vector)</code>","text":"<p>This function ensures that input_value remains within the range spanned by the input_vector. If the input_value falls outside the vector's bounds, it'll return the appropriate max or min value from the vector.</p> Example <p>clamp_within_vector_range(10, [0,1,2,3]) = 3 clamp_within_vector_range(-10, [0,1,2,3]) = 0</p> Author <p>Kevin Best, 8/7/2023 https://github.com/tkevinbest</p> Source code in <code>opensourceleg/math/math.py</code> <pre><code>def clamp_within_vector_range(\n    input_value: Union[float, int], input_vector: list[Union[float, int]]\n) -&gt; Union[float, int]:\n    \"\"\"\n    This function ensures that input_value remains within the range spanned by the input_vector.\n    If the input_value falls outside the vector's bounds, it'll return the appropriate max or min value from the vector.\n\n    Example:\n        clamp_within_vector_range(10, [0,1,2,3]) = 3\n        clamp_within_vector_range(-10, [0,1,2,3]) = 0\n\n    Author:\n        Kevin Best, 8/7/2023\n        https://github.com/tkevinbest\n    \"\"\"\n    min_allowed = min(input_vector)\n    max_allowed = max(input_vector)\n    return max(min(input_value, max_allowed), min_allowed)\n</code></pre>"},{"location":"api/math/math/#opensourceleg.math.math.from_twos_complement","title":"<code>from_twos_complement(value, bit_length)</code>","text":"<p>Converts a 2's complement integer to a signed integer</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>2's complement integer</p> required <code>bit_length</code> <code>int</code> <p>Number of bits of 2's complement representation</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Signed integer</p> <p>Author: Axel Sj\u00f6gren Holtz (axel.sjogren.holtz@vgregion.se)</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If value or bit_length is not an integer</p> <code>ValueError</code> <p>If value is negative, bit_length is negative, or value exceeds bit_length</p> Source code in <code>opensourceleg/math/math.py</code> <pre><code>def from_twos_complement(value: int, bit_length: int) -&gt; int:\n    \"\"\"Converts a 2's complement integer to a signed integer\n\n    Args:\n        value (int): 2's complement integer\n        bit_length (int): Number of bits of 2's complement representation\n\n    Returns:\n        int: Signed integer\n\n    Author: Axel Sj\u00f6gren Holtz (axel.sjogren.holtz@vgregion.se)\n\n    Raises:\n        TypeError: If value or bit_length is not an integer\n        ValueError: If value is negative, bit_length is negative, or value exceeds bit_length\n    \"\"\"\n    if not isinstance(value, int):\n        raise TypeError(\"value must be an integer\")\n    if value &lt; 0:\n        raise ValueError(\"value must be non-negative\")\n    if not isinstance(bit_length, int):\n        raise TypeError(\"bit_length must be an integer\")\n    if bit_length &lt; 0:\n        raise ValueError(\"bit_length must be non-negative\")\n    if value.bit_length() &gt; bit_length:\n        raise ValueError(f\"value ({value}) exceeds the specified bit_length ({bit_length})\")\n\n    if value &gt;= 2 ** (bit_length - 1):\n        return int(value - (2**bit_length))\n    else:\n        return int(value)\n</code></pre>"},{"location":"api/math/math/#opensourceleg.math.math.to_twos_complement","title":"<code>to_twos_complement(value, bit_length)</code>","text":"<p>Converts a signed integer to 2's complement for a defined number of bits as an unsigned integer</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>Signed integer to convert</p> required <code>bit_length</code> <code>int</code> <p>Number of bits of 2's complement representation</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Unsigned integer 2's complement</p> <p>Author: Axel Sj\u00f6gren Holtz (axel.sjogren.holtz@vgregion.se)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If value is too small or too large for the given bit length</p> Source code in <code>opensourceleg/math/math.py</code> <pre><code>def to_twos_complement(value: int, bit_length: int) -&gt; int:\n    \"\"\"Converts a signed integer to 2's complement for a defined number of bits\n    as an unsigned integer\n\n    Args:\n        value (int): Signed integer to convert\n        bit_length (int): Number of bits of 2's complement representation\n\n    Returns:\n        int: Unsigned integer 2's complement\n\n    Author: Axel Sj\u00f6gren Holtz (axel.sjogren.holtz@vgregion.se)\n\n    Raises:\n        ValueError: If value is too small or too large for the given bit length\n    \"\"\"\n    min_value = -(2 ** (bit_length - 1))\n    max_value = 2 ** (bit_length - 1) - 1\n\n    if value &lt; min_value:\n        raise ValueError(f\"Value {value} is too small for {bit_length} bits\")\n    if value &gt; max_value:\n        raise ValueError(f\"Value {value} is too large for {bit_length} bits\")\n\n    if value &gt;= 0:\n        return value\n\n    return int(value + 2**bit_length)\n</code></pre>"},{"location":"api/robots/osl/","title":"OSL","text":""},{"location":"api/robots/osl/#opensourceleg.robots.osl.OpenSourceLeg","title":"<code>OpenSourceLeg</code>","text":"<p>               Bases: <code>RobotBase[TActuator, TSensor]</code></p> <p>Open Source Leg (OSL) class derived from RobotBase.</p> Source code in <code>opensourceleg/robots/osl.py</code> <pre><code>class OpenSourceLeg(RobotBase[TActuator, TSensor]):\n    \"\"\"\n    Open Source Leg (OSL) class derived from RobotBase.\n    \"\"\"\n\n    def start(self) -&gt; None:\n        \"\"\"\n        Start the OSL.\n        \"\"\"\n        super().start()\n\n    def stop(self) -&gt; None:\n        \"\"\"\n        Stop the OSL.\n        \"\"\"\n        super().stop()\n\n    def update(self) -&gt; None:\n        \"\"\"\n        Update the robot.\n        \"\"\"\n        super().update()\n\n    def home(\n        self,\n        homing_voltage: int = 2000,\n        homing_frequency: int = 200,\n        homing_direction: Optional[dict[str, int]] = None,\n        output_position_offset: Optional[dict[str, float]] = None,\n        current_threshold: int = 5000,\n        velocity_threshold: float = 0.001,\n        callbacks: Optional[dict[str, Callable]] = None,\n    ) -&gt; None:\n        \"\"\"\n        Call the home method for all actuators.\n\n        Args:\n            homing_voltage: The voltage to apply to the actuators during homing.\n            homing_frequency: The frequency to apply to the actuators during homing.\n            homing_direction: The direction to apply to the actuators during homing.\n                Default is -1 for knee and ankle.\n            output_position_offset: The offset to apply to the actuators during homing.\n                Default is 0.0 for knee and 30.0 for ankle.\n            current_threshold: The current threshold to apply to the actuators during homing. Default is 5000.\n            velocity_threshold: The velocity threshold to apply to the actuators during homing. Default is 0.001.\n            callbacks  Optional[dict[str, Callable]]:\n                Optional dictionary of callback functions, one per actuator, to be called when each actuator's\n                homing completes. Only one callback per actuator is supported, and the tag must match.\n                Each function should take no arguments and return None. If None, no callbacks are used.\n        \"\"\"\n        if output_position_offset is None:\n            output_position_offset = {\"knee\": 0.0, \"ankle\": np.deg2rad(30.0)}\n        if homing_direction is None:\n            homing_direction = {\"knee\": -1, \"ankle\": -1}\n        for actuator in self.actuators.values():\n            callback = callbacks.get(actuator.tag, None) if callbacks is not None else None\n            actuator.home(\n                homing_voltage=homing_voltage,\n                homing_frequency=homing_frequency,\n                homing_direction=homing_direction[actuator.tag],\n                output_position_offset=output_position_offset[actuator.tag],\n                current_threshold=current_threshold,\n                velocity_threshold=velocity_threshold,\n                callback=callback,\n            )\n\n        LOGGER.info(\n            \"OSL homing complete. If you'd like to create or load encoder maps to \"\n            \"correct for nonlinearities, call `make_encoder_linearization_map()` method.\"\n        )\n\n    def make_encoder_linearization_map(\n        self,\n        overwrite: bool = False,\n    ) -&gt; None:\n        \"\"\"\n        This method makes a lookup table to calculate the position measured by the joint encoder.\n        This is necessary because the magnetic output encoders are nonlinear.\n        By making the map while the joint is unloaded, joint position calculated by motor position * gear ratio\n        should be the same as the true joint position. Output from this function is a file containing a_i values\n        parameterizing the map.\n\n        Eqn:\n            position = sum from i=0^5 (a_i*counts^i)\n\n        Author:\n            Kevin Best (tkbest@umich.edu),\n            Senthur Ayyappan (senthura@umich.edu)\n        \"\"\"\n        for actuator_key in self.actuators:\n            if f\"joint_encoder_{actuator_key}\" in self.sensors:\n                self._create_linear_joint_mapping(\n                    actuator_key=actuator_key,\n                    encoder_key=f\"joint_encoder_{actuator_key}\",\n                    overwrite=overwrite,\n                )\n            else:\n                LOGGER.warning(\n                    f\"[{actuator_key}] No joint encoder found. Skipping. \"\n                    f\"Encoder tags should be of the form 'joint_encoder_{actuator_key}'.\"\n                )\n\n    def _create_linear_joint_mapping(\n        self,\n        actuator_key: str,\n        encoder_key: str,\n        overwrite: bool = False,\n    ) -&gt; None:\n        _actuator: ActuatorBase = self.actuators[actuator_key]\n        _encoder: SensorBase = self.sensors[encoder_key]\n\n        if not _actuator.is_homed:\n            LOGGER.warning(\n                msg=f\"[{str.upper(_actuator.tag)}] Please home the {_actuator.tag} joint before making the encoder map.\"\n            )\n            return None\n\n        if os.path.exists(f\"./{_encoder.tag}_linearization_map.npy\") and not overwrite:\n            LOGGER.info(msg=f\"[{str.upper(_encoder.tag)}] Encoder map exists. Skipping encoder map creation.\")\n            _encoder.set_encoder_map(  # type: ignore[attr-defined]\n                np.polynomial.polynomial.Polynomial(np.load(f\"./{_encoder.tag}_linearization_map.npy\"))\n            )\n            LOGGER.info(\n                msg=f\"[{str.upper(_encoder.tag)}] Encoder map loaded from './{_encoder.tag}_linearization_map.npy'.\"\n            )\n            return None\n\n        _actuator.set_control_mode(mode=CONTROL_MODES.CURRENT)\n        _actuator.set_current_gains(\n            kp=DEFAULT_CURRENT_GAINS.kp,\n            ki=DEFAULT_CURRENT_GAINS.ki,\n            kd=DEFAULT_CURRENT_GAINS.kd,\n            ff=DEFAULT_CURRENT_GAINS.ff,\n        )\n\n        time.sleep(0.1)\n\n        _actuator.set_output_torque(value=0.0)\n\n        _joint_encoder_array = []\n        _output_position_array = []\n\n        LOGGER.info(\n            msg=f\"[{str.upper(_actuator.tag)}] Please manually move the {_actuator.tag} joint numerous times through \"\n            f\"its full range of motion for 10 seconds.\"\n        )\n        input(\"Press any key when you are ready to start.\")\n\n        _start_time: float = time.time()\n\n        # TODO: Switch to SoftRealtimeLoop since it has reset method now\n        while time.time() - _start_time &lt; 10:\n            try:\n                LOGGER.info(\n                    msg=f\"[{str.upper(_actuator.tag)}] Mapping the {_actuator.tag} \"\n                    f\"joint encoder: {(10 - time.time() + _start_time):.2f} seconds left.\"\n                )\n                _actuator.update()\n                _encoder.update()\n\n                _joint_encoder_array.append(_encoder.position)  # type: ignore[attr-defined]\n                _output_position_array.append(_actuator.output_position)\n                time.sleep(1 / _actuator.frequency)\n\n            except KeyboardInterrupt:\n                LOGGER.warning(msg=\"Encoder map interrupted.\")\n                return None\n\n        LOGGER.info(msg=f\"[{str.upper(_actuator.tag)}] You may now stop moving the {_actuator.tag} joint.\")\n\n        _power = np.arange(4.0)\n        _a_mat = np.array(_joint_encoder_array).reshape(-1, 1) ** _power\n        _beta = np.linalg.lstsq(_a_mat, _output_position_array, rcond=None)\n        _coeffs = _beta[0]\n\n        _encoder.set_encoder_map(np.polynomial.polynomial.Polynomial(coef=_coeffs))  # type: ignore[attr-defined]\n\n        np.save(file=f\"./{_encoder.tag}_linearization_map.npy\", arr=_coeffs)\n\n        _actuator.set_control_mode(mode=CONTROL_MODES.VOLTAGE)\n        _actuator.set_motor_voltage(value=0.0)\n\n        LOGGER.info(\n            msg=f\"[{str.upper(_encoder.tag)}] Encoder map saved to './{_encoder.tag}_linearization_map.npy' and loaded.\"\n        )\n\n    @property\n    def knee(self) -&gt; Union[TActuator, ActuatorBase]:\n        \"\"\"\n        Get the knee actuator.\n\n        Returns:\n            Union[TActuator, ActuatorBase]: The knee actuator.\n        \"\"\"\n        try:\n            return self.actuators[\"knee\"]\n        except KeyError:\n            LOGGER.error(\"Knee actuator not found. Please check for `knee` key in the actuators dictionary.\")\n            exit(1)\n\n    @property\n    def ankle(self) -&gt; Union[TActuator, ActuatorBase]:\n        \"\"\"\n        Get the ankle actuator.\n\n        Returns:\n            Union[TActuator, ActuatorBase]: The ankle actuator.\n        \"\"\"\n        try:\n            return self.actuators[\"ankle\"]\n        except KeyError:\n            LOGGER.error(\"Ankle actuator not found. Please check for `ankle` key in the actuators dictionary.\")\n            exit(1)\n\n    @property\n    def loadcell(self) -&gt; Union[TSensor, LoadcellBase]:\n        \"\"\"\n        Get the loadcell sensor.\n\n        Returns:\n            Union[TSensor, LoadcellBase]: The loadcell sensor.\n        \"\"\"\n        try:\n            return self.sensors[\"loadcell\"]\n        except KeyError:\n            LOGGER.error(\"Loadcell sensor not found. Please check for `loadcell` key in the sensors dictionary.\")\n            exit(1)\n\n    @property\n    def joint_encoder_knee(self) -&gt; Union[TSensor, SensorBase]:\n        \"\"\"\n        Get the knee joint encoder sensor.\n\n        Returns:\n            Union[TSensor, SensorBase]: The knee joint encoder sensor.\n        \"\"\"\n        try:\n            return self.sensors[\"joint_encoder_knee\"]\n        except KeyError:\n            LOGGER.error(\n                \"Knee joint encoder sensor not found.\"\n                \"Please check for `joint_encoder_knee` key in the sensors dictionary.\"\n            )\n            exit(1)\n\n    @property\n    def joint_encoder_ankle(self) -&gt; Union[TSensor, SensorBase]:\n        \"\"\"\n        Get the ankle joint encoder sensor.\n\n        Returns:\n            Union[TSensor, SensorBase]: The ankle joint encoder sensor.\n        \"\"\"\n        try:\n            return self.sensors[\"joint_encoder_ankle\"]\n        except KeyError:\n            LOGGER.error(\n                \"Ankle joint encoder sensor not found.\"\n                \"Please check for `joint_encoder_ankle` key in the sensors dictionary.\"\n            )\n            exit(1)\n</code></pre>"},{"location":"api/robots/osl/#opensourceleg.robots.osl.OpenSourceLeg.ankle","title":"<code>ankle</code>  <code>property</code>","text":"<p>Get the ankle actuator.</p> <p>Returns:</p> Type Description <code>Union[TActuator, ActuatorBase]</code> <p>Union[TActuator, ActuatorBase]: The ankle actuator.</p>"},{"location":"api/robots/osl/#opensourceleg.robots.osl.OpenSourceLeg.joint_encoder_ankle","title":"<code>joint_encoder_ankle</code>  <code>property</code>","text":"<p>Get the ankle joint encoder sensor.</p> <p>Returns:</p> Type Description <code>Union[TSensor, SensorBase]</code> <p>Union[TSensor, SensorBase]: The ankle joint encoder sensor.</p>"},{"location":"api/robots/osl/#opensourceleg.robots.osl.OpenSourceLeg.joint_encoder_knee","title":"<code>joint_encoder_knee</code>  <code>property</code>","text":"<p>Get the knee joint encoder sensor.</p> <p>Returns:</p> Type Description <code>Union[TSensor, SensorBase]</code> <p>Union[TSensor, SensorBase]: The knee joint encoder sensor.</p>"},{"location":"api/robots/osl/#opensourceleg.robots.osl.OpenSourceLeg.knee","title":"<code>knee</code>  <code>property</code>","text":"<p>Get the knee actuator.</p> <p>Returns:</p> Type Description <code>Union[TActuator, ActuatorBase]</code> <p>Union[TActuator, ActuatorBase]: The knee actuator.</p>"},{"location":"api/robots/osl/#opensourceleg.robots.osl.OpenSourceLeg.loadcell","title":"<code>loadcell</code>  <code>property</code>","text":"<p>Get the loadcell sensor.</p> <p>Returns:</p> Type Description <code>Union[TSensor, LoadcellBase]</code> <p>Union[TSensor, LoadcellBase]: The loadcell sensor.</p>"},{"location":"api/robots/osl/#opensourceleg.robots.osl.OpenSourceLeg.home","title":"<code>home(homing_voltage=2000, homing_frequency=200, homing_direction=None, output_position_offset=None, current_threshold=5000, velocity_threshold=0.001, callbacks=None)</code>","text":"<p>Call the home method for all actuators.</p> <p>Parameters:</p> Name Type Description Default <code>homing_voltage</code> <code>int</code> <p>The voltage to apply to the actuators during homing.</p> <code>2000</code> <code>homing_frequency</code> <code>int</code> <p>The frequency to apply to the actuators during homing.</p> <code>200</code> <code>homing_direction</code> <code>Optional[dict[str, int]]</code> <p>The direction to apply to the actuators during homing. Default is -1 for knee and ankle.</p> <code>None</code> <code>output_position_offset</code> <code>Optional[dict[str, float]]</code> <p>The offset to apply to the actuators during homing. Default is 0.0 for knee and 30.0 for ankle.</p> <code>None</code> <code>current_threshold</code> <code>int</code> <p>The current threshold to apply to the actuators during homing. Default is 5000.</p> <code>5000</code> <code>velocity_threshold</code> <code>float</code> <p>The velocity threshold to apply to the actuators during homing. Default is 0.001.</p> <code>0.001</code> <code>callbacks</code> <code> Optional[dict[str, Callable]]</code> <p>Optional dictionary of callback functions, one per actuator, to be called when each actuator's homing completes. Only one callback per actuator is supported, and the tag must match. Each function should take no arguments and return None. If None, no callbacks are used.</p> <code>None</code> Source code in <code>opensourceleg/robots/osl.py</code> <pre><code>def home(\n    self,\n    homing_voltage: int = 2000,\n    homing_frequency: int = 200,\n    homing_direction: Optional[dict[str, int]] = None,\n    output_position_offset: Optional[dict[str, float]] = None,\n    current_threshold: int = 5000,\n    velocity_threshold: float = 0.001,\n    callbacks: Optional[dict[str, Callable]] = None,\n) -&gt; None:\n    \"\"\"\n    Call the home method for all actuators.\n\n    Args:\n        homing_voltage: The voltage to apply to the actuators during homing.\n        homing_frequency: The frequency to apply to the actuators during homing.\n        homing_direction: The direction to apply to the actuators during homing.\n            Default is -1 for knee and ankle.\n        output_position_offset: The offset to apply to the actuators during homing.\n            Default is 0.0 for knee and 30.0 for ankle.\n        current_threshold: The current threshold to apply to the actuators during homing. Default is 5000.\n        velocity_threshold: The velocity threshold to apply to the actuators during homing. Default is 0.001.\n        callbacks  Optional[dict[str, Callable]]:\n            Optional dictionary of callback functions, one per actuator, to be called when each actuator's\n            homing completes. Only one callback per actuator is supported, and the tag must match.\n            Each function should take no arguments and return None. If None, no callbacks are used.\n    \"\"\"\n    if output_position_offset is None:\n        output_position_offset = {\"knee\": 0.0, \"ankle\": np.deg2rad(30.0)}\n    if homing_direction is None:\n        homing_direction = {\"knee\": -1, \"ankle\": -1}\n    for actuator in self.actuators.values():\n        callback = callbacks.get(actuator.tag, None) if callbacks is not None else None\n        actuator.home(\n            homing_voltage=homing_voltage,\n            homing_frequency=homing_frequency,\n            homing_direction=homing_direction[actuator.tag],\n            output_position_offset=output_position_offset[actuator.tag],\n            current_threshold=current_threshold,\n            velocity_threshold=velocity_threshold,\n            callback=callback,\n        )\n\n    LOGGER.info(\n        \"OSL homing complete. If you'd like to create or load encoder maps to \"\n        \"correct for nonlinearities, call `make_encoder_linearization_map()` method.\"\n    )\n</code></pre>"},{"location":"api/robots/osl/#opensourceleg.robots.osl.OpenSourceLeg.make_encoder_linearization_map","title":"<code>make_encoder_linearization_map(overwrite=False)</code>","text":"<p>This method makes a lookup table to calculate the position measured by the joint encoder. This is necessary because the magnetic output encoders are nonlinear. By making the map while the joint is unloaded, joint position calculated by motor position * gear ratio should be the same as the true joint position. Output from this function is a file containing a_i values parameterizing the map.</p> Eqn <p>position = sum from i=0^5 (a_i*counts^i)</p> Author <p>Kevin Best (tkbest@umich.edu), Senthur Ayyappan (senthura@umich.edu)</p> Source code in <code>opensourceleg/robots/osl.py</code> <pre><code>def make_encoder_linearization_map(\n    self,\n    overwrite: bool = False,\n) -&gt; None:\n    \"\"\"\n    This method makes a lookup table to calculate the position measured by the joint encoder.\n    This is necessary because the magnetic output encoders are nonlinear.\n    By making the map while the joint is unloaded, joint position calculated by motor position * gear ratio\n    should be the same as the true joint position. Output from this function is a file containing a_i values\n    parameterizing the map.\n\n    Eqn:\n        position = sum from i=0^5 (a_i*counts^i)\n\n    Author:\n        Kevin Best (tkbest@umich.edu),\n        Senthur Ayyappan (senthura@umich.edu)\n    \"\"\"\n    for actuator_key in self.actuators:\n        if f\"joint_encoder_{actuator_key}\" in self.sensors:\n            self._create_linear_joint_mapping(\n                actuator_key=actuator_key,\n                encoder_key=f\"joint_encoder_{actuator_key}\",\n                overwrite=overwrite,\n            )\n        else:\n            LOGGER.warning(\n                f\"[{actuator_key}] No joint encoder found. Skipping. \"\n                f\"Encoder tags should be of the form 'joint_encoder_{actuator_key}'.\"\n            )\n</code></pre>"},{"location":"api/robots/osl/#opensourceleg.robots.osl.OpenSourceLeg.start","title":"<code>start()</code>","text":"<p>Start the OSL.</p> Source code in <code>opensourceleg/robots/osl.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"\n    Start the OSL.\n    \"\"\"\n    super().start()\n</code></pre>"},{"location":"api/robots/osl/#opensourceleg.robots.osl.OpenSourceLeg.stop","title":"<code>stop()</code>","text":"<p>Stop the OSL.</p> Source code in <code>opensourceleg/robots/osl.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"\n    Stop the OSL.\n    \"\"\"\n    super().stop()\n</code></pre>"},{"location":"api/robots/osl/#opensourceleg.robots.osl.OpenSourceLeg.update","title":"<code>update()</code>","text":"<p>Update the robot.</p> Source code in <code>opensourceleg/robots/osl.py</code> <pre><code>def update(self) -&gt; None:\n    \"\"\"\n    Update the robot.\n    \"\"\"\n    super().update()\n</code></pre>"},{"location":"api/robots/robots/","title":"Base","text":"<p>Module for the RobotBase abstract class.</p> <p>This module defines an abstract base class, <code>RobotBase</code>, that provides a template for a robot system integrating actuators and sensors. The class supports context management and defines abstract methods for starting, stopping, and updating the robot's components.</p>"},{"location":"api/robots/robots/#opensourceleg.robots.base.RobotBase","title":"<code>RobotBase</code>","text":"<p>               Bases: <code>ABC</code>, <code>Generic[TActuator, TSensor]</code></p> <p>Abstract base class representing a robot composed of actuators and sensors.</p> <p>This class provides the basic structure for a robot, including methods to start, stop, and update its components. It also supports context management so that the robot can be used within a with-statement to automatically start and stop its components.</p> <p>This class is generic and can be parameterized with actuator and sensor types that must be subclasses of ActuatorBase and SensorBase respectively.</p> <p>Attributes:</p> Name Type Description <code>actuators</code> <code>dict[str, TActuator]</code> <p>A dictionary mapping actuator names to actuator instances.</p> <code>sensors</code> <code>dict[str, TSensor]</code> <p>A dictionary mapping sensor names to sensor instances.</p> Source code in <code>opensourceleg/robots/base.py</code> <pre><code>class RobotBase(ABC, Generic[TActuator, TSensor]):\n    \"\"\"\n    Abstract base class representing a robot composed of actuators and sensors.\n\n    This class provides the basic structure for a robot, including methods to start, stop,\n    and update its components. It also supports context management so that the robot\n    can be used within a with-statement to automatically start and stop its components.\n\n    This class is generic and can be parameterized with actuator and sensor types that\n    must be subclasses of ActuatorBase and SensorBase respectively.\n\n    Attributes:\n        actuators (dict[str, TActuator]): A dictionary mapping actuator names to actuator instances.\n        sensors (dict[str, TSensor]): A dictionary mapping sensor names to sensor instances.\n    \"\"\"\n\n    def __init__(\n        self,\n        tag: str,\n        actuators: dict[str, TActuator],\n        sensors: dict[str, TSensor],\n    ) -&gt; None:\n        \"\"\"\n        Initialize the RobotBase instance.\n\n        Args:\n            tag (str): A unique identifier for the robot.\n            actuators (dict[str, TActuator]): A dictionary of actuators keyed by their names.\n            sensors (dict[str, TSensor]): A dictionary of sensors keyed by their names.\n        \"\"\"\n        self._tag = tag\n        self.actuators: dict[str, TActuator] = actuators\n        self.sensors: dict[str, TSensor] = sensors\n\n    def __enter__(self) -&gt; \"RobotBase\":\n        \"\"\"\n        Enter the runtime context for the robot.\n\n        This method starts all actuators and sensors and returns the robot instance.\n\n        Returns:\n            RobotBase: The current robot instance.\n\n        Example:\n            &gt;&gt;&gt; with MyRobot() as robot:\n            ...     robot.update()\n        \"\"\"\n        self.start()\n        return self\n\n    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -&gt; None:\n        \"\"\"\n        Exit the runtime context for the robot.\n\n        This method stops all actuators and sensors.\n\n        Args:\n            exc_type (Any): The exception type, if an exception occurred.\n            exc_val (Any): The exception value, if an exception occurred.\n            exc_tb (Any): The traceback, if an exception occurred.\n        \"\"\"\n        self.stop()\n\n    @abstractmethod\n    def start(self) -&gt; None:\n        \"\"\"\n        Start all actuators and sensors.\n\n        For each actuator in the actuators dictionary, a debug message is logged and its start method is called.\n        Similarly, for each sensor in the sensors dictionary, a debug message is logged and its start method is called.\n\n        Returns:\n            None\n\n        Example:\n            &gt;&gt;&gt; robot = MyRobot()\n            &gt;&gt;&gt; robot.start()\n        \"\"\"\n        for actuator in self.actuators.values():\n            LOGGER.debug(f\"Calling start method of {actuator.tag}\")\n            actuator.start()\n\n        for sensor in self.sensors.values():\n            LOGGER.debug(f\"Calling start method of {sensor}\")\n            sensor.start()\n\n    @abstractmethod\n    def stop(self) -&gt; None:\n        \"\"\"\n        Stop all actuators and sensors.\n\n        For each actuator in the actuators dictionary, a debug message is logged and its stop method is called.\n        Similarly, for each sensor in the sensors dictionary, a debug message is logged and its stop method is called.\n\n        Returns:\n            None\n\n        Example:\n            &gt;&gt;&gt; robot = MyRobot()\n            &gt;&gt;&gt; robot.start()\n            ... # Do something with the robot\n            &gt;&gt;&gt; robot.stop()\n        \"\"\"\n        for actuator in self.actuators.values():\n            LOGGER.debug(f\"Calling stop method of {actuator.tag}\")\n            actuator.stop()\n\n        for sensor in self.sensors.values():\n            LOGGER.debug(f\"Calling stop method of {sensor}\")\n            sensor.stop()\n\n    @abstractmethod\n    def update(self) -&gt; None:\n        \"\"\"\n        Update all actuators and sensors.\n\n        This method calls the update method for each actuator and sensor to refresh their state.\n\n        Returns:\n            None\n\n        Example:\n            &gt;&gt;&gt; robot = MyRobot()\n            &gt;&gt;&gt; robot.start()\n            &gt;&gt;&gt; robot.update()\n        \"\"\"\n        for actuator in self.actuators.values():\n            actuator.update()\n\n        for sensor in self.sensors.values():\n            sensor.update()\n\n    @property\n    def tag(self) -&gt; str:\n        \"\"\"\n        Get the unique identifier (tag) of the robot.\n\n        Returns:\n            str: The robot's tag.\n\n        Example:\n            &gt;&gt;&gt; robot = MyRobot()\n            &gt;&gt;&gt; robot.tag\n            \"my_robot\"\n        \"\"\"\n        return self._tag\n</code></pre>"},{"location":"api/robots/robots/#opensourceleg.robots.base.RobotBase.tag","title":"<code>tag</code>  <code>property</code>","text":"<p>Get the unique identifier (tag) of the robot.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The robot's tag.</p> Example <p>robot = MyRobot() robot.tag \"my_robot\"</p>"},{"location":"api/robots/robots/#opensourceleg.robots.base.RobotBase.__enter__","title":"<code>__enter__()</code>","text":"<p>Enter the runtime context for the robot.</p> <p>This method starts all actuators and sensors and returns the robot instance.</p> <p>Returns:</p> Name Type Description <code>RobotBase</code> <code>RobotBase</code> <p>The current robot instance.</p> Example <p>with MyRobot() as robot: ...     robot.update()</p> Source code in <code>opensourceleg/robots/base.py</code> <pre><code>def __enter__(self) -&gt; \"RobotBase\":\n    \"\"\"\n    Enter the runtime context for the robot.\n\n    This method starts all actuators and sensors and returns the robot instance.\n\n    Returns:\n        RobotBase: The current robot instance.\n\n    Example:\n        &gt;&gt;&gt; with MyRobot() as robot:\n        ...     robot.update()\n    \"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"api/robots/robots/#opensourceleg.robots.base.RobotBase.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Exit the runtime context for the robot.</p> <p>This method stops all actuators and sensors.</p> <p>Parameters:</p> Name Type Description Default <code>exc_type</code> <code>Any</code> <p>The exception type, if an exception occurred.</p> required <code>exc_val</code> <code>Any</code> <p>The exception value, if an exception occurred.</p> required <code>exc_tb</code> <code>Any</code> <p>The traceback, if an exception occurred.</p> required Source code in <code>opensourceleg/robots/base.py</code> <pre><code>def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -&gt; None:\n    \"\"\"\n    Exit the runtime context for the robot.\n\n    This method stops all actuators and sensors.\n\n    Args:\n        exc_type (Any): The exception type, if an exception occurred.\n        exc_val (Any): The exception value, if an exception occurred.\n        exc_tb (Any): The traceback, if an exception occurred.\n    \"\"\"\n    self.stop()\n</code></pre>"},{"location":"api/robots/robots/#opensourceleg.robots.base.RobotBase.__init__","title":"<code>__init__(tag, actuators, sensors)</code>","text":"<p>Initialize the RobotBase instance.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>A unique identifier for the robot.</p> required <code>actuators</code> <code>dict[str, TActuator]</code> <p>A dictionary of actuators keyed by their names.</p> required <code>sensors</code> <code>dict[str, TSensor]</code> <p>A dictionary of sensors keyed by their names.</p> required Source code in <code>opensourceleg/robots/base.py</code> <pre><code>def __init__(\n    self,\n    tag: str,\n    actuators: dict[str, TActuator],\n    sensors: dict[str, TSensor],\n) -&gt; None:\n    \"\"\"\n    Initialize the RobotBase instance.\n\n    Args:\n        tag (str): A unique identifier for the robot.\n        actuators (dict[str, TActuator]): A dictionary of actuators keyed by their names.\n        sensors (dict[str, TSensor]): A dictionary of sensors keyed by their names.\n    \"\"\"\n    self._tag = tag\n    self.actuators: dict[str, TActuator] = actuators\n    self.sensors: dict[str, TSensor] = sensors\n</code></pre>"},{"location":"api/robots/robots/#opensourceleg.robots.base.RobotBase.start","title":"<code>start()</code>  <code>abstractmethod</code>","text":"<p>Start all actuators and sensors.</p> <p>For each actuator in the actuators dictionary, a debug message is logged and its start method is called. Similarly, for each sensor in the sensors dictionary, a debug message is logged and its start method is called.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Example <p>robot = MyRobot() robot.start()</p> Source code in <code>opensourceleg/robots/base.py</code> <pre><code>@abstractmethod\ndef start(self) -&gt; None:\n    \"\"\"\n    Start all actuators and sensors.\n\n    For each actuator in the actuators dictionary, a debug message is logged and its start method is called.\n    Similarly, for each sensor in the sensors dictionary, a debug message is logged and its start method is called.\n\n    Returns:\n        None\n\n    Example:\n        &gt;&gt;&gt; robot = MyRobot()\n        &gt;&gt;&gt; robot.start()\n    \"\"\"\n    for actuator in self.actuators.values():\n        LOGGER.debug(f\"Calling start method of {actuator.tag}\")\n        actuator.start()\n\n    for sensor in self.sensors.values():\n        LOGGER.debug(f\"Calling start method of {sensor}\")\n        sensor.start()\n</code></pre>"},{"location":"api/robots/robots/#opensourceleg.robots.base.RobotBase.stop","title":"<code>stop()</code>  <code>abstractmethod</code>","text":"<p>Stop all actuators and sensors.</p> <p>For each actuator in the actuators dictionary, a debug message is logged and its stop method is called. Similarly, for each sensor in the sensors dictionary, a debug message is logged and its stop method is called.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Example <p>robot = MyRobot() robot.start() ... # Do something with the robot robot.stop()</p> Source code in <code>opensourceleg/robots/base.py</code> <pre><code>@abstractmethod\ndef stop(self) -&gt; None:\n    \"\"\"\n    Stop all actuators and sensors.\n\n    For each actuator in the actuators dictionary, a debug message is logged and its stop method is called.\n    Similarly, for each sensor in the sensors dictionary, a debug message is logged and its stop method is called.\n\n    Returns:\n        None\n\n    Example:\n        &gt;&gt;&gt; robot = MyRobot()\n        &gt;&gt;&gt; robot.start()\n        ... # Do something with the robot\n        &gt;&gt;&gt; robot.stop()\n    \"\"\"\n    for actuator in self.actuators.values():\n        LOGGER.debug(f\"Calling stop method of {actuator.tag}\")\n        actuator.stop()\n\n    for sensor in self.sensors.values():\n        LOGGER.debug(f\"Calling stop method of {sensor}\")\n        sensor.stop()\n</code></pre>"},{"location":"api/robots/robots/#opensourceleg.robots.base.RobotBase.update","title":"<code>update()</code>  <code>abstractmethod</code>","text":"<p>Update all actuators and sensors.</p> <p>This method calls the update method for each actuator and sensor to refresh their state.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Example <p>robot = MyRobot() robot.start() robot.update()</p> Source code in <code>opensourceleg/robots/base.py</code> <pre><code>@abstractmethod\ndef update(self) -&gt; None:\n    \"\"\"\n    Update all actuators and sensors.\n\n    This method calls the update method for each actuator and sensor to refresh their state.\n\n    Returns:\n        None\n\n    Example:\n        &gt;&gt;&gt; robot = MyRobot()\n        &gt;&gt;&gt; robot.start()\n        &gt;&gt;&gt; robot.update()\n    \"\"\"\n    for actuator in self.actuators.values():\n        actuator.update()\n\n    for sensor in self.sensors.values():\n        sensor.update()\n</code></pre>"},{"location":"api/sensors/adc/","title":"ADC","text":"<p>Module for communicating with the ADS131M0x family of ADC chips.</p>"},{"location":"api/sensors/adc/#opensourceleg.sensors.adc.ADS131M0x","title":"<code>ADS131M0x</code>","text":"<p>               Bases: <code>ADCBase</code></p> <p>Class for communication with the ADS131M0x family of ADC chips.</p> <p>This class allows configuration of the ADS131M0x chips and reading ADC values in millivolts.</p> Source code in <code>opensourceleg/sensors/adc.py</code> <pre><code>class ADS131M0x(ADCBase):\n    \"\"\"\n    Class for communication with the ADS131M0x family of ADC chips.\n\n    This class allows configuration of the ADS131M0x chips and reading ADC values in millivolts.\n    \"\"\"\n\n    # Class attributes\n    _MAX_CHANNELS = 8\n    _BYTES_PER_WORD = 3\n    _RESOLUTION = 24\n    _SPI_MODE = 1\n    _DATA_RATES = (250, 500, 1000, 2000, 4000, 8000, 16000, 32000)\n\n    _BLANK_WORD: ClassVar[list[int]] = [0x00, 0x00, 0x00]\n    _RESET_WORD: ClassVar[list[int]] = [0x00, 0x11, 0x00]\n    _STANDBY_WORD: ClassVar[list[int]] = [0x00, 0x22, 0x00]\n    _WAKEUP_WORD: ClassVar[list[int]] = [0x00, 0x33, 0x00]\n    _RREG_PREFIX = 0b101\n    _WREG_PREFIX = 0b011\n\n    _ID_REG = 0x00\n    _STATUS_REG = 0x01\n    _MODE_REG = 0x02\n    _CLOCK_REG = 0x03\n    _GAIN1_REG = 0x04\n    _GAIN2_REG = 0x05\n    _CFG_REG = 0x06\n\n    _DISABLE_CHANNELS_CLOCK = 0x000E\n    _ENABLE_CHANNELS_CLOCK = 0xFF0E\n    _MODE_CFG = 0x0110\n\n    _OCAL_MSB_ADDRS: ClassVar[list[int]] = [0x0A, 0x0F, 0x14, 0x19, 0x1E, 0x23, 0x28, 0x2D]\n    _OCAL_LSB_ADDRS: ClassVar[list[int]] = [0x0B, 0x10, 0x15, 0x1A, 0x1F, 0x24, 0x29, 0x2E]\n    _GCAL_MSB_ADDRS: ClassVar[list[int]] = [0x0C, 0x11, 0x16, 0x1B, 0x20, 0x25, 0x2A, 0x2F]\n    _GCAL_LSB_ADDRS: ClassVar[list[int]] = [0x0D, 0x12, 0x17, 0x1C, 0x21, 0x26, 0x2B, 0x30]\n    _CHANNEL_CFG_ADDRS: ClassVar[list[int]] = [0x09, 0x0E, 0x13, 0x18, 0x1D, 0x22, 0x27, 0x2C]\n\n    _GCAL_STEP_SIZE = 1.19e-7\n    _READY_STATUS_BASE = 0x05 &lt;&lt; 8\n\n    def __init__(\n        self,\n        tag: str = \"ADS131M0x\",\n        spi_bus: int = 0,\n        spi_cs: int = 0,\n        data_rate: int = 500,\n        clock_freq: int = 8192000,\n        num_channels: int = 6,\n        gains: list[int] = [1] * 6,\n        voltage_reference: float = 1.2,\n        gain_error: Optional[list[int]] = None,\n        offline: bool = False,\n    ):\n        \"\"\"\n        Initialize the ADS131M0x instance.\n\n        Args:\n            tag (str): Identifier for the ADC instance. Default is \"ADS131M0x\".\n            spi_bus (int): SPI bus number. Default is 0.\n            spi_cs (int): SPI chip select line. Default is 0.\n            data_rate (int): Sampling rate in Hz. Default is 500 Hz.\n            clock_freq (int): SPI clock frequency in Hz. Default is 8192000 Hz.\n            num_channels (int): Number of ADC channels. Default is 6.\n            gains (List[int]): Programmable gain values for each channel. Default is [1] * num_channels.\n            voltage_reference (float): Reference voltage in volts. Default is 1.2 V.\n            gain_error (List[int]): Gain error correction values for each channel. Default is None.\n            offline (bool): If True, the ADC operates in offline mode. Default is False.\n\n        Raises:\n            ValueError: If the configuration parameters are invalid.\n        \"\"\"\n\n        try:\n            import spidev\n\n            self._spi = spidev.SpiDev()\n        except ImportError as e:\n            LOGGER.error(\"spidev is not installed. Please install it to use this module.\")\n            raise ImportError(\"spidev is required but not installed.\") from e\n\n        if len(gains) != num_channels:\n            raise ValueError(\"Length of gains must equal the number of channels.\")\n        if (gain_error is not None) and (len(gain_error) != num_channels):\n            raise ValueError(\"Length of gain_error must equal the number of channels.\")\n        if data_rate not in self._DATA_RATES:\n            raise ValueError(f\"Invalid data rate. Must be one of {self._DATA_RATES}.\")\n\n        self._spi_bus = spi_bus\n        self._spi_cs = spi_cs\n        self._num_channels = num_channels\n        self._clock_freq = clock_freq\n        self._data_rate = data_rate\n        self._gain_exponents = self._calculate_gain_exponents(gains)\n        self._voltage_reference = voltage_reference\n        self._gain_error = gain_error\n        self._streaming = False\n        self._words_per_frame = 2 + num_channels\n        self._ready_status = self._calculate_ready_status()\n        self._data_counts = np.empty(self.num_channels, dtype=int)\n        self._data = np.empty(self.num_channels, dtype=float)\n\n    def __repr__(self) -&gt; str:\n        return \"ADS131M0x\"\n\n    def start(self) -&gt; None:\n        \"\"\"\n        Start the ADC by opening the SPI port, resetting the device, configuring gain settings,\n        and transitioning to continuous conversion mode.\n        \"\"\"\n        LOGGER.info(\"Starting ADC...\")\n        self._spi.open(self._spi_bus, self._spi_cs)\n        self._spi.max_speed_hz = self._clock_freq\n        self._spi.mode = self._SPI_MODE\n\n        self.reset()\n        self._set_gain()\n        self._set_device_state(1)\n        self._clear_stale_data()\n        LOGGER.info(\"ADC started successfully.\")\n\n    def stop(self) -&gt; None:\n        \"\"\"\n        Stop the ADC by transitioning to standby mode and closing the SPI port.\n        \"\"\"\n        LOGGER.info(\"Stopping ADC...\")\n        self._set_device_state(0)\n        self._spi.close()\n        LOGGER.info(\"ADC stopped successfully.\")\n\n    def reset(self) -&gt; None:\n        \"\"\"\n        Reset the ADC by sending the reset command via SPI.\n        \"\"\"\n        self._spi.xfer2(self._RESET_WORD + self._BLANK_WORD * (self._words_per_frame - 1))\n\n    def update(self) -&gt; None:\n        \"\"\"\n        Update the ADC data by reading the latest voltage values in millivolts.\n        Attempts to read a maximum of 1000 times before throwing an error.\n        \"\"\"\n        MAX_ATTEMPTS = 1000\n        attempts = 0\n        while not self._ready_to_read():\n            sleep(0.001)\n            attempts += 1\n            if attempts &gt; MAX_ATTEMPTS:\n                raise RuntimeError(\n                    \"Couldn't connect to the ADC, please ensure that the device is connected and powered on.\"\n                )\n\n        self._data = self._read_data_millivolts()\n\n    def calibrate(self) -&gt; None:\n        \"\"\"\n        Perform offset and gain calibration on the ADC.\n        \"\"\"\n        self._offset_calibration()\n        # if self._gain_error is not None:\n        #     self._gain_calibration()\n\n    def read_register(self, address: int) -&gt; int:\n        \"\"\"\n        Read the value of a register at the specified address.\n\n        Args:\n            address (int): Address of the register to read.\n\n        Returns:\n            int: Value stored in the register.\n        \"\"\"\n        msg = (address &lt;&lt; 7) | (self._RREG_PREFIX &lt;&lt; 13)\n        word = self._message_to_word(msg)\n        rsp = self._spi_message(word)\n        return int(rsp[0] &lt;&lt; 8 | rsp[1])\n\n    def write_register(self, address: int, reg_val: int) -&gt; None:\n        \"\"\"\n        Write a value to a register at the specified address.\n\n        Args:\n            address (int): Address of the register to write.\n            reg_val (int): Value to write to the register.\n        \"\"\"\n        addr_msg = (address &lt;&lt; 7) | (self._WREG_PREFIX &lt;&lt; 13)\n        addr_bytes = self._message_to_word(addr_msg)\n        reg_bytes = self._message_to_word(reg_val)\n        self._spi_message(addr_bytes + reg_bytes)\n\n    @property\n    def is_streaming(self) -&gt; bool:\n        \"\"\"\n        Check if the ADC is currently streaming data.\n\n        Returns:\n            bool: True if streaming, False otherwise.\n        \"\"\"\n        return self._streaming\n\n    @property\n    def gains(self) -&gt; np.ndarray:\n        \"\"\"\n        Get the programmable gain values for each channel.\n\n        Returns:\n            np.ndarray: Array of gain values.\n        \"\"\"\n        return np.power(2, self._gain_exponents)\n\n    @property\n    def data(self) -&gt; np.ndarray:\n        \"\"\"\n        Get the latest ADC data in millivolts.\n\n        Returns:\n            np.ndarray: Array of voltage readings for each channel.\n        \"\"\"\n        return self._data\n\n    @property\n    def data_counts(self) -&gt; np.ndarray:\n        \"\"\"\n        Get the latest ADC data in raw counts.\n\n        Returns:\n            np.ndarray: Array of raw ADC counts for each channel.\n        \"\"\"\n        return self._data_counts\n\n    @property\n    def num_channels(self) -&gt; int:\n        \"\"\"\n        Get the number of ADC channels.\n\n        Returns:\n            int: Number of channels.\n        \"\"\"\n        return self._num_channels\n\n    def _calculate_gain_exponents(self, gains: list[int]) -&gt; list[int]:\n        \"\"\"\n        Calculate gain exponents for the programmable gains.\n\n        Args:\n            gains (List[int]): List of programmable gains.\n\n        Returns:\n            List[int]: List of gain exponents.\n\n        Raises:\n            ValueError: If a gain is not a power of 2 between 1 and 128.\n        \"\"\"\n        gain_exponents = []\n        for gain in gains:\n            if not (1 &lt;= gain &lt;= 128 and math.log2(gain).is_integer()):\n                raise ValueError(\"Each gain must be a power of 2 between 1 and 128.\")\n            gain_exponents.append(int(math.log2(gain)))\n        return gain_exponents\n\n    def _calculate_ready_status(self) -&gt; int:\n        \"\"\"\n        Calculate the ready status bitmask for the ADC.\n\n        Returns:\n            int: Ready status bitmask.\n        \"\"\"\n        ready_status = self._READY_STATUS_BASE\n        for i in range(self._num_channels):\n            ready_status |= 1 &lt;&lt; i\n        return ready_status\n\n    def _spi_message(self, msg: list[int]) -&gt; Any:\n        \"\"\"Send SPI message to ADS131M0x.\n\n        Args:\n         - msg (List[int]): message to be sent to the ADS131M0x separated into bytes.\n        Returns:\n            list[int]: The response from the device, representing the entire frame.\n        \"\"\"\n        self._spi.xfer2(msg)\n        return self._spi.readbytes(self._BYTES_PER_WORD * self._words_per_frame)\n\n    def _channel_enable(self, state: bool) -&gt; None:\n        \"\"\"\n        Enable or disable streaming on all channels.\n\n        Args:\n            state (bool): If True, enables the channel clocks; if False, disables them.\n        \"\"\"\n        OSR = (self._clock_freq / 2) / self._data_rate\n        OSR_reg = int(math.log2(OSR) - 7)\n        self._ENABLE_CHANNELS_CLOCK &amp;= ~(0b111 &lt;&lt; 2)\n        self._ENABLE_CHANNELS_CLOCK |= OSR_reg &lt;&lt; 2\n        self._DISABLE_CHANNELS_CLOCK &amp;= ~(0b111 &lt;&lt; 2)\n        self._DISABLE_CHANNELS_CLOCK |= OSR_reg &lt;&lt; 2\n        if state is True:\n            self.write_register(self._CLOCK_REG, self._ENABLE_CHANNELS_CLOCK)\n        elif state is False:\n            self.write_register(self._CLOCK_REG, self._DISABLE_CHANNELS_CLOCK)\n\n    def _set_device_state(self, state: int) -&gt; None:\n        \"\"\"\n        Set the internal state of the ADC device.\n\n        Args:\n            state (int): The desired state:\n                0 -- Standby mode.\n                1 -- Continuous Conversion Mode.\n        \"\"\"\n        if state == 0:\n            self._spi.xfer2(self._STANDBY_WORD + self._BLANK_WORD * (self._words_per_frame - 1))\n            self._streaming = False\n        elif state == 1:\n            self._spi.xfer2(self._WAKEUP_WORD + self._BLANK_WORD * (self._words_per_frame - 1))\n            self._streaming = True\n\n    def _set_voltage_source(self, source: int) -&gt; None:\n        \"\"\"\n        Change the voltage source for the ADC input.\n\n        Args:\n            source (int): The voltage source selection:\n                0 -- external input.\n                1 -- shorts differential pairs for a value near 0.\n                2 -- positive internal test signal ((160mV / gain) * (Vref / 1.25)).\n                3 -- negative internal test signal ((-160mV / gain) * (Vref / 1.25)).\n        \"\"\"\n        for i in range(0, self.num_channels):\n            self.write_register(self._CHANNEL_CFG_ADDRS[i], source)\n\n    def _clear_stale_data(self) -&gt; None:\n        \"\"\"Clears previous 2 stale data points stored in ADC registers.\"\"\"\n        for _ in range(2):\n            self._read_data_counts()\n\n    def _set_gain(self) -&gt; None:\n        \"\"\"Set PGA gain for all channels.\"\"\"\n\n        gains = self._gain_exponents + [0] * (self._MAX_CHANNELS - len(self._gain_exponents))\n        self._channel_enable(False)\n        msg1 = gains[3] &lt;&lt; 12 | gains[2] &lt;&lt; 8 | gains[1] &lt;&lt; 4 | gains[0]\n        self.write_register(self._GAIN1_REG, msg1)\n        msg2 = gains[7] &lt;&lt; 12 | gains[6] &lt;&lt; 8 | gains[5] &lt;&lt; 4 | gains[4]\n        self.write_register(self._GAIN2_REG, msg2)\n        self._channel_enable(True)\n\n    def _offset_calibration(self, n_samples: int = 1000) -&gt; None:\n        \"\"\"Centers the ADC data around the measured zero value.\"\"\"\n        self._set_voltage_source(1)\n        self._clear_stale_data()\n        n_samples = 2**10\n        offsets = np.empty((n_samples, self.num_channels))\n        for i in range(n_samples):\n            offsets[i] = self._read_data_counts()\n        mean_offset = offsets.mean(axis=0, dtype=int)\n\n        for i in range(0, self.num_channels):\n            self.write_register(self._OCAL_MSB_ADDRS[i], mean_offset[i].item() &gt;&gt; 8)\n            self.write_register(self._OCAL_LSB_ADDRS[i], (mean_offset[i].item() &lt;&lt; 8) &amp; 0xFF00)\n        self._set_voltage_source(0)\n\n    def _gain_calibration(self) -&gt; None:\n        \"\"\"Corrects actual gain to desired gain using user-calculated gain error for each channel.\"\"\"\n        for i in range(self.num_channels):\n            if self._gain_error is None:\n                raise ValueError(\"Gain error is not set.\")\n\n            gain_correction = (1 + self._gain_error[i]) / self._GCAL_STEP_SIZE\n            self.write_register(self._GCAL_MSB_ADDRS[i], int(gain_correction) &gt;&gt; 8)\n\n    def _message_to_word(self, msg: int) -&gt; list[int]:\n        \"\"\"Separates message into bytes to be sent to ADC.\"\"\"\n        word = [0] * 3\n        word[0] = (msg &gt;&gt; 8) &amp; 0xFF\n        word[1] = msg &amp; 0xFF\n        return word\n\n    def _ready_to_read(self) -&gt; bool:\n        \"\"\"\n        Check if all ADC channels are ready for a new data read.\n\n        Returns:\n            bool: True if the status register indicates readiness; otherwise, False.\n        \"\"\"\n        reply = self.read_register(self._STATUS_REG)\n        return reply == self._ready_status\n\n    def _read_data_millivolts(self) -&gt; Any:\n        \"\"\"Returns channel readings in millivolts.\"\"\"\n        self._data_counts = self._read_data_counts()\n        mV = 1000 * self._data_counts / 2 ** (self._RESOLUTION - 1) * self._voltage_reference\n        return mV\n\n    def _read_data_counts(self) -&gt; np.ndarray:\n        \"\"\"Returns channel readings in counts ranging from -2^23 -&gt; 2^23-1\"\"\"\n        reply = self._spi.readbytes(self._BYTES_PER_WORD * self._words_per_frame)\n        data_counts = np.empty(self.num_channels, dtype=int)\n        for byte in range(3, self.num_channels * 3 + 1, 3):\n            val = (reply[byte] &lt;&lt; 16) | (reply[byte + 1] &lt;&lt; 8) | reply[byte + 2]\n            data_counts[int(((byte) / 3) - 1)] = self._twos_complement(\n                val,\n                self._RESOLUTION,\n            )\n        return data_counts\n\n    def _twos_complement(self, num: int, bits: int) -&gt; int:\n        \"\"\"\n        Convert an unsigned integer to a signed integer using two's complement representation.\n\n        Args:\n            num (int): The unsigned integer.\n            bits (int): The number of bits used to represent the number.\n\n        Returns:\n            int: The signed integer value.\n        \"\"\"\n        val = num\n        if (num &gt;&gt; (bits - 1)) != 0:\n            val = num - (1 &lt;&lt; bits)\n        return val\n</code></pre>"},{"location":"api/sensors/adc/#opensourceleg.sensors.adc.ADS131M0x.data","title":"<code>data</code>  <code>property</code>","text":"<p>Get the latest ADC data in millivolts.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Array of voltage readings for each channel.</p>"},{"location":"api/sensors/adc/#opensourceleg.sensors.adc.ADS131M0x.data_counts","title":"<code>data_counts</code>  <code>property</code>","text":"<p>Get the latest ADC data in raw counts.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Array of raw ADC counts for each channel.</p>"},{"location":"api/sensors/adc/#opensourceleg.sensors.adc.ADS131M0x.gains","title":"<code>gains</code>  <code>property</code>","text":"<p>Get the programmable gain values for each channel.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Array of gain values.</p>"},{"location":"api/sensors/adc/#opensourceleg.sensors.adc.ADS131M0x.is_streaming","title":"<code>is_streaming</code>  <code>property</code>","text":"<p>Check if the ADC is currently streaming data.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if streaming, False otherwise.</p>"},{"location":"api/sensors/adc/#opensourceleg.sensors.adc.ADS131M0x.num_channels","title":"<code>num_channels</code>  <code>property</code>","text":"<p>Get the number of ADC channels.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of channels.</p>"},{"location":"api/sensors/adc/#opensourceleg.sensors.adc.ADS131M0x.__init__","title":"<code>__init__(tag='ADS131M0x', spi_bus=0, spi_cs=0, data_rate=500, clock_freq=8192000, num_channels=6, gains=[1] * 6, voltage_reference=1.2, gain_error=None, offline=False)</code>","text":"<p>Initialize the ADS131M0x instance.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>Identifier for the ADC instance. Default is \"ADS131M0x\".</p> <code>'ADS131M0x'</code> <code>spi_bus</code> <code>int</code> <p>SPI bus number. Default is 0.</p> <code>0</code> <code>spi_cs</code> <code>int</code> <p>SPI chip select line. Default is 0.</p> <code>0</code> <code>data_rate</code> <code>int</code> <p>Sampling rate in Hz. Default is 500 Hz.</p> <code>500</code> <code>clock_freq</code> <code>int</code> <p>SPI clock frequency in Hz. Default is 8192000 Hz.</p> <code>8192000</code> <code>num_channels</code> <code>int</code> <p>Number of ADC channels. Default is 6.</p> <code>6</code> <code>gains</code> <code>List[int]</code> <p>Programmable gain values for each channel. Default is [1] * num_channels.</p> <code>[1] * 6</code> <code>voltage_reference</code> <code>float</code> <p>Reference voltage in volts. Default is 1.2 V.</p> <code>1.2</code> <code>gain_error</code> <code>List[int]</code> <p>Gain error correction values for each channel. Default is None.</p> <code>None</code> <code>offline</code> <code>bool</code> <p>If True, the ADC operates in offline mode. Default is False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the configuration parameters are invalid.</p> Source code in <code>opensourceleg/sensors/adc.py</code> <pre><code>def __init__(\n    self,\n    tag: str = \"ADS131M0x\",\n    spi_bus: int = 0,\n    spi_cs: int = 0,\n    data_rate: int = 500,\n    clock_freq: int = 8192000,\n    num_channels: int = 6,\n    gains: list[int] = [1] * 6,\n    voltage_reference: float = 1.2,\n    gain_error: Optional[list[int]] = None,\n    offline: bool = False,\n):\n    \"\"\"\n    Initialize the ADS131M0x instance.\n\n    Args:\n        tag (str): Identifier for the ADC instance. Default is \"ADS131M0x\".\n        spi_bus (int): SPI bus number. Default is 0.\n        spi_cs (int): SPI chip select line. Default is 0.\n        data_rate (int): Sampling rate in Hz. Default is 500 Hz.\n        clock_freq (int): SPI clock frequency in Hz. Default is 8192000 Hz.\n        num_channels (int): Number of ADC channels. Default is 6.\n        gains (List[int]): Programmable gain values for each channel. Default is [1] * num_channels.\n        voltage_reference (float): Reference voltage in volts. Default is 1.2 V.\n        gain_error (List[int]): Gain error correction values for each channel. Default is None.\n        offline (bool): If True, the ADC operates in offline mode. Default is False.\n\n    Raises:\n        ValueError: If the configuration parameters are invalid.\n    \"\"\"\n\n    try:\n        import spidev\n\n        self._spi = spidev.SpiDev()\n    except ImportError as e:\n        LOGGER.error(\"spidev is not installed. Please install it to use this module.\")\n        raise ImportError(\"spidev is required but not installed.\") from e\n\n    if len(gains) != num_channels:\n        raise ValueError(\"Length of gains must equal the number of channels.\")\n    if (gain_error is not None) and (len(gain_error) != num_channels):\n        raise ValueError(\"Length of gain_error must equal the number of channels.\")\n    if data_rate not in self._DATA_RATES:\n        raise ValueError(f\"Invalid data rate. Must be one of {self._DATA_RATES}.\")\n\n    self._spi_bus = spi_bus\n    self._spi_cs = spi_cs\n    self._num_channels = num_channels\n    self._clock_freq = clock_freq\n    self._data_rate = data_rate\n    self._gain_exponents = self._calculate_gain_exponents(gains)\n    self._voltage_reference = voltage_reference\n    self._gain_error = gain_error\n    self._streaming = False\n    self._words_per_frame = 2 + num_channels\n    self._ready_status = self._calculate_ready_status()\n    self._data_counts = np.empty(self.num_channels, dtype=int)\n    self._data = np.empty(self.num_channels, dtype=float)\n</code></pre>"},{"location":"api/sensors/adc/#opensourceleg.sensors.adc.ADS131M0x.calibrate","title":"<code>calibrate()</code>","text":"<p>Perform offset and gain calibration on the ADC.</p> Source code in <code>opensourceleg/sensors/adc.py</code> <pre><code>def calibrate(self) -&gt; None:\n    \"\"\"\n    Perform offset and gain calibration on the ADC.\n    \"\"\"\n    self._offset_calibration()\n</code></pre>"},{"location":"api/sensors/adc/#opensourceleg.sensors.adc.ADS131M0x.read_register","title":"<code>read_register(address)</code>","text":"<p>Read the value of a register at the specified address.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>int</code> <p>Address of the register to read.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Value stored in the register.</p> Source code in <code>opensourceleg/sensors/adc.py</code> <pre><code>def read_register(self, address: int) -&gt; int:\n    \"\"\"\n    Read the value of a register at the specified address.\n\n    Args:\n        address (int): Address of the register to read.\n\n    Returns:\n        int: Value stored in the register.\n    \"\"\"\n    msg = (address &lt;&lt; 7) | (self._RREG_PREFIX &lt;&lt; 13)\n    word = self._message_to_word(msg)\n    rsp = self._spi_message(word)\n    return int(rsp[0] &lt;&lt; 8 | rsp[1])\n</code></pre>"},{"location":"api/sensors/adc/#opensourceleg.sensors.adc.ADS131M0x.reset","title":"<code>reset()</code>","text":"<p>Reset the ADC by sending the reset command via SPI.</p> Source code in <code>opensourceleg/sensors/adc.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"\n    Reset the ADC by sending the reset command via SPI.\n    \"\"\"\n    self._spi.xfer2(self._RESET_WORD + self._BLANK_WORD * (self._words_per_frame - 1))\n</code></pre>"},{"location":"api/sensors/adc/#opensourceleg.sensors.adc.ADS131M0x.start","title":"<code>start()</code>","text":"<p>Start the ADC by opening the SPI port, resetting the device, configuring gain settings, and transitioning to continuous conversion mode.</p> Source code in <code>opensourceleg/sensors/adc.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"\n    Start the ADC by opening the SPI port, resetting the device, configuring gain settings,\n    and transitioning to continuous conversion mode.\n    \"\"\"\n    LOGGER.info(\"Starting ADC...\")\n    self._spi.open(self._spi_bus, self._spi_cs)\n    self._spi.max_speed_hz = self._clock_freq\n    self._spi.mode = self._SPI_MODE\n\n    self.reset()\n    self._set_gain()\n    self._set_device_state(1)\n    self._clear_stale_data()\n    LOGGER.info(\"ADC started successfully.\")\n</code></pre>"},{"location":"api/sensors/adc/#opensourceleg.sensors.adc.ADS131M0x.stop","title":"<code>stop()</code>","text":"<p>Stop the ADC by transitioning to standby mode and closing the SPI port.</p> Source code in <code>opensourceleg/sensors/adc.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"\n    Stop the ADC by transitioning to standby mode and closing the SPI port.\n    \"\"\"\n    LOGGER.info(\"Stopping ADC...\")\n    self._set_device_state(0)\n    self._spi.close()\n    LOGGER.info(\"ADC stopped successfully.\")\n</code></pre>"},{"location":"api/sensors/adc/#opensourceleg.sensors.adc.ADS131M0x.update","title":"<code>update()</code>","text":"<p>Update the ADC data by reading the latest voltage values in millivolts. Attempts to read a maximum of 1000 times before throwing an error.</p> Source code in <code>opensourceleg/sensors/adc.py</code> <pre><code>def update(self) -&gt; None:\n    \"\"\"\n    Update the ADC data by reading the latest voltage values in millivolts.\n    Attempts to read a maximum of 1000 times before throwing an error.\n    \"\"\"\n    MAX_ATTEMPTS = 1000\n    attempts = 0\n    while not self._ready_to_read():\n        sleep(0.001)\n        attempts += 1\n        if attempts &gt; MAX_ATTEMPTS:\n            raise RuntimeError(\n                \"Couldn't connect to the ADC, please ensure that the device is connected and powered on.\"\n            )\n\n    self._data = self._read_data_millivolts()\n</code></pre>"},{"location":"api/sensors/adc/#opensourceleg.sensors.adc.ADS131M0x.write_register","title":"<code>write_register(address, reg_val)</code>","text":"<p>Write a value to a register at the specified address.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>int</code> <p>Address of the register to write.</p> required <code>reg_val</code> <code>int</code> <p>Value to write to the register.</p> required Source code in <code>opensourceleg/sensors/adc.py</code> <pre><code>def write_register(self, address: int, reg_val: int) -&gt; None:\n    \"\"\"\n    Write a value to a register at the specified address.\n\n    Args:\n        address (int): Address of the register to write.\n        reg_val (int): Value to write to the register.\n    \"\"\"\n    addr_msg = (address &lt;&lt; 7) | (self._WREG_PREFIX &lt;&lt; 13)\n    addr_bytes = self._message_to_word(addr_msg)\n    reg_bytes = self._message_to_word(reg_val)\n    self._spi_message(addr_bytes + reg_bytes)\n</code></pre>"},{"location":"api/sensors/encoder/","title":"Encoder","text":""},{"location":"api/sensors/encoder/#opensourceleg.sensors.encoder.AS5048B","title":"<code>AS5048B</code>","text":"<p>               Bases: <code>EncoderBase</code></p> Source code in <code>opensourceleg/sensors/encoder.py</code> <pre><code>class AS5048B(EncoderBase):  # ToDo: We use AS5048B -- need to look into name change A-- uses SPI, B uses I2C\n    ENC_RESOLUTION = 2**14  # 14 bit resolution\n    I2C_BASE_ADR_7BIT = 0b1000000  # The adress base on the format &lt;base[6:2]&gt; &lt;A1[1]&gt; &lt;A2[0]&gt;\n\n    ## Register adresses I2C\n    OTP_ZERO_POSITION_HIGH = 0x16  # bit 13 through 6\n    OTP_ZERO_POSITION_LOW = 0x17  # bit 5 through 0 (2 msbs of this aren't used)\n    AUTOMATIC_GAIN_CONTROL = 0xFA  # 0 = high mag field, 255 = low mag field, 8 bit\n    DIAGNOSTICS = 0xFB  # flags: 3 = comp high, 2 = comp low, 1 = COF, 0 = OCF\n    MAGNITUDE_HIGH = 0xFC  # bit 13 through 6\n    MAGNITUDE_LOW = 0xFD  # bit 5 through 0 (2 msbs of this aren't used)\n    ANGLE_HIGH = 0xFE  # bit 13 through 6\n    ANGLE_LOW = 0xFF  # bit 5 through 0 (2 msbs of this aren't used)\n\n    ## Status flags Diagnostics registers\n    FLAG_COMP_H = 0x1 &lt;&lt; 3\n    FLAG_COMP_L = 0x1 &lt;&lt; 2\n    FLAG_COF = 0x1 &lt;&lt; 1\n    FLAG_OCF = 0x1 &lt;&lt; 0\n\n    def __init__(\n        self,\n        tag: str = \"AS5048B\",\n        bus: str = \"/dev/i2c\",\n        A1_adr_pin: bool = False,\n        A2_adr_pin: bool = False,\n        zero_position: int = 0,\n        enable_diagnostics: bool = False,\n        offline: bool = False,\n    ) -&gt; None:\n        \"\"\"\n        Class for the AS5048B encoder, implements the Encoder interface\n\n        https://www.mouser.com/datasheet/2/588/AS5048_DS000298_4_00-2324531.pdf\n\n\n        Args:\n            tag (str): Tag name for the encoder\n            bus (str): Path to the i2c bus ex. '/dev/i2c-1'\n            A1_adr_pin (int): State of the adress pin A1 on the AS5048A module\n            A2_adr_pin (int): State of the adress pin A1 on the AS5048A module\n            zero_position (int): The zero position of the encoder\n\n        Author: Axel Sj\u00f6gren Holtz (axel.sjogren.holtz@vgregion.se),\n                Senthur Ayyappan (senthura@umich.edu)\n        \"\"\"\n        self.bus = bus\n        self.enable_diagnostics = enable_diagnostics\n\n        super().__init__(tag=tag, offline=offline)\n\n        self.addr = AS5048B.I2C_BASE_ADR_7BIT | ((bool(A2_adr_pin)) &lt;&lt; 1) | ((bool(A1_adr_pin)) &lt;&lt; 0)\n        self._reset_data()\n\n        self._zero_to_set = zero_position\n        self._is_streaming = False\n        self._data: Union[bytes, None] = None\n        self.rotations = 0\n        self._SMBus: Union[SMBus, None] = None\n\n        # Cache for frequently used values\n        self._two_pi = 2 * np.pi\n        self._scale_factor = self._two_pi / AS5048B.ENC_RESOLUTION\n\n        self._encoder_map: Union[np.polynomial.polynomial.Polynomial, None] = None\n\n    def start(self) -&gt; None:\n        LOGGER.info(f\"Opening encoder communication: {self.__repr__()}\")\n        self._SMBus = SMBus(self.bus)\n        self.update()  # Use public method instead of _update\n        if self.zero_position != self._zero_to_set:\n            self.zero_position = self._zero_to_set\n            LOGGER.info(f\"Set zero position to {self.zero_position}\")\n\n        self._is_streaming = True\n\n    def stop(self) -&gt; None:\n        if self._SMBus:\n            self._SMBus.close()\n            self._SMBus = None\n        self._reset_data()\n        self._is_streaming = False\n\n    def update(self) -&gt; None:\n        self._read_data_registers()\n\n        if self.enable_diagnostics:\n            self._check_diagnostics()\n\n    def set_encoder_map(self, encoder_map: np.polynomial.polynomial.Polynomial) -&gt; None:\n        \"\"\"\n        Sets the encoder map to correct for nonlinearities in the encoder\n\n        Args:\n            encoder_map (np.polynomial.polynomial.Polynomial): The encoder map to set\n\n        Returns:\n            None\n\n        Examples:\n            &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n            &gt;&gt;&gt; actuator.start()\n            &gt;&gt;&gt; actuator.set_encoder_map(np.polynomial.polynomial.Polynomial(coef=[1, 2, 3, 4, 5]))\n        \"\"\"\n        self._encoder_map = encoder_map\n\n    # def apply_state(self, state: Encoder.State) -&gt; None:\n    # raise NotImplementedError(f\"apply_state not implemented for {self.__class__}\")\n\n    @staticmethod\n    def _get_14bit(bytesToParse: bytes) -&gt; int:\n        return (bytesToParse[0] &lt;&lt; 6) | bytesToParse[1]  # int() is unnecessary\n\n    @staticmethod\n    def _set_14bit(intToParse: int) -&gt; bytes:\n        \"\"\"\n        Convert a 14bit integer to bytes &lt;msb[13:6]&gt;&lt;lsb[5:0]&gt;\n\n        Args\n            intToParse (int): The integer to convert to bytes\n\n        Raises\n            OverflowError: If intToParse &gt;= 2^14\n        \"\"\"\n        if intToParse &gt;= AS5048B.ENC_RESOLUTION:\n            raise OverflowError(f\"Argument intToParse={intToParse} &gt;= 2^14 bit encoder resolution\")\n        return bytes([(intToParse &gt;&gt; 6), intToParse &amp; 0x3F])\n\n    def deg_to_counts(self, angle_deg: float) -&gt; int:\n        return int((AS5048B.ENC_RESOLUTION / 360) * angle_deg)\n\n    def _reset_data(self) -&gt; None:\n        # Use bytearray for better performance when we need to modify\n        self._encdata_old = bytearray(6)\n        self._encdata_old_timestamp = 0\n        self._encdata_new = bytearray(6)\n        self._encdata_new_timestamp = 0\n\n    def _write_registers(self, register: int, data: bytes) -&gt; None:\n        if self._SMBus is None:\n            raise RuntimeError(\"SMBus not initialized. Call start() first.\")\n        self._SMBus.write_i2c_block_data(self.addr, register, data)\n\n    def _read_registers(self, register: int, length: int) -&gt; bytes:\n        if self._SMBus is None:\n            raise RuntimeError(\"SMBus not initialized. Call start() first.\")\n        return bytes(self._SMBus.read_i2c_block_data(self.addr, register, length))\n\n    def _read_data_registers(self) -&gt; None:\n        \"\"\"\n        Read data output registers\n            [0]\n            [1]\n            [2] 0xFC MAG H\n            [3] 0xFD MAG L\n            [4] 0xFE ANG H\n            [5] 0xFF ANG L\n        \"\"\"\n        # Swap references instead of copying data\n        self._encdata_old, self._encdata_new = self._encdata_new, self._encdata_old\n        self._encdata_old_timestamp, self._encdata_new_timestamp = self._encdata_new_timestamp, time.monotonic_ns()\n\n        # Read directly into the bytearray\n        data = self._read_registers(AS5048B.AUTOMATIC_GAIN_CONTROL, 6)\n        self._encdata_new[:] = data\n        self._data = data\n\n    def _check_diagnostics(self) -&gt; None:\n        if not self.diag_OCF:\n            raise OSError(\"Invalid data returned on read, DIAG_OCF != 1\")\n\n        if self.diag_COF:\n            LOGGER.info(\"CORDIC Overflow, sample invalid\")\n\n        if self.diag_compH:\n            LOGGER.info(\"Low magnetic field comp triggered\")\n\n        if self.diag_compL:\n            LOGGER.info(\"High magnetic field comp triggered\")\n\n    @property\n    def position(self) -&gt; float:\n        \"\"\"Get the current angular position in radians\"\"\"\n        signed_output = from_twos_complement(self.counts, 14)\n        raw_position = signed_output * self._scale_factor\n\n        if self._encoder_map is not None:\n            raw_position = self._encoder_map(raw_position)\n\n        return raw_position\n\n    @property\n    def counts(self) -&gt; int:\n        \"\"\"Get the raw encoder output as counts of full scale output.\n\n        Returns:\n            int: Encoder output in counts [0, FS]\n        \"\"\"\n        return AS5048B._get_14bit(self._encdata_new[4:6])\n\n    @property\n    def velocity(self) -&gt; float:\n        \"\"\"Calculate angular velocity in radians per second\"\"\"\n        try:\n            # TODO: Add linearization logic here for the velocity attribute\n            LOGGER.warning(\n                \"Velocity attribute does not use the linearization map. \"\n                \"Please calculate the velocity using the position attribute.\"\n            )\n            encAngleDataOld = AS5048B._get_14bit(self._encdata_old[4:6])\n            encAngleDataNew = AS5048B._get_14bit(self._encdata_new[4:6])\n            # Timediff is converted from ns to s\n            timediff = (self._encdata_new_timestamp - self._encdata_old_timestamp) * 1e-9\n\n            if timediff &lt;= 0:\n                return 0.0\n\n            return (encAngleDataNew - encAngleDataOld) * self._scale_factor / timediff\n\n        except (TypeError, ZeroDivisionError):\n            return 0.0\n\n    @property\n    def abs_ang(self) -&gt; float:\n        \"\"\"Get absolute angular position accounting for rotations\"\"\"\n        try:\n            encAngleDataOld = AS5048B._get_14bit(self._encdata_old[4:6])\n            encAngleDataNew = AS5048B._get_14bit(self._encdata_new[4:6])\n        except TypeError:\n            return self.position\n\n        encAngRadOld = from_twos_complement(encAngleDataOld, 14) * self._scale_factor\n        encAngRadNew = from_twos_complement(encAngleDataNew, 14) * self._scale_factor\n\n        # Detect rotation crossings\n        diff = encAngRadNew - encAngRadOld\n        if diff &gt; 0.9 * self._two_pi:\n            self.rotations -= 1\n        elif diff &lt; -0.9 * self._two_pi:\n            self.rotations += 1\n\n        return encAngRadNew + self._two_pi * self.rotations\n\n    @property\n    def zero_position(self) -&gt; int:\n        \"\"\"Reads the content of the Zero position registers of the Encoder\n\n        Returns:\n            int: The 14 bit value stored in the Zero offset OTP registers\n        \"\"\"\n        registers = self._read_registers(AS5048B.OTP_ZERO_POSITION_HIGH, 2)\n        return AS5048B._get_14bit(registers)\n\n    @zero_position.setter\n    def zero_position(self, value: int) -&gt; None:\n        \"\"\"Sets the zero position OTP registers (but does not burn them)\n\n        Args:\n            value (int): The content of the Zero offset registers\n\n        Raises:\n            OverflowError: If value &gt;= 2^14\n            ValueError: If value is negative or too large\n        \"\"\"\n        if not (0 &lt;= value &lt; (AS5048B.ENC_RESOLUTION - 1)):\n            raise ValueError(f\"Zero position must be between 0 and {AS5048B.ENC_RESOLUTION - 2}\")\n        try:\n            payload = AS5048B._set_14bit(value)\n        except OverflowError as err:\n            raise OverflowError(f\"Argument value={value} &gt;= 2^14 bit encoder resolution\") from err\n        else:\n            self._write_registers(AS5048B.OTP_ZERO_POSITION_HIGH, payload)\n\n    def set_zero_position(self) -&gt; None:\n        \"\"\"\n        Calculates the midpoint between the current endpoints and sets it as\n        the zero position.\n        \"\"\"\n        input(\"Set joint in lower position and press enter\")\n\n        self.zero_position = 0\n        self.update()\n        min_value = from_twos_complement(self.counts, 14)\n\n        input(\"Set joint in upper position and press enter\")\n        self.update()\n        max_value = from_twos_complement(self.counts, 14)\n        mid_value = (min_value + max_value) // 2\n        self.zero_position = to_twos_complement(mid_value, 14)\n        LOGGER.info(f\"[SET] Zero registers: {self.zero_position}\")\n\n    @property\n    def diag_compH(self) -&gt; bool:\n        \"\"\"\n        COMP high, indicated a weak magnetic field. It is\n        recommended to monitor the magnitude value.\n\n        Returns:\n            Status of COMP_H diagnostics flag\n        \"\"\"\n        return bool(self._encdata_new[1] &amp; AS5048B.FLAG_COMP_H)\n\n    @property\n    def diag_compL(self) -&gt; bool:\n        \"\"\"\n        COMP low, indicates a high magnetic field. It is\n        recommended to monitor in addition the magnitude\n        value.\n\n        Returns:\n            Status of COMP_L diagnostics flag\n        \"\"\"\n        return bool(self._encdata_new[1] &amp; AS5048B.FLAG_COMP_L)\n\n    @property\n    def diag_COF(self) -&gt; bool:\n        \"\"\"\n        COF (CORDIC Overflow), logic high indicates an out of\n        range error in the CORDIC part. When this bit is set, the\n        angle and magnitude data is invalid. The absolute output\n        maintains the last valid angular value.\n        Returns:\n            Status of COF diagnostics flag\n        \"\"\"\n        return bool(self._encdata_new[1] &amp; AS5048B.FLAG_COF)\n\n    @property\n    def diag_OCF(self) -&gt; bool:\n        \"\"\"\n        OCF (Offset Compensation Finished), logic high indicates\n        the finished Offset Compensation Algorithm. After power\n        up the flag remains always to logic high.\n\n        Returns:\n            Status of OCF diagnostics flag\n        \"\"\"\n        return bool(self._encdata_new[1] &amp; AS5048B.FLAG_OCF)\n\n    @property\n    def is_streaming(self) -&gt; bool:\n        \"\"\"\n        Check if the encoder is currently streaming.\n\n        Returns:\n            bool: True if the encoder is streaming, False otherwise.\n        \"\"\"\n        return self._is_streaming\n\n    @property\n    def data(self) -&gt; bytes:\n        \"\"\"\n        Get the raw data from the encoder\n\n        Returns:\n            bytes: The latest raw data from the encoder.\n        \"\"\"\n        if self._data is None:\n            return b\"\"  # Return empty bytes if no data available\n\n        return self._data\n\n    @property\n    def encoder_map(self) -&gt; Optional[np.polynomial.polynomial.Polynomial]:\n        \"\"\"\n        Polynomial coefficients defining the encoder map from counts to radians.\n\n        Returns:\n            Optional[np.polynomial.polynomial.Polynomial]: The encoder map\n\n        Examples:\n            &gt;&gt;&gt; encoder = AS5048B(port='/dev/ttyACM0')\n            &gt;&gt;&gt; encoder.start()\n            &gt;&gt;&gt; print(encoder.encoder_map)\n        \"\"\"\n        if self._encoder_map is not None:\n            return self._encoder_map\n        else:\n            LOGGER.warning(msg=\"Encoder map is not set. Please create one using a rbot\")\n            return None\n</code></pre>"},{"location":"api/sensors/encoder/#opensourceleg.sensors.encoder.AS5048B.abs_ang","title":"<code>abs_ang</code>  <code>property</code>","text":"<p>Get absolute angular position accounting for rotations</p>"},{"location":"api/sensors/encoder/#opensourceleg.sensors.encoder.AS5048B.counts","title":"<code>counts</code>  <code>property</code>","text":"<p>Get the raw encoder output as counts of full scale output.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Encoder output in counts [0, FS]</p>"},{"location":"api/sensors/encoder/#opensourceleg.sensors.encoder.AS5048B.data","title":"<code>data</code>  <code>property</code>","text":"<p>Get the raw data from the encoder</p> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>The latest raw data from the encoder.</p>"},{"location":"api/sensors/encoder/#opensourceleg.sensors.encoder.AS5048B.diag_COF","title":"<code>diag_COF</code>  <code>property</code>","text":"<p>COF (CORDIC Overflow), logic high indicates an out of range error in the CORDIC part. When this bit is set, the angle and magnitude data is invalid. The absolute output maintains the last valid angular value. Returns:     Status of COF diagnostics flag</p>"},{"location":"api/sensors/encoder/#opensourceleg.sensors.encoder.AS5048B.diag_OCF","title":"<code>diag_OCF</code>  <code>property</code>","text":"<p>OCF (Offset Compensation Finished), logic high indicates the finished Offset Compensation Algorithm. After power up the flag remains always to logic high.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Status of OCF diagnostics flag</p>"},{"location":"api/sensors/encoder/#opensourceleg.sensors.encoder.AS5048B.diag_compH","title":"<code>diag_compH</code>  <code>property</code>","text":"<p>COMP high, indicated a weak magnetic field. It is recommended to monitor the magnitude value.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Status of COMP_H diagnostics flag</p>"},{"location":"api/sensors/encoder/#opensourceleg.sensors.encoder.AS5048B.diag_compL","title":"<code>diag_compL</code>  <code>property</code>","text":"<p>COMP low, indicates a high magnetic field. It is recommended to monitor in addition the magnitude value.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Status of COMP_L diagnostics flag</p>"},{"location":"api/sensors/encoder/#opensourceleg.sensors.encoder.AS5048B.encoder_map","title":"<code>encoder_map</code>  <code>property</code>","text":"<p>Polynomial coefficients defining the encoder map from counts to radians.</p> <p>Returns:</p> Type Description <code>Optional[Polynomial]</code> <p>Optional[np.polynomial.polynomial.Polynomial]: The encoder map</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; encoder = AS5048B(port='/dev/ttyACM0')\n&gt;&gt;&gt; encoder.start()\n&gt;&gt;&gt; print(encoder.encoder_map)\n</code></pre>"},{"location":"api/sensors/encoder/#opensourceleg.sensors.encoder.AS5048B.is_streaming","title":"<code>is_streaming</code>  <code>property</code>","text":"<p>Check if the encoder is currently streaming.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the encoder is streaming, False otherwise.</p>"},{"location":"api/sensors/encoder/#opensourceleg.sensors.encoder.AS5048B.position","title":"<code>position</code>  <code>property</code>","text":"<p>Get the current angular position in radians</p>"},{"location":"api/sensors/encoder/#opensourceleg.sensors.encoder.AS5048B.velocity","title":"<code>velocity</code>  <code>property</code>","text":"<p>Calculate angular velocity in radians per second</p>"},{"location":"api/sensors/encoder/#opensourceleg.sensors.encoder.AS5048B.zero_position","title":"<code>zero_position</code>  <code>property</code> <code>writable</code>","text":"<p>Reads the content of the Zero position registers of the Encoder</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The 14 bit value stored in the Zero offset OTP registers</p>"},{"location":"api/sensors/encoder/#opensourceleg.sensors.encoder.AS5048B.__init__","title":"<code>__init__(tag='AS5048B', bus='/dev/i2c', A1_adr_pin=False, A2_adr_pin=False, zero_position=0, enable_diagnostics=False, offline=False)</code>","text":"<p>Class for the AS5048B encoder, implements the Encoder interface</p> <p>https://www.mouser.com/datasheet/2/588/AS5048_DS000298_4_00-2324531.pdf</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>Tag name for the encoder</p> <code>'AS5048B'</code> <code>bus</code> <code>str</code> <p>Path to the i2c bus ex. '/dev/i2c-1'</p> <code>'/dev/i2c'</code> <code>A1_adr_pin</code> <code>int</code> <p>State of the adress pin A1 on the AS5048A module</p> <code>False</code> <code>A2_adr_pin</code> <code>int</code> <p>State of the adress pin A1 on the AS5048A module</p> <code>False</code> <code>zero_position</code> <code>int</code> <p>The zero position of the encoder</p> <code>0</code> Axel Sj\u00f6gren Holtz (axel.sjogren.holtz@vgregion.se), <p>Senthur Ayyappan (senthura@umich.edu)</p> Source code in <code>opensourceleg/sensors/encoder.py</code> <pre><code>def __init__(\n    self,\n    tag: str = \"AS5048B\",\n    bus: str = \"/dev/i2c\",\n    A1_adr_pin: bool = False,\n    A2_adr_pin: bool = False,\n    zero_position: int = 0,\n    enable_diagnostics: bool = False,\n    offline: bool = False,\n) -&gt; None:\n    \"\"\"\n    Class for the AS5048B encoder, implements the Encoder interface\n\n    https://www.mouser.com/datasheet/2/588/AS5048_DS000298_4_00-2324531.pdf\n\n\n    Args:\n        tag (str): Tag name for the encoder\n        bus (str): Path to the i2c bus ex. '/dev/i2c-1'\n        A1_adr_pin (int): State of the adress pin A1 on the AS5048A module\n        A2_adr_pin (int): State of the adress pin A1 on the AS5048A module\n        zero_position (int): The zero position of the encoder\n\n    Author: Axel Sj\u00f6gren Holtz (axel.sjogren.holtz@vgregion.se),\n            Senthur Ayyappan (senthura@umich.edu)\n    \"\"\"\n    self.bus = bus\n    self.enable_diagnostics = enable_diagnostics\n\n    super().__init__(tag=tag, offline=offline)\n\n    self.addr = AS5048B.I2C_BASE_ADR_7BIT | ((bool(A2_adr_pin)) &lt;&lt; 1) | ((bool(A1_adr_pin)) &lt;&lt; 0)\n    self._reset_data()\n\n    self._zero_to_set = zero_position\n    self._is_streaming = False\n    self._data: Union[bytes, None] = None\n    self.rotations = 0\n    self._SMBus: Union[SMBus, None] = None\n\n    # Cache for frequently used values\n    self._two_pi = 2 * np.pi\n    self._scale_factor = self._two_pi / AS5048B.ENC_RESOLUTION\n\n    self._encoder_map: Union[np.polynomial.polynomial.Polynomial, None] = None\n</code></pre>"},{"location":"api/sensors/encoder/#opensourceleg.sensors.encoder.AS5048B.set_encoder_map","title":"<code>set_encoder_map(encoder_map)</code>","text":"<p>Sets the encoder map to correct for nonlinearities in the encoder</p> <p>Parameters:</p> Name Type Description Default <code>encoder_map</code> <code>Polynomial</code> <p>The encoder map to set</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n&gt;&gt;&gt; actuator.start()\n&gt;&gt;&gt; actuator.set_encoder_map(np.polynomial.polynomial.Polynomial(coef=[1, 2, 3, 4, 5]))\n</code></pre> Source code in <code>opensourceleg/sensors/encoder.py</code> <pre><code>def set_encoder_map(self, encoder_map: np.polynomial.polynomial.Polynomial) -&gt; None:\n    \"\"\"\n    Sets the encoder map to correct for nonlinearities in the encoder\n\n    Args:\n        encoder_map (np.polynomial.polynomial.Polynomial): The encoder map to set\n\n    Returns:\n        None\n\n    Examples:\n        &gt;&gt;&gt; actuator = DephyActuator(port='/dev/ttyACM0')\n        &gt;&gt;&gt; actuator.start()\n        &gt;&gt;&gt; actuator.set_encoder_map(np.polynomial.polynomial.Polynomial(coef=[1, 2, 3, 4, 5]))\n    \"\"\"\n    self._encoder_map = encoder_map\n</code></pre>"},{"location":"api/sensors/encoder/#opensourceleg.sensors.encoder.AS5048B.set_zero_position","title":"<code>set_zero_position()</code>","text":"<p>Calculates the midpoint between the current endpoints and sets it as the zero position.</p> Source code in <code>opensourceleg/sensors/encoder.py</code> <pre><code>def set_zero_position(self) -&gt; None:\n    \"\"\"\n    Calculates the midpoint between the current endpoints and sets it as\n    the zero position.\n    \"\"\"\n    input(\"Set joint in lower position and press enter\")\n\n    self.zero_position = 0\n    self.update()\n    min_value = from_twos_complement(self.counts, 14)\n\n    input(\"Set joint in upper position and press enter\")\n    self.update()\n    max_value = from_twos_complement(self.counts, 14)\n    mid_value = (min_value + max_value) // 2\n    self.zero_position = to_twos_complement(mid_value, 14)\n    LOGGER.info(f\"[SET] Zero registers: {self.zero_position}\")\n</code></pre>"},{"location":"api/sensors/imu/","title":"IMU","text":"<p>Module for interfacing with IMU sensors using the MSCL and Adafruit libraries.</p> This module provides two IMU sensor implementations <ul> <li>LordMicrostrainIMU: Uses the MSCL library to interface with a Lord Microstrain IMU.</li> <li>BNO055: Uses the Adafruit BNO055 library to interface with a Bosch BNO055 IMU.</li> </ul> Dependencies <ul> <li>MSCL (for LordMicrostrainIMU): https://github.com/LORD-MicroStrain/MSCL/tree/master</li> <li>adafruit_bno055, board, busio (for BNO055)</li> </ul> <p>Ensure that the required libraries are installed and that the library paths are added to PYTHONPATH or sys.path if necessary.</p>"},{"location":"api/sensors/imu/#opensourceleg.sensors.imu.BNO055","title":"<code>BNO055</code>","text":"<p>               Bases: <code>IMUBase</code></p> <p>Sensor class for the Bosch BNO055 IMU.</p> <p>This class wraps the Adafruit BNO055 library to provide an interface consistent with the OSL sensor framework.</p> Connections <ul> <li>The sensor should be connected to the main I2C bus.</li> <li>UART connectivity is not implemented.</li> </ul> Requirements <ul> <li>adafruit_bno055</li> <li>board</li> <li>busio</li> </ul> Author <p>Kevin Best</p> Date <p>8/22/2024</p> Source code in <code>opensourceleg/sensors/imu.py</code> <pre><code>class BNO055(IMUBase):\n    \"\"\"\n    Sensor class for the Bosch BNO055 IMU.\n\n    This class wraps the Adafruit BNO055 library to provide an interface\n    consistent with the OSL sensor framework.\n\n    Connections:\n        - The sensor should be connected to the main I2C bus.\n        - UART connectivity is not implemented.\n\n    Requirements:\n        - adafruit_bno055\n        - board\n        - busio\n\n    Author:\n        Kevin Best\n\n    Date:\n        8/22/2024\n    \"\"\"\n\n    def __init__(\n        self,\n        tag: str = \"BNO055\",\n        addr: int = 40,\n        offline: bool = False,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the BNO055 sensor.\n\n        Args:\n            addr (int, optional): I2C address of the BNO055 sensor. Defaults to 40.\n        \"\"\"\n        # Attempt to import the required libraries.\n        try:\n            import adafruit_bno055\n            import board\n            import busio\n\n            self.adafruit_bno055 = adafruit_bno055\n            self.board = board\n            self.busio = busio\n        except ImportError as e:\n            LOGGER.error(f\"BNO055IMU requires adafruit_bno055, board, and busio packages. Error: {e}\")\n            exit(1)\n\n        super().__init__(tag=tag, offline=offline)\n        self._address: int = addr\n        self._gyro_data: list[float] = [0.0, 0.0, 0.0]\n        self._acc_data: list[float] = [0.0, 0.0, 0.0]\n        self._is_streaming = False\n\n    def start(self) -&gt; None:\n        \"\"\"\n        Start the BNO055 sensor.\n\n        Initializes the I2C bus, creates an instance of the Adafruit BNO055 sensor,\n        configures the sensor settings, and sets the streaming flag to True.\n        \"\"\"\n        i2c = self.busio.I2C(self.board.SCL, self.board.SDA)\n        try:\n            self._adafruit_imu = self.adafruit_bno055.BNO055_I2C(i2c, address=self._address)\n        except ValueError:\n            print(\"BNO055 IMU Not Found on i2c bus! Check wiring!\")\n        self.configure_IMU_settings()\n        self._is_streaming = True\n\n    def stop(self) -&gt; None:\n        \"\"\"\n        Stop the BNO055 sensor.\n\n        Sets the streaming flag to False.\n        \"\"\"\n        self._is_streaming = False\n\n    def update(self) -&gt; None:\n        \"\"\"\n        Update the sensor data from the BNO055.\n\n        Reads the latest acceleration and gyroscopic data from the sensor.\n        \"\"\"\n        self._acc_data = self._adafruit_imu.acceleration\n        self._gyro_data = self._adafruit_imu.gyro\n\n    def configure_IMU_settings(self) -&gt; None:\n        \"\"\"\n        Configure the BNO055 sensor settings.\n\n        Hard-coded configuration:\n            - Enables external crystal.\n            - Sets mode to ACCGYRO_MODE.\n            - Configures accelerometer range to ACCEL_2G and bandwidth to ACCEL_15_63HZ.\n            - Configures gyroscope range to GYRO_1000_DPS and bandwidth to GYRO_23HZ.\n        \"\"\"\n        self._adafruit_imu.use_external_crystal = True\n        self._adafruit_imu.mode = self.adafruit_bno055.ACCGYRO_MODE\n        self._adafruit_imu.accel_range = self.adafruit_bno055.ACCEL_2G\n        self._adafruit_imu.accel_bandwidth = self.adafruit_bno055.ACCEL_15_63HZ\n        self._adafruit_imu.gyro_range = self.adafruit_bno055.GYRO_1000_DPS\n        self._adafruit_imu.gyro_bandwidth = self.adafruit_bno055.GYRO_23HZ\n\n    @property\n    def acc_x(self) -&gt; float:\n        \"\"\"\n        Get the measured acceleration along the x-axis in m/s\u00b2.\n\n        Returns:\n            float: Acceleration (m/s\u00b2) along the x-axis.\n        \"\"\"\n        return self._acc_data[0]\n\n    @property\n    def acc_y(self) -&gt; float:\n        \"\"\"\n        Get the measured acceleration along the y-axis in m/s\u00b2.\n\n        Returns:\n            float: Acceleration (m/s\u00b2) along the y-axis.\n        \"\"\"\n        return self._acc_data[1]\n\n    @property\n    def acc_z(self) -&gt; float:\n        \"\"\"\n        Get the measured acceleration along the z-axis in m/s\u00b2.\n\n        Returns:\n            float: Acceleration (m/s\u00b2) along the z-axis.\n        \"\"\"\n        return self._acc_data[2]\n\n    @property\n    def gyro_x(self) -&gt; float:\n        \"\"\"\n        Get the measured rotational velocity about the x-axis in rad/s.\n\n        Returns:\n            float: Angular velocity (rad/s) about the x-axis.\n        \"\"\"\n        return self._gyro_data[0]\n\n    @property\n    def gyro_y(self) -&gt; float:\n        \"\"\"\n        Get the measured rotational velocity about the y-axis in rad/s.\n\n        Returns:\n            float: Angular velocity (rad/s) about the y-axis.\n        \"\"\"\n        return self._gyro_data[1]\n\n    @property\n    def gyro_z(self) -&gt; float:\n        \"\"\"\n        Get the measured rotational velocity about the z-axis in rad/s.\n\n        Returns:\n            float: Angular velocity (rad/s) about the z-axis.\n        \"\"\"\n        return self._gyro_data[2]\n\n    @property\n    def is_streaming(self) -&gt; bool:\n        \"\"\"\n        Check if the BNO055 sensor is streaming data.\n\n        Returns:\n            bool: True if streaming; otherwise, False.\n        \"\"\"\n        return self._is_streaming\n</code></pre>"},{"location":"api/sensors/imu/#opensourceleg.sensors.imu.BNO055.acc_x","title":"<code>acc_x</code>  <code>property</code>","text":"<p>Get the measured acceleration along the x-axis in m/s\u00b2.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Acceleration (m/s\u00b2) along the x-axis.</p>"},{"location":"api/sensors/imu/#opensourceleg.sensors.imu.BNO055.acc_y","title":"<code>acc_y</code>  <code>property</code>","text":"<p>Get the measured acceleration along the y-axis in m/s\u00b2.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Acceleration (m/s\u00b2) along the y-axis.</p>"},{"location":"api/sensors/imu/#opensourceleg.sensors.imu.BNO055.acc_z","title":"<code>acc_z</code>  <code>property</code>","text":"<p>Get the measured acceleration along the z-axis in m/s\u00b2.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Acceleration (m/s\u00b2) along the z-axis.</p>"},{"location":"api/sensors/imu/#opensourceleg.sensors.imu.BNO055.gyro_x","title":"<code>gyro_x</code>  <code>property</code>","text":"<p>Get the measured rotational velocity about the x-axis in rad/s.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Angular velocity (rad/s) about the x-axis.</p>"},{"location":"api/sensors/imu/#opensourceleg.sensors.imu.BNO055.gyro_y","title":"<code>gyro_y</code>  <code>property</code>","text":"<p>Get the measured rotational velocity about the y-axis in rad/s.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Angular velocity (rad/s) about the y-axis.</p>"},{"location":"api/sensors/imu/#opensourceleg.sensors.imu.BNO055.gyro_z","title":"<code>gyro_z</code>  <code>property</code>","text":"<p>Get the measured rotational velocity about the z-axis in rad/s.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Angular velocity (rad/s) about the z-axis.</p>"},{"location":"api/sensors/imu/#opensourceleg.sensors.imu.BNO055.is_streaming","title":"<code>is_streaming</code>  <code>property</code>","text":"<p>Check if the BNO055 sensor is streaming data.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if streaming; otherwise, False.</p>"},{"location":"api/sensors/imu/#opensourceleg.sensors.imu.BNO055.__init__","title":"<code>__init__(tag='BNO055', addr=40, offline=False)</code>","text":"<p>Initialize the BNO055 sensor.</p> <p>Parameters:</p> Name Type Description Default <code>addr</code> <code>int</code> <p>I2C address of the BNO055 sensor. Defaults to 40.</p> <code>40</code> Source code in <code>opensourceleg/sensors/imu.py</code> <pre><code>def __init__(\n    self,\n    tag: str = \"BNO055\",\n    addr: int = 40,\n    offline: bool = False,\n) -&gt; None:\n    \"\"\"\n    Initialize the BNO055 sensor.\n\n    Args:\n        addr (int, optional): I2C address of the BNO055 sensor. Defaults to 40.\n    \"\"\"\n    # Attempt to import the required libraries.\n    try:\n        import adafruit_bno055\n        import board\n        import busio\n\n        self.adafruit_bno055 = adafruit_bno055\n        self.board = board\n        self.busio = busio\n    except ImportError as e:\n        LOGGER.error(f\"BNO055IMU requires adafruit_bno055, board, and busio packages. Error: {e}\")\n        exit(1)\n\n    super().__init__(tag=tag, offline=offline)\n    self._address: int = addr\n    self._gyro_data: list[float] = [0.0, 0.0, 0.0]\n    self._acc_data: list[float] = [0.0, 0.0, 0.0]\n    self._is_streaming = False\n</code></pre>"},{"location":"api/sensors/imu/#opensourceleg.sensors.imu.BNO055.configure_IMU_settings","title":"<code>configure_IMU_settings()</code>","text":"<p>Configure the BNO055 sensor settings.</p> Hard-coded configuration <ul> <li>Enables external crystal.</li> <li>Sets mode to ACCGYRO_MODE.</li> <li>Configures accelerometer range to ACCEL_2G and bandwidth to ACCEL_15_63HZ.</li> <li>Configures gyroscope range to GYRO_1000_DPS and bandwidth to GYRO_23HZ.</li> </ul> Source code in <code>opensourceleg/sensors/imu.py</code> <pre><code>def configure_IMU_settings(self) -&gt; None:\n    \"\"\"\n    Configure the BNO055 sensor settings.\n\n    Hard-coded configuration:\n        - Enables external crystal.\n        - Sets mode to ACCGYRO_MODE.\n        - Configures accelerometer range to ACCEL_2G and bandwidth to ACCEL_15_63HZ.\n        - Configures gyroscope range to GYRO_1000_DPS and bandwidth to GYRO_23HZ.\n    \"\"\"\n    self._adafruit_imu.use_external_crystal = True\n    self._adafruit_imu.mode = self.adafruit_bno055.ACCGYRO_MODE\n    self._adafruit_imu.accel_range = self.adafruit_bno055.ACCEL_2G\n    self._adafruit_imu.accel_bandwidth = self.adafruit_bno055.ACCEL_15_63HZ\n    self._adafruit_imu.gyro_range = self.adafruit_bno055.GYRO_1000_DPS\n    self._adafruit_imu.gyro_bandwidth = self.adafruit_bno055.GYRO_23HZ\n</code></pre>"},{"location":"api/sensors/imu/#opensourceleg.sensors.imu.BNO055.start","title":"<code>start()</code>","text":"<p>Start the BNO055 sensor.</p> <p>Initializes the I2C bus, creates an instance of the Adafruit BNO055 sensor, configures the sensor settings, and sets the streaming flag to True.</p> Source code in <code>opensourceleg/sensors/imu.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"\n    Start the BNO055 sensor.\n\n    Initializes the I2C bus, creates an instance of the Adafruit BNO055 sensor,\n    configures the sensor settings, and sets the streaming flag to True.\n    \"\"\"\n    i2c = self.busio.I2C(self.board.SCL, self.board.SDA)\n    try:\n        self._adafruit_imu = self.adafruit_bno055.BNO055_I2C(i2c, address=self._address)\n    except ValueError:\n        print(\"BNO055 IMU Not Found on i2c bus! Check wiring!\")\n    self.configure_IMU_settings()\n    self._is_streaming = True\n</code></pre>"},{"location":"api/sensors/imu/#opensourceleg.sensors.imu.BNO055.stop","title":"<code>stop()</code>","text":"<p>Stop the BNO055 sensor.</p> <p>Sets the streaming flag to False.</p> Source code in <code>opensourceleg/sensors/imu.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"\n    Stop the BNO055 sensor.\n\n    Sets the streaming flag to False.\n    \"\"\"\n    self._is_streaming = False\n</code></pre>"},{"location":"api/sensors/imu/#opensourceleg.sensors.imu.BNO055.update","title":"<code>update()</code>","text":"<p>Update the sensor data from the BNO055.</p> <p>Reads the latest acceleration and gyroscopic data from the sensor.</p> Source code in <code>opensourceleg/sensors/imu.py</code> <pre><code>def update(self) -&gt; None:\n    \"\"\"\n    Update the sensor data from the BNO055.\n\n    Reads the latest acceleration and gyroscopic data from the sensor.\n    \"\"\"\n    self._acc_data = self._adafruit_imu.acceleration\n    self._gyro_data = self._adafruit_imu.gyro\n</code></pre>"},{"location":"api/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU","title":"<code>LordMicrostrainIMU</code>","text":"<p>               Bases: <code>IMUBase</code></p> Source code in <code>opensourceleg/sensors/imu.py</code> <pre><code>class LordMicrostrainIMU(IMUBase):\n    # LordMicrostrain-specific offline configuration\n    _OFFLINE_PROPERTIES: ClassVar[list[str]] = [\n        *IMUBase._OFFLINE_PROPERTIES,\n        \"roll\",\n        \"pitch\",\n        \"yaw\",\n        \"vel_x\",\n        \"vel_y\",\n        \"vel_z\",\n        \"timestamp\",\n    ]\n    _OFFLINE_PROPERTY_DEFAULTS: ClassVar[dict[str, Any]] = {\n        **IMUBase._OFFLINE_PROPERTY_DEFAULTS,\n        \"data\": {\n            \"estRoll\": 0.0,\n            \"estPitch\": 0.0,\n            \"estYaw\": 0.0,\n            \"estAngularRateX\": 0.0,\n            \"estAngularRateY\": 0.0,\n            \"estAngularRateZ\": 0.0,\n            \"estLinearAccelX\": 0.0,\n            \"estLinearAccelY\": 0.0,\n            \"estLinearAccelZ\": 0.0,\n            \"estFilterGpsTimeTow\": 0.0,\n        },\n        \"roll\": 0.0,\n        \"pitch\": 0.0,\n        \"yaw\": 0.0,\n        \"vel_x\": 0.0,\n        \"vel_y\": 0.0,\n        \"vel_z\": 0.0,\n        \"timestamp\": 0.0,\n    }\n    \"\"\"\n    Sensor class for the Lord Microstrain IMU.\n\n    This class interfaces with a Lord Microstrain Inertial Measurement Unit (IMU)\n    via the MSCL library. It returns Euler angles (in radians), angular rates (in rad/s),\n    and linear accelerations (in m/s^2).\n\n    Resources:\n        - Download v0.65 MSCL pre-built package for Raspbian:\n          https://github.com/LORD-MicroStrain/MSCL/releases/download/v65.0.0/python3-mscl_65.0.0_arm64.deb\n        - Read the MSCL installation instructions:\n          https://github.com/LORD-MicroStrain/MSCL/blob/master/HowToUseMSCL.md\n        - We assume that the MSCL library is installed in /usr/share/python3-mscl\n\n    Note: MSCL v65 may encounter page alignment errors on some Raspberry Pi 5 kernels.\n        Updating to a newer Raspberry Pi OS image with the rpi-v8 kernel\n        or upgrading to MSCL v67.1.0 resolves the issue:\n        https://github.com/LORD-MicroStrain/MSCL/releases/download/v67.1.0/MSCL_arm64_Python3.11_v67.1.0.deb\n    \"\"\"\n\n    def __init__(\n        self,\n        tag: str = \"LordMicrostrainIMU\",\n        port: str = r\"/dev/ttyUSB0\",\n        baud_rate: int = 921600,\n        frequency: int = 200,\n        update_timeout: int = 500,\n        max_packets: int = 1,\n        return_packets: bool = False,\n        offline: bool = False,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the LordMicrostrainIMU sensor.\n\n        Args:\n            port (str, optional): Serial port for the IMU. Defaults to \"/dev/ttyUSB0\".\n            baud_rate (int, optional): Baud rate for the serial connection. Defaults to 921600.\n            frequency (int, optional): Data streaming frequency in Hz. Defaults to 200.\n            update_timeout (int, optional): Timeout for data packet retrieval in milliseconds. Defaults to 500.\n            max_packets (int, optional): Maximum number of data packets to retrieve. Defaults to 1.\n            return_packets (bool, optional): If True, returns the raw data packets. Defaults to False.\n        \"\"\"\n        # Attempt to import the MSCL library and add its path.\n        try:\n            try:\n                import mscl\n            except (ImportError, ModuleNotFoundError):\n                # Falling back to old method of appending to sys.path for importing older versions of mscl\n                import sys\n\n                legacy_path = \"/usr/share/python3-mscl\"\n                if legacy_path not in sys.path:\n                    sys.path.append(legacy_path)\n                import mscl\n\n            self.mscl = mscl\n        except ImportError:\n            LOGGER.warning(\n                \"Failed to import mscl. Please install the MSCL library from Lord Microstrain and append the path \"\n                \"to the PYTHONPATH or sys.path. Checkout https://github.com/LORD-MicroStrain/MSCL/tree/master \"\n                \"and https://lord-microstrain.github.io/MSCL/Documentation/MSCL%20API%20Documentation/index.html\"\n                \"If you are using a newer version of MSCL, you may need to add /usr/lib/python3.version/dist-packages \\\n                to PYTHONPATH\"\n            )\n\n            if not offline:\n                exit(1)\n\n        self._init_variables(\n            tag=tag,\n            port=port,\n            baud_rate=baud_rate,\n            frequency=frequency,\n            update_timeout=update_timeout,\n            max_packets=max_packets,\n            return_packets=return_packets,\n            offline=offline,\n        )\n\n    def _init_variables(\n        self,\n        tag: str,\n        port: str,\n        baud_rate: int,\n        frequency: int,\n        update_timeout: int,\n        max_packets: int,\n        return_packets: bool,\n        offline: bool,\n    ) -&gt; None:\n        super().__init__(tag=tag, offline=offline)\n        self._port = port\n        self._baud_rate = baud_rate\n        self._frequency = frequency\n        self._update_timeout = update_timeout\n        self._max_packets = max_packets\n        self._return_packets = return_packets\n        self._is_streaming = False\n        self._connection = None\n        self._data: dict[str, float] = {}\n\n    def _configure_mip_channels(self) -&gt; Any:\n        \"\"\"\n        Configure and return the MIP channels for data streaming.\n\n        Sets up the desired channels for:\n          - Estimated orientation (Euler angles)\n          - Estimated angular rate\n          - Estimated linear acceleration\n          - GPS timestamp\n\n        Returns:\n            Any: A configured MipChannels object for the MSCL InertialNode.\n        \"\"\"\n        channels = self.mscl.MipChannels()\n        channels.append(\n            self.mscl.MipChannel(\n                self.mscl.MipTypes.CH_FIELD_ESTFILTER_ESTIMATED_ORIENT_EULER,\n                self.mscl.SampleRate.Hertz(self.frequency),\n            )\n        )\n        channels.append(\n            self.mscl.MipChannel(\n                self.mscl.MipTypes.CH_FIELD_ESTFILTER_ESTIMATED_ANGULAR_RATE,\n                self.mscl.SampleRate.Hertz(self.frequency),\n            )\n        )\n        channels.append(\n            self.mscl.MipChannel(\n                self.mscl.MipTypes.CH_FIELD_ESTFILTER_ESTIMATED_LINEAR_ACCEL,\n                self.mscl.SampleRate.Hertz(self.frequency),\n            )\n        )\n        channels.append(\n            self.mscl.MipChannel(\n                self.mscl.MipTypes.CH_FIELD_ESTFILTER_GPS_TIMESTAMP,\n                self.mscl.SampleRate.Hertz(self.frequency),\n            )\n        )\n\n        return channels\n\n    def set_update_timeout(self, timeout: int) -&gt; None:\n        \"\"\"\n        Set the update timeout for the sensor.\n        \"\"\"\n        self._update_timeout = timeout\n\n    def set_max_packets(self, max_packets: int) -&gt; None:\n        \"\"\"\n        Set the maximum number of packets to retrieve.\n        \"\"\"\n        self._max_packets = max_packets\n\n    def set_return_packets(self, return_packets: bool) -&gt; None:\n        \"\"\"\n        Set the return packets flag.\n        \"\"\"\n        self._return_packets = return_packets\n\n    def start(self) -&gt; None:\n        \"\"\"\n        Start the Lord Microstrain IMU sensor.\n\n        Establishes a serial connection, configures the MIP channels, enables data streaming,\n        and sets the streaming flag to True.\n        \"\"\"\n        try:\n            self._connection = self.mscl.Connection.Serial(os.path.realpath(self.port), self.baud_rate)\n        except RuntimeError as e:\n            LOGGER.error(f\"Failed to connect to the IMU at {self.port}: {e}\")\n            exit(1)\n\n        self._node = self.mscl.InertialNode(self._connection)\n        self._validate_frequency()\n        self._node.setActiveChannelFields(self.mscl.MipTypes.CLASS_ESTFILTER, self._configure_mip_channels())\n        self._node.enableDataStream(self.mscl.MipTypes.CLASS_ESTFILTER)\n        self._is_streaming = True\n\n    @check_sensor_stream\n    def stop(self) -&gt; None:\n        \"\"\"\n        Stop the Lord Microstrain IMU sensor.\n\n        Sets the node to idle mode and updates the streaming flag to False.\n\n        Raises:\n            SensorNotStreamingException: If the sensor is not currently streaming.\n        \"\"\"\n        self._node.setToIdle()\n        self._is_streaming = False\n\n    @check_sensor_stream\n    def ping(self) -&gt; None:\n        \"\"\"\n        Ping the Lord Microstrain IMU sensor to verify connectivity.\n\n        Logs an info message if the ping is successful, otherwise logs an error.\n\n        Raises:\n            SensorNotStreamingException: If the sensor is not currently streaming.\n        \"\"\"\n        response = self._node.ping()\n\n        if response.success():\n            LOGGER.info(f\"Successfully pinged the IMU at {self.port}\")\n        else:\n            LOGGER.error(f\"Failed to ping the IMU at {self.port}\")\n\n    def update(self) -&gt; Union[None, Any]:\n        \"\"\"\n        Retrieve and update IMU data from the sensor. To modify update parameters, use the set_update_timeout,\n        set_max_packets, and set_return_packets methods.\n\n        Returns:\n            Union[None, Any]: Returns the data packets if `return_packets` is True; otherwise, None.\n        \"\"\"\n        data_packets = self._node.getDataPackets(timeout=self.update_timeout, maxPackets=self.max_packets)\n        data_points = data_packets[-1].data()\n        self._data = {data.channelName(): data.as_float() for data in data_points}\n\n        if self.return_packets:\n            return data_packets\n        else:\n            return None\n\n    @property\n    def port(self) -&gt; str:\n        \"\"\"\n        Get the serial port used by the sensor.\n\n        Returns:\n            str: The serial port.\n        \"\"\"\n        return self._port\n\n    @property\n    def baud_rate(self) -&gt; int:\n        \"\"\"\n        Get the baud rate used for the sensor connection.\n\n        Returns:\n            int: The baud rate.\n        \"\"\"\n        return self._baud_rate\n\n    @property\n    def frequency(self) -&gt; int:\n        \"\"\"\n        Get the data streaming frequency of the sensor.\n\n        Returns:\n            int: The streaming frequency in Hz.\n        \"\"\"\n        return self._frequency\n\n    @property\n    def is_streaming(self) -&gt; bool:\n        \"\"\"\n        Check if the sensor is currently streaming data.\n\n        Returns:\n            bool: True if streaming; otherwise, False.\n        \"\"\"\n        return self._is_streaming\n\n    @property\n    def update_timeout(self) -&gt; int:\n        \"\"\"\n        Get the update timeout for the sensor.\n        \"\"\"\n        return self._update_timeout\n\n    @property\n    def max_packets(self) -&gt; int:\n        \"\"\"\n        Get the maximum number of packets to retrieve.\n        \"\"\"\n        return self._max_packets\n\n    @property\n    def return_packets(self) -&gt; bool:\n        \"\"\"\n        Get the return packets flag.\n        \"\"\"\n        return self._return_packets\n\n    @property\n    def data(self) -&gt; dict[str, float]:\n        \"\"\"\n        Get the latest sensor data.\n\n        Returns:\n            dict[str, float]: A dictionary mapping channel names to their float values.\n        \"\"\"\n        return self._data\n\n    @property\n    def roll(self) -&gt; float:\n        \"\"\"\n        Get the estimated roll angle in radians.\n\n        Returns:\n            float: Roll angle (rad).\n        \"\"\"\n        return self._data[\"estRoll\"]\n\n    @property\n    def pitch(self) -&gt; float:\n        \"\"\"\n        Get the estimated pitch angle in radians.\n\n        Returns:\n            float: Pitch angle (rad).\n        \"\"\"\n        return self._data[\"estPitch\"]\n\n    @property\n    def yaw(self) -&gt; float:\n        \"\"\"\n        Get the estimated yaw angle in radians.\n\n        Returns:\n            float: Yaw angle (rad).\n        \"\"\"\n        return self._data[\"estYaw\"]\n\n    @property\n    def vel_x(self) -&gt; float:\n        \"\"\"\n        Get the estimated angular velocity about the x-axis in rad/s.\n\n        Returns:\n            float: Angular velocity (rad/s) about the x-axis.\n        \"\"\"\n        return self._data[\"estAngularRateX\"]\n\n    @property\n    def vel_y(self) -&gt; float:\n        \"\"\"\n        Get the estimated angular velocity about the y-axis in rad/s.\n\n        Returns:\n            float: Angular velocity (rad/s) about the y-axis.\n        \"\"\"\n        return self._data[\"estAngularRateY\"]\n\n    @property\n    def vel_z(self) -&gt; float:\n        \"\"\"\n        Get the estimated angular velocity about the z-axis in rad/s.\n\n        Returns:\n            float: Angular velocity (rad/s) about the z-axis.\n        \"\"\"\n        return self._data[\"estAngularRateZ\"]\n\n    @property\n    def acc_x(self) -&gt; float:\n        \"\"\"\n        Get the estimated linear acceleration along the x-axis in m/s\u00b2.\n\n        Returns:\n            float: Linear acceleration (m/s\u00b2) along the x-axis.\n        \"\"\"\n        return self._data[\"estLinearAccelX\"]\n\n    @property\n    def acc_y(self) -&gt; float:\n        \"\"\"\n        Get the estimated linear acceleration along the y-axis in m/s\u00b2.\n\n        Returns:\n            float: Linear acceleration (m/s\u00b2) along the y-axis.\n        \"\"\"\n        return self._data[\"estLinearAccelY\"]\n\n    @property\n    def acc_z(self) -&gt; float:\n        \"\"\"\n        Get the estimated linear acceleration along the z-axis in m/s\u00b2.\n\n        Returns:\n            float: Linear acceleration (m/s\u00b2) along the z-axis.\n        \"\"\"\n        return self._data[\"estLinearAccelZ\"]\n\n    @property\n    def gyro_x(self) -&gt; float:\n        \"\"\"\n        Get the measured gyroscopic value for the x-axis.\n\n        Note:\n            Gyro data is not available for the Lord Microstrain IMU, so this returns 0.0\n            and logs a warning.\n\n        Returns:\n            float: 0.0\n        \"\"\"\n        LOGGER.warning(\"Gyro data not available for Lord Microstrain IMU\")\n        return 0.0\n\n    @property\n    def gyro_y(self) -&gt; float:\n        \"\"\"\n        Get the measured gyroscopic value for the y-axis.\n\n        Note:\n            Gyro data is not available for the Lord Microstrain IMU, so this returns 0.0\n            and logs a warning.\n\n        Returns:\n            float: 0.0\n        \"\"\"\n        LOGGER.warning(\"Gyro data not available for Lord Microstrain IMU\")\n        return 0.0\n\n    @property\n    def gyro_z(self) -&gt; float:\n        \"\"\"\n        Get the measured gyroscopic value for the z-axis.\n\n        Note:\n            Gyro data is not available for the Lord Microstrain IMU, so this returns 0.0\n            and logs a warning.\n\n        Returns:\n            float: 0.0\n        \"\"\"\n        LOGGER.warning(\"Gyro data not available for Lord Microstrain IMU\")\n        return 0.0\n\n    @property\n    def timestamp(self) -&gt; float:\n        \"\"\"\n        Get the timestamp of the latest data packet in seconds.\n\n        Returns:\n            float: Timestamp (s) from the sensor data.\n        \"\"\"\n        return self._data[\"estFilterGpsTimeTow\"]\n\n    def _validate_frequency(self) -&gt; None:\n        \"\"\"\n        Check and adjust frequency for compatibility with IMU refresh rate.\n        \"\"\"\n\n        imu_sample_rate = self._node.getDataRateBase(self.mscl.MipTypes.CLASS_ESTFILTER)\n\n        if self._frequency &gt; imu_sample_rate or imu_sample_rate % self._frequency != 0:\n            min_dist = float(\"inf\")\n            best_frequency = 200\n\n            for divisor in range(1, int(np.sqrt(imu_sample_rate)) + 1):\n                if imu_sample_rate % divisor == 0:\n                    for candidate in [divisor, imu_sample_rate // divisor]:\n                        dist = abs(self._frequency - candidate)\n                        if dist &lt; min_dist:\n                            min_dist = dist\n                            best_frequency = candidate\n\n            LOGGER.info(\n                f\"\"\"{self._frequency} is not a valid decimation of {imu_sample_rate},\n                choosing closest decimation: {best_frequency}\"\"\"\n            )\n\n            self._frequency = best_frequency\n</code></pre>"},{"location":"api/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.acc_x","title":"<code>acc_x</code>  <code>property</code>","text":"<p>Get the estimated linear acceleration along the x-axis in m/s\u00b2.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Linear acceleration (m/s\u00b2) along the x-axis.</p>"},{"location":"api/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.acc_y","title":"<code>acc_y</code>  <code>property</code>","text":"<p>Get the estimated linear acceleration along the y-axis in m/s\u00b2.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Linear acceleration (m/s\u00b2) along the y-axis.</p>"},{"location":"api/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.acc_z","title":"<code>acc_z</code>  <code>property</code>","text":"<p>Get the estimated linear acceleration along the z-axis in m/s\u00b2.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Linear acceleration (m/s\u00b2) along the z-axis.</p>"},{"location":"api/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.baud_rate","title":"<code>baud_rate</code>  <code>property</code>","text":"<p>Get the baud rate used for the sensor connection.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The baud rate.</p>"},{"location":"api/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.data","title":"<code>data</code>  <code>property</code>","text":"<p>Get the latest sensor data.</p> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>dict[str, float]: A dictionary mapping channel names to their float values.</p>"},{"location":"api/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.frequency","title":"<code>frequency</code>  <code>property</code>","text":"<p>Get the data streaming frequency of the sensor.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The streaming frequency in Hz.</p>"},{"location":"api/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.gyro_x","title":"<code>gyro_x</code>  <code>property</code>","text":"<p>Get the measured gyroscopic value for the x-axis.</p> Note <p>Gyro data is not available for the Lord Microstrain IMU, so this returns 0.0 and logs a warning.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>0.0</p>"},{"location":"api/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.gyro_y","title":"<code>gyro_y</code>  <code>property</code>","text":"<p>Get the measured gyroscopic value for the y-axis.</p> Note <p>Gyro data is not available for the Lord Microstrain IMU, so this returns 0.0 and logs a warning.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>0.0</p>"},{"location":"api/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.gyro_z","title":"<code>gyro_z</code>  <code>property</code>","text":"<p>Get the measured gyroscopic value for the z-axis.</p> Note <p>Gyro data is not available for the Lord Microstrain IMU, so this returns 0.0 and logs a warning.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>0.0</p>"},{"location":"api/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.is_streaming","title":"<code>is_streaming</code>  <code>property</code>","text":"<p>Check if the sensor is currently streaming data.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if streaming; otherwise, False.</p>"},{"location":"api/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.max_packets","title":"<code>max_packets</code>  <code>property</code>","text":"<p>Get the maximum number of packets to retrieve.</p>"},{"location":"api/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.pitch","title":"<code>pitch</code>  <code>property</code>","text":"<p>Get the estimated pitch angle in radians.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Pitch angle (rad).</p>"},{"location":"api/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.port","title":"<code>port</code>  <code>property</code>","text":"<p>Get the serial port used by the sensor.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The serial port.</p>"},{"location":"api/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.return_packets","title":"<code>return_packets</code>  <code>property</code>","text":"<p>Get the return packets flag.</p>"},{"location":"api/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.roll","title":"<code>roll</code>  <code>property</code>","text":"<p>Get the estimated roll angle in radians.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Roll angle (rad).</p>"},{"location":"api/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.timestamp","title":"<code>timestamp</code>  <code>property</code>","text":"<p>Get the timestamp of the latest data packet in seconds.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Timestamp (s) from the sensor data.</p>"},{"location":"api/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.update_timeout","title":"<code>update_timeout</code>  <code>property</code>","text":"<p>Get the update timeout for the sensor.</p>"},{"location":"api/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.vel_x","title":"<code>vel_x</code>  <code>property</code>","text":"<p>Get the estimated angular velocity about the x-axis in rad/s.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Angular velocity (rad/s) about the x-axis.</p>"},{"location":"api/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.vel_y","title":"<code>vel_y</code>  <code>property</code>","text":"<p>Get the estimated angular velocity about the y-axis in rad/s.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Angular velocity (rad/s) about the y-axis.</p>"},{"location":"api/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.vel_z","title":"<code>vel_z</code>  <code>property</code>","text":"<p>Get the estimated angular velocity about the z-axis in rad/s.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Angular velocity (rad/s) about the z-axis.</p>"},{"location":"api/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.yaw","title":"<code>yaw</code>  <code>property</code>","text":"<p>Get the estimated yaw angle in radians.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Yaw angle (rad).</p>"},{"location":"api/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.__init__","title":"<code>__init__(tag='LordMicrostrainIMU', port='/dev/ttyUSB0', baud_rate=921600, frequency=200, update_timeout=500, max_packets=1, return_packets=False, offline=False)</code>","text":"<p>Initialize the LordMicrostrainIMU sensor.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>str</code> <p>Serial port for the IMU. Defaults to \"/dev/ttyUSB0\".</p> <code>'/dev/ttyUSB0'</code> <code>baud_rate</code> <code>int</code> <p>Baud rate for the serial connection. Defaults to 921600.</p> <code>921600</code> <code>frequency</code> <code>int</code> <p>Data streaming frequency in Hz. Defaults to 200.</p> <code>200</code> <code>update_timeout</code> <code>int</code> <p>Timeout for data packet retrieval in milliseconds. Defaults to 500.</p> <code>500</code> <code>max_packets</code> <code>int</code> <p>Maximum number of data packets to retrieve. Defaults to 1.</p> <code>1</code> <code>return_packets</code> <code>bool</code> <p>If True, returns the raw data packets. Defaults to False.</p> <code>False</code> Source code in <code>opensourceleg/sensors/imu.py</code> <pre><code>def __init__(\n    self,\n    tag: str = \"LordMicrostrainIMU\",\n    port: str = r\"/dev/ttyUSB0\",\n    baud_rate: int = 921600,\n    frequency: int = 200,\n    update_timeout: int = 500,\n    max_packets: int = 1,\n    return_packets: bool = False,\n    offline: bool = False,\n) -&gt; None:\n    \"\"\"\n    Initialize the LordMicrostrainIMU sensor.\n\n    Args:\n        port (str, optional): Serial port for the IMU. Defaults to \"/dev/ttyUSB0\".\n        baud_rate (int, optional): Baud rate for the serial connection. Defaults to 921600.\n        frequency (int, optional): Data streaming frequency in Hz. Defaults to 200.\n        update_timeout (int, optional): Timeout for data packet retrieval in milliseconds. Defaults to 500.\n        max_packets (int, optional): Maximum number of data packets to retrieve. Defaults to 1.\n        return_packets (bool, optional): If True, returns the raw data packets. Defaults to False.\n    \"\"\"\n    # Attempt to import the MSCL library and add its path.\n    try:\n        try:\n            import mscl\n        except (ImportError, ModuleNotFoundError):\n            # Falling back to old method of appending to sys.path for importing older versions of mscl\n            import sys\n\n            legacy_path = \"/usr/share/python3-mscl\"\n            if legacy_path not in sys.path:\n                sys.path.append(legacy_path)\n            import mscl\n\n        self.mscl = mscl\n    except ImportError:\n        LOGGER.warning(\n            \"Failed to import mscl. Please install the MSCL library from Lord Microstrain and append the path \"\n            \"to the PYTHONPATH or sys.path. Checkout https://github.com/LORD-MicroStrain/MSCL/tree/master \"\n            \"and https://lord-microstrain.github.io/MSCL/Documentation/MSCL%20API%20Documentation/index.html\"\n            \"If you are using a newer version of MSCL, you may need to add /usr/lib/python3.version/dist-packages \\\n            to PYTHONPATH\"\n        )\n\n        if not offline:\n            exit(1)\n\n    self._init_variables(\n        tag=tag,\n        port=port,\n        baud_rate=baud_rate,\n        frequency=frequency,\n        update_timeout=update_timeout,\n        max_packets=max_packets,\n        return_packets=return_packets,\n        offline=offline,\n    )\n</code></pre>"},{"location":"api/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.ping","title":"<code>ping()</code>","text":"<p>Ping the Lord Microstrain IMU sensor to verify connectivity.</p> <p>Logs an info message if the ping is successful, otherwise logs an error.</p> <p>Raises:</p> Type Description <code>SensorNotStreamingException</code> <p>If the sensor is not currently streaming.</p> Source code in <code>opensourceleg/sensors/imu.py</code> <pre><code>@check_sensor_stream\ndef ping(self) -&gt; None:\n    \"\"\"\n    Ping the Lord Microstrain IMU sensor to verify connectivity.\n\n    Logs an info message if the ping is successful, otherwise logs an error.\n\n    Raises:\n        SensorNotStreamingException: If the sensor is not currently streaming.\n    \"\"\"\n    response = self._node.ping()\n\n    if response.success():\n        LOGGER.info(f\"Successfully pinged the IMU at {self.port}\")\n    else:\n        LOGGER.error(f\"Failed to ping the IMU at {self.port}\")\n</code></pre>"},{"location":"api/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.set_max_packets","title":"<code>set_max_packets(max_packets)</code>","text":"<p>Set the maximum number of packets to retrieve.</p> Source code in <code>opensourceleg/sensors/imu.py</code> <pre><code>def set_max_packets(self, max_packets: int) -&gt; None:\n    \"\"\"\n    Set the maximum number of packets to retrieve.\n    \"\"\"\n    self._max_packets = max_packets\n</code></pre>"},{"location":"api/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.set_return_packets","title":"<code>set_return_packets(return_packets)</code>","text":"<p>Set the return packets flag.</p> Source code in <code>opensourceleg/sensors/imu.py</code> <pre><code>def set_return_packets(self, return_packets: bool) -&gt; None:\n    \"\"\"\n    Set the return packets flag.\n    \"\"\"\n    self._return_packets = return_packets\n</code></pre>"},{"location":"api/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.set_update_timeout","title":"<code>set_update_timeout(timeout)</code>","text":"<p>Set the update timeout for the sensor.</p> Source code in <code>opensourceleg/sensors/imu.py</code> <pre><code>def set_update_timeout(self, timeout: int) -&gt; None:\n    \"\"\"\n    Set the update timeout for the sensor.\n    \"\"\"\n    self._update_timeout = timeout\n</code></pre>"},{"location":"api/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.start","title":"<code>start()</code>","text":"<p>Start the Lord Microstrain IMU sensor.</p> <p>Establishes a serial connection, configures the MIP channels, enables data streaming, and sets the streaming flag to True.</p> Source code in <code>opensourceleg/sensors/imu.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"\n    Start the Lord Microstrain IMU sensor.\n\n    Establishes a serial connection, configures the MIP channels, enables data streaming,\n    and sets the streaming flag to True.\n    \"\"\"\n    try:\n        self._connection = self.mscl.Connection.Serial(os.path.realpath(self.port), self.baud_rate)\n    except RuntimeError as e:\n        LOGGER.error(f\"Failed to connect to the IMU at {self.port}: {e}\")\n        exit(1)\n\n    self._node = self.mscl.InertialNode(self._connection)\n    self._validate_frequency()\n    self._node.setActiveChannelFields(self.mscl.MipTypes.CLASS_ESTFILTER, self._configure_mip_channels())\n    self._node.enableDataStream(self.mscl.MipTypes.CLASS_ESTFILTER)\n    self._is_streaming = True\n</code></pre>"},{"location":"api/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.stop","title":"<code>stop()</code>","text":"<p>Stop the Lord Microstrain IMU sensor.</p> <p>Sets the node to idle mode and updates the streaming flag to False.</p> <p>Raises:</p> Type Description <code>SensorNotStreamingException</code> <p>If the sensor is not currently streaming.</p> Source code in <code>opensourceleg/sensors/imu.py</code> <pre><code>@check_sensor_stream\ndef stop(self) -&gt; None:\n    \"\"\"\n    Stop the Lord Microstrain IMU sensor.\n\n    Sets the node to idle mode and updates the streaming flag to False.\n\n    Raises:\n        SensorNotStreamingException: If the sensor is not currently streaming.\n    \"\"\"\n    self._node.setToIdle()\n    self._is_streaming = False\n</code></pre>"},{"location":"api/sensors/imu/#opensourceleg.sensors.imu.LordMicrostrainIMU.update","title":"<code>update()</code>","text":"<p>Retrieve and update IMU data from the sensor. To modify update parameters, use the set_update_timeout, set_max_packets, and set_return_packets methods.</p> <p>Returns:</p> Type Description <code>Union[None, Any]</code> <p>Union[None, Any]: Returns the data packets if <code>return_packets</code> is True; otherwise, None.</p> Source code in <code>opensourceleg/sensors/imu.py</code> <pre><code>def update(self) -&gt; Union[None, Any]:\n    \"\"\"\n    Retrieve and update IMU data from the sensor. To modify update parameters, use the set_update_timeout,\n    set_max_packets, and set_return_packets methods.\n\n    Returns:\n        Union[None, Any]: Returns the data packets if `return_packets` is True; otherwise, None.\n    \"\"\"\n    data_packets = self._node.getDataPackets(timeout=self.update_timeout, maxPackets=self.max_packets)\n    data_points = data_packets[-1].data()\n    self._data = {data.channelName(): data.as_float() for data in data_points}\n\n    if self.return_packets:\n        return data_packets\n    else:\n        return None\n</code></pre>"},{"location":"api/sensors/loadcell/","title":"Loadcell","text":"<p>Module for interfacing with Loadcell amplifiers.</p> <p>This module provides implements reading force/moment data from a 6-axis loadcell using DAQs by the Neurobionics lab, and Dephy.</p> <p>Classes:</p> Name Description <code>LoadcellNotRespondingException</code> <p>Exception raised when the load cell does not respond.</p> <code>DEPHY_AMPLIFIER_MEMORY_CHANNELS</code> <p>Enum representing memory channel addresses for load cell readings.</p> <code>DephyLoadcellAmplifier</code> <p>Read and process force/moment data from a 6-axis load cell with a DAQ by Dephy.</p> <code>NBLoadcellDAQ</code> <p>Read and process force/moment data from a 6-axis load cell with DAQs by Neurobionics Lab.</p> Dependencies <ul> <li>numpy</li> <li>smbus2</li> <li>spidev</li> <li>opensourceleg.logging</li> <li>opensourceleg.sensors.base</li> <li>opensourceleg.sensors.adc</li> </ul>"},{"location":"api/sensors/loadcell/#opensourceleg.sensors.loadcell.DEPHY_AMPLIFIER_MEMORY_CHANNELS","title":"<code>DEPHY_AMPLIFIER_MEMORY_CHANNELS</code>","text":"<p>               Bases: <code>int</code>, <code>Enum</code></p> <p>Enumeration of memory channel addresses used by the load cell.</p> <p>Each channel corresponds to a specific high or low byte of the ADC data.</p> Source code in <code>opensourceleg/sensors/loadcell.py</code> <pre><code>class DEPHY_AMPLIFIER_MEMORY_CHANNELS(int, Enum):\n    \"\"\"\n    Enumeration of memory channel addresses used by the load cell.\n\n    Each channel corresponds to a specific high or low byte of the ADC data.\n    \"\"\"\n\n    CH1_H = 8\n    CH1_L = 9\n    CH2_H = 10\n    CH2_L = 11\n    CH3_H = 12\n    CH3_L = 13\n    CH4_H = 14\n    CH4_L = 15\n    CH5_H = 16\n    CH5_L = 17\n    CH6_H = 18\n    CH6_L = 19\n</code></pre>"},{"location":"api/sensors/loadcell/#opensourceleg.sensors.loadcell.DephyLoadcellAmplifier","title":"<code>DephyLoadcellAmplifier</code>","text":"<p>               Bases: <code>LoadcellBase</code></p> <p>Implementation of a load cell sensor using the Dephy Loadcell Amplifier.</p> <p>This class communicates with the Dephy strain amplifier. It can connect via either I2C using the SMBus interface, or using custom data callbacks. It processes the raw ADC data, and computes forces (Fx, Fy, Fz) and moments (Mx, My, Mz) based on a provided calibration matrix and hardware configuration.</p> Class Attributes <p>ADC_RANGE (int): The maximum ADC value (212 - 1). OFFSET (float): The ADC mid-scale offset (half of 212).</p> Source code in <code>opensourceleg/sensors/loadcell.py</code> <pre><code>class DephyLoadcellAmplifier(LoadcellBase):\n    \"\"\"\n    Implementation of a load cell sensor using the Dephy Loadcell Amplifier.\n\n    This class communicates with the Dephy strain amplifier.\n    It can connect via either I2C using the SMBus interface, or using custom data callbacks.\n    It processes the raw ADC data, and computes forces (Fx, Fy, Fz) and moments (Mx, My, Mz)\n    based on a provided calibration matrix and hardware configuration.\n\n    Class Attributes:\n        ADC_RANGE (int): The maximum ADC value (2**12 - 1).\n        OFFSET (float): The ADC mid-scale offset (half of 2**12).\n    \"\"\"\n\n    ADC_RANGE = 2**12 - 1\n    OFFSET = 2**12 / 2\n\n    def __init__(\n        self,\n        calibration_matrix: npt.NDArray[np.double],\n        tag: str = \"DephyLoadcellAmplifier\",\n        amp_gain: float = 125.0,\n        exc: float = 5.0,\n        bus: int = 1,\n        i2c_address: int = 0x66,\n        offline: bool = False,\n        enable_diagnostics: bool = True,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the Dephy loadcell amplifier.\n\n        Validates the provided parameters and initializes internal variables for data\n        acquisition, calibration, and streaming.\n\n        Args:\n            calibration_matrix (npt.NDArray[np.double]): A 6x6 calibration matrix.\n            tag (str, optional): A tag for identifying the load cell instance. Defaults to \"DephyLoadcellAmplifier\".\n            amp_gain (float, optional): Amplifier gain; must be greater than 0. Defaults to 125.0.\n            exc (float, optional): Excitation voltage; must be greater than 0. Defaults to 5.0.\n            bus (int, optional): I2C bus number to use. Defaults to 1.\n            i2c_address (int, optional): I2C address of the strain amplifier. Defaults to 0x66.\n\n        Raises:\n            TypeError: If calibration_matrix is not a 6x6 array.\n            ValueError: If amp_gain or exc are not greater than 0.\n        \"\"\"\n        super().__init__(tag=tag, offline=offline)\n\n        # Validate input parameters.\n        if calibration_matrix.shape != (6, 6):\n            LOGGER.info(f\"[{self.__repr__()}] calibration_matrix must be a 6x6 array of np.double.\")\n            raise TypeError(\"calibration_matrix must be a 6x6 array of np.double.\")\n        if amp_gain &lt;= 0:\n            LOGGER.info(f\"[{self.__repr__()}] amp_gain must be a floating point value greater than 0.\")\n            raise ValueError(\"amp_gain must be a floating point value greater than 0.\")\n        if exc &lt;= 0:\n            LOGGER.info(f\"[{self.__repr__()}] exc must be a floating point value greater than 0.\")\n            raise ValueError(\"exc must be a floating point value greater than 0.\")\n\n        self._amp_gain: float = amp_gain\n        self._exc: float = exc\n\n        self._bus = bus\n        self._i2c_address = i2c_address\n\n        self._calibration_matrix = calibration_matrix\n\n        self._data: npt.NDArray[np.double] = np.zeros(shape=(1, 6), dtype=np.double)\n        self._prev_data: npt.NDArray[np.double] = self._data\n        self._failed_reads = 0\n\n        self._calibration_offset: npt.NDArray[np.double] = np.zeros(shape=(1, 6), dtype=np.double)\n        self._zero_calibration_offset: npt.NDArray[np.double] = self._calibration_offset\n        self._is_calibrated: bool = False\n        self._is_streaming: bool = False\n        self._enable_diagnostics: bool = enable_diagnostics\n        self._data_potentially_invalid: bool = False\n        if self._enable_diagnostics:\n            self._diagnostics_counter = Counter()\n        self._num_broken_wire_pre_exception: int = 5\n\n    def start(self) -&gt; None:\n        \"\"\"\n        Start the load cell sensor.\n\n        If using I2C Mode, it opens the I2C connection using SMBus, waits briefly for hardware stabilization,\n        and sets the streaming flag to True.\n        \"\"\"\n        self._smbus = SMBus(self._bus)\n        time.sleep(1)\n        self._is_streaming = True\n\n    def reset(self) -&gt; None:\n        \"\"\"\n        Reset the load cell calibration.\n\n        Resets the calibration offset to the zero value and marks the sensor as uncalibrated.\n        \"\"\"\n        self._calibration_offset = self._zero_calibration_offset\n        self._is_calibrated = False\n\n    def update(\n        self,\n        calibration_offset: Optional[npt.NDArray[np.double]] = None,\n        data_callback: Optional[Callable[..., npt.NDArray[np.uint16]]] = None,\n    ) -&gt; None:\n        \"\"\"\n        Query the load cell for the latest data and update internal state.\n\n        Reads raw ADC data (either via a provided callback or by reading from I2C),\n        converts it to engineering units using the calibration matrix, amplifier gain,\n        and excitation voltage, and subtracts any calibration offset.\n\n        Args:\n            calibration_offset (Optional[npt.NDArray[np.double]], optional):\n                An offset to subtract from the processed data. If None, uses the current calibration offset.\n            data_callback (Optional[Callable[..., npt.NDArray[np.uint8]]], optional):\n                A callback function to provide raw data. If not provided, the sensor's internal i2c method is used.\n\n        Raises:\n            ValueError: If the update method fails due to misconfiguration.\n        \"\"\"\n        data = data_callback() if data_callback else self._read_compressed_strain()\n\n        if self._enable_diagnostics:\n            self.check_data(data)\n\n        if calibration_offset is None:\n            calibration_offset = self._calibration_offset\n\n        signed_data = ((data - self.OFFSET) / self.ADC_RANGE) * self._exc\n        coupled_data = signed_data * 1000 / (self._exc * self._amp_gain)\n\n        # Process the data using the calibration matrix and subtract the offset.\n        self._data = np.transpose(a=self._calibration_matrix.dot(b=np.transpose(a=coupled_data))) - calibration_offset\n\n    def check_data(self, data: npt.NDArray[np.uint16]) -&gt; None:\n        \"\"\"\n        Watches raw values from the load cell to try to catch broken wires.\n        Symptom is indicated by saturation at either max or min ADC values.\n        \"\"\"\n        ADC_saturated_high = np.any(data == self.ADC_RANGE)  # Use np.any for NumPy arrays\n        ADC_saturated_low = np.any(data == 0)  # Use np.any for NumPy arrays\n        concerning_data_found = bool(ADC_saturated_high or ADC_saturated_low)\n        self._diagnostics_counter.update(concerning_data_found)\n        if self._diagnostics_counter.current_count &gt;= self._num_broken_wire_pre_exception:\n            raise LoadcellBrokenWireDetectedException(\n                f\"[{self.__repr__()}] Consistent saturation in readings, check wiring. ADC values: {self._data}.\"\n            )\n\n    def calibrate(\n        self,\n        number_of_iterations: int = 2000,\n        reset: bool = False,\n        data_callback: Optional[Callable[[], npt.NDArray[np.uint16]]] = None,\n    ) -&gt; None:\n        \"\"\"\n        Perform a zeroing (calibration) routine for the load cell.\n\n        This method obtains an initial zero-load reading that is subtracted from subsequent\n        measurements. If the sensor has already been calibrated and 'reset' is False, a log message\n        is displayed.\n\n        Args:\n            number_of_iterations (int, optional): Number of iterations to average for calibration.\n                Defaults to 2000.\n            reset (bool, optional): If True, forces recalibration by resetting the current calibration.\n                Defaults to False.\n            data_callback (Optional[Callable[[], npt.NDArray[np.uint8]]], optional): Optional callback\n                to provide raw data. Defaults to None.\n        \"\"\"\n        if not self.is_calibrated:\n            LOGGER.info(\n                f\"[{self.__repr__()}] Initiating zeroing routine, please ensure that there is no ground contact force.\"\n            )\n            input(\"Press any key to start.\")\n\n            self.update(data_callback=data_callback)\n            self._calibration_offset = self._data\n\n            for _ in range(number_of_iterations):\n                self.update(\n                    calibration_offset=self._zero_calibration_offset,\n                    data_callback=data_callback,\n                )\n                iterative_calibration_offset = self._data\n                self._calibration_offset = (iterative_calibration_offset + self._calibration_offset) / 2.0\n\n            self._is_calibrated = True\n            LOGGER.info(f\"[{self.__repr__()}] Calibration routine complete.\")\n\n        elif reset:\n            self.reset()\n            self.calibrate()\n        else:\n            LOGGER.info(\n                f\"[{self.__repr__()}] Loadcell has already been zeroed. \"\n                \"To recalibrate, set reset=True in the calibrate method or call reset() first.\"\n            )\n\n    def stop(self) -&gt; None:\n        \"\"\"\n        Stop the load cell sensor.\n\n        Sets the streaming flag to False and closes the I2C connection if it is open.\n        \"\"\"\n        self._is_streaming = False\n        if hasattr(self, \"_smbus\"):\n            self._smbus.close()\n\n    def _read_compressed_strain(self) -&gt; npt.NDArray[np.uint16]:\n        \"\"\"\n        Read and unpack compressed strain data from the sensor.\n\n        This method reads a block of data from the sensor via I2C and then unpacks it\n        using the compressed strain format. If multiple read attempts fail, a\n        LoadcellNotRespondingException is raised.\n\n        Returns:\n            Any: The unpacked strain data.\n        \"\"\"\n        try:\n            data = self._smbus.read_i2c_block_data(self._i2c_address, DEPHY_AMPLIFIER_MEMORY_CHANNELS.CH1_H, 10)\n            self.failed_reads = 0\n        except OSError:\n            self.failed_reads += 1\n\n            if self.failed_reads &gt;= 5:\n                raise LoadcellNotRespondingException(\"Load cell unresponsive.\") from None\n\n        return self._unpack_compressed_strain(np.array(object=data, dtype=np.uint8))\n\n    @staticmethod\n    def _unpack_uncompressed_strain(data: npt.NDArray[np.uint8]) -&gt; npt.NDArray[np.uint16]:\n        \"\"\"\n        Unpack raw ADC data using the uncompressed format.\n\n        This method is used for older versions of the strain amplifier firmware (pre-2017).\n\n        Args:\n            data (npt.NDArray[np.uint8]): Raw data read from the sensor.\n\n        Returns:\n            npt.NDArray[np.uint16]: An array containing the unpacked values for 6 channels.\n        \"\"\"\n        ch1 = (data[0] &lt;&lt; 8) | data[1]\n        ch2 = (data[2] &lt;&lt; 8) | data[3]\n        ch3 = (data[4] &lt;&lt; 8) | data[5]\n        ch4 = (data[6] &lt;&lt; 8) | data[7]\n        ch5 = (data[8] &lt;&lt; 8) | data[9]\n        ch6 = (data[10] &lt;&lt; 8) | data[11]\n        return np.array(object=[ch1, ch2, ch3, ch4, ch5, ch6])\n\n    @staticmethod\n    def _unpack_compressed_strain(data: npt.NDArray[np.uint8]) -&gt; npt.NDArray[np.uint16]:\n        \"\"\"\n        Unpack raw ADC data using the compressed format.\n\n        This method is used for more recent versions of the strain amplifier firmware.\n\n        Args:\n            data (npt.NDArray[np.uint8]): Raw data read from the sensor.\n\n        Returns:\n            npt.NDArray[np.uint16]: An array containing the unpacked values for 6 channels.\n        \"\"\"\n        return np.array(\n            object=[\n                (data[0] &lt;&lt; 4) | ((data[1] &gt;&gt; 4) &amp; 0x0F),\n                ((data[1] &lt;&lt; 8) &amp; 0x0F00) | data[2],\n                (data[3] &lt;&lt; 4) | ((data[4] &gt;&gt; 4) &amp; 0x0F),\n                ((data[4] &lt;&lt; 8) &amp; 0x0F00) | data[5],\n                (data[6] &lt;&lt; 4) | ((data[7] &gt;&gt; 4) &amp; 0x0F),\n                ((data[7] &lt;&lt; 8) &amp; 0x0F00) | data[8],\n            ]\n        )\n\n    @property\n    def is_calibrated(self) -&gt; bool:\n        \"\"\"\n        Indicates whether the load cell has been calibrated (zeroed).\n\n        Returns:\n            bool: True if the calibration routine has been successfully completed; otherwise, False.\n        \"\"\"\n        return self._is_calibrated\n\n    @property\n    def is_streaming(self) -&gt; bool:\n        \"\"\"\n        Check if the load cell is currently streaming data.\n\n        Returns:\n            bool: True if streaming; otherwise, False.\n        \"\"\"\n        return self._is_streaming\n\n    @property\n    def fx(self) -&gt; float:\n        \"\"\"\n        Get the latest force in the x (medial/lateral) direction in Newtons.\n\n        For the standard OSL setup, this value is positive towards the user's right.\n\n        Returns:\n            float: Force (N) along the x-axis.\n        \"\"\"\n        return self.data[0]\n\n    @property\n    def fy(self) -&gt; float:\n        \"\"\"\n        Get the latest force in the y (anterior/posterior) direction in Newtons.\n\n        For the standard OSL setup, this value is positive in the posterior direction.\n\n        Returns:\n            float: Force (N) along the y-axis.\n        \"\"\"\n        return self.data[1]\n\n    @property\n    def fz(self) -&gt; float:\n        \"\"\"\n        Get the latest force in the z (vertical) direction in Newtons.\n\n        For the standard OSL setup, this value is positive downwards. In quiet standing,\n        a negative Fz value is expected.\n\n        Returns:\n            float: Force (N) along the z-axis.\n        \"\"\"\n        return self.data[2]\n\n    @property\n    def mx(self) -&gt; float:\n        \"\"\"\n        Get the latest moment about the x (medial/lateral) axis in Nm.\n\n        For the standard OSL setup, this moment is positive towards the user's right.\n\n        Returns:\n            float: Moment (Nm) about the x-axis.\n        \"\"\"\n        return self.data[3]\n\n    @property\n    def my(self) -&gt; float:\n        \"\"\"\n        Get the latest moment about the y (anterior/posterior) axis in Nm.\n\n        For the standard OSL setup, this moment is positive in the posterior direction.\n\n        Returns:\n            float: Moment (Nm) about the y-axis.\n        \"\"\"\n        return self.data[4]\n\n    @property\n    def mz(self) -&gt; float:\n        \"\"\"\n        Get the latest moment about the z (vertical) axis in Nm.\n\n        For the standard OSL setup, this moment is positive towards the ground.\n\n        Returns:\n            float: Moment (Nm) about the z-axis.\n        \"\"\"\n        return self.data[5]\n\n    @property\n    def data(self) -&gt; list[float]:\n        \"\"\"\n        Get the latest processed load cell data.\n\n        Returns:\n            list[float]: A 1D vector containing [Fx, Fy, Fz, Mx, My, Mz], where forces are in Newtons and moments in Nm.\n        \"\"\"\n        if self._data is not None:\n            return list(map(float, self._data[0].tolist()))\n        else:\n            return list(map(float, self._zero_calibration_offset.tolist()))\n</code></pre>"},{"location":"api/sensors/loadcell/#opensourceleg.sensors.loadcell.DephyLoadcellAmplifier.data","title":"<code>data</code>  <code>property</code>","text":"<p>Get the latest processed load cell data.</p> <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: A 1D vector containing [Fx, Fy, Fz, Mx, My, Mz], where forces are in Newtons and moments in Nm.</p>"},{"location":"api/sensors/loadcell/#opensourceleg.sensors.loadcell.DephyLoadcellAmplifier.fx","title":"<code>fx</code>  <code>property</code>","text":"<p>Get the latest force in the x (medial/lateral) direction in Newtons.</p> <p>For the standard OSL setup, this value is positive towards the user's right.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Force (N) along the x-axis.</p>"},{"location":"api/sensors/loadcell/#opensourceleg.sensors.loadcell.DephyLoadcellAmplifier.fy","title":"<code>fy</code>  <code>property</code>","text":"<p>Get the latest force in the y (anterior/posterior) direction in Newtons.</p> <p>For the standard OSL setup, this value is positive in the posterior direction.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Force (N) along the y-axis.</p>"},{"location":"api/sensors/loadcell/#opensourceleg.sensors.loadcell.DephyLoadcellAmplifier.fz","title":"<code>fz</code>  <code>property</code>","text":"<p>Get the latest force in the z (vertical) direction in Newtons.</p> <p>For the standard OSL setup, this value is positive downwards. In quiet standing, a negative Fz value is expected.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Force (N) along the z-axis.</p>"},{"location":"api/sensors/loadcell/#opensourceleg.sensors.loadcell.DephyLoadcellAmplifier.is_calibrated","title":"<code>is_calibrated</code>  <code>property</code>","text":"<p>Indicates whether the load cell has been calibrated (zeroed).</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the calibration routine has been successfully completed; otherwise, False.</p>"},{"location":"api/sensors/loadcell/#opensourceleg.sensors.loadcell.DephyLoadcellAmplifier.is_streaming","title":"<code>is_streaming</code>  <code>property</code>","text":"<p>Check if the load cell is currently streaming data.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if streaming; otherwise, False.</p>"},{"location":"api/sensors/loadcell/#opensourceleg.sensors.loadcell.DephyLoadcellAmplifier.mx","title":"<code>mx</code>  <code>property</code>","text":"<p>Get the latest moment about the x (medial/lateral) axis in Nm.</p> <p>For the standard OSL setup, this moment is positive towards the user's right.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Moment (Nm) about the x-axis.</p>"},{"location":"api/sensors/loadcell/#opensourceleg.sensors.loadcell.DephyLoadcellAmplifier.my","title":"<code>my</code>  <code>property</code>","text":"<p>Get the latest moment about the y (anterior/posterior) axis in Nm.</p> <p>For the standard OSL setup, this moment is positive in the posterior direction.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Moment (Nm) about the y-axis.</p>"},{"location":"api/sensors/loadcell/#opensourceleg.sensors.loadcell.DephyLoadcellAmplifier.mz","title":"<code>mz</code>  <code>property</code>","text":"<p>Get the latest moment about the z (vertical) axis in Nm.</p> <p>For the standard OSL setup, this moment is positive towards the ground.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Moment (Nm) about the z-axis.</p>"},{"location":"api/sensors/loadcell/#opensourceleg.sensors.loadcell.DephyLoadcellAmplifier.__init__","title":"<code>__init__(calibration_matrix, tag='DephyLoadcellAmplifier', amp_gain=125.0, exc=5.0, bus=1, i2c_address=102, offline=False, enable_diagnostics=True)</code>","text":"<p>Initialize the Dephy loadcell amplifier.</p> <p>Validates the provided parameters and initializes internal variables for data acquisition, calibration, and streaming.</p> <p>Parameters:</p> Name Type Description Default <code>calibration_matrix</code> <code>NDArray[double]</code> <p>A 6x6 calibration matrix.</p> required <code>tag</code> <code>str</code> <p>A tag for identifying the load cell instance. Defaults to \"DephyLoadcellAmplifier\".</p> <code>'DephyLoadcellAmplifier'</code> <code>amp_gain</code> <code>float</code> <p>Amplifier gain; must be greater than 0. Defaults to 125.0.</p> <code>125.0</code> <code>exc</code> <code>float</code> <p>Excitation voltage; must be greater than 0. Defaults to 5.0.</p> <code>5.0</code> <code>bus</code> <code>int</code> <p>I2C bus number to use. Defaults to 1.</p> <code>1</code> <code>i2c_address</code> <code>int</code> <p>I2C address of the strain amplifier. Defaults to 0x66.</p> <code>102</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>If calibration_matrix is not a 6x6 array.</p> <code>ValueError</code> <p>If amp_gain or exc are not greater than 0.</p> Source code in <code>opensourceleg/sensors/loadcell.py</code> <pre><code>def __init__(\n    self,\n    calibration_matrix: npt.NDArray[np.double],\n    tag: str = \"DephyLoadcellAmplifier\",\n    amp_gain: float = 125.0,\n    exc: float = 5.0,\n    bus: int = 1,\n    i2c_address: int = 0x66,\n    offline: bool = False,\n    enable_diagnostics: bool = True,\n) -&gt; None:\n    \"\"\"\n    Initialize the Dephy loadcell amplifier.\n\n    Validates the provided parameters and initializes internal variables for data\n    acquisition, calibration, and streaming.\n\n    Args:\n        calibration_matrix (npt.NDArray[np.double]): A 6x6 calibration matrix.\n        tag (str, optional): A tag for identifying the load cell instance. Defaults to \"DephyLoadcellAmplifier\".\n        amp_gain (float, optional): Amplifier gain; must be greater than 0. Defaults to 125.0.\n        exc (float, optional): Excitation voltage; must be greater than 0. Defaults to 5.0.\n        bus (int, optional): I2C bus number to use. Defaults to 1.\n        i2c_address (int, optional): I2C address of the strain amplifier. Defaults to 0x66.\n\n    Raises:\n        TypeError: If calibration_matrix is not a 6x6 array.\n        ValueError: If amp_gain or exc are not greater than 0.\n    \"\"\"\n    super().__init__(tag=tag, offline=offline)\n\n    # Validate input parameters.\n    if calibration_matrix.shape != (6, 6):\n        LOGGER.info(f\"[{self.__repr__()}] calibration_matrix must be a 6x6 array of np.double.\")\n        raise TypeError(\"calibration_matrix must be a 6x6 array of np.double.\")\n    if amp_gain &lt;= 0:\n        LOGGER.info(f\"[{self.__repr__()}] amp_gain must be a floating point value greater than 0.\")\n        raise ValueError(\"amp_gain must be a floating point value greater than 0.\")\n    if exc &lt;= 0:\n        LOGGER.info(f\"[{self.__repr__()}] exc must be a floating point value greater than 0.\")\n        raise ValueError(\"exc must be a floating point value greater than 0.\")\n\n    self._amp_gain: float = amp_gain\n    self._exc: float = exc\n\n    self._bus = bus\n    self._i2c_address = i2c_address\n\n    self._calibration_matrix = calibration_matrix\n\n    self._data: npt.NDArray[np.double] = np.zeros(shape=(1, 6), dtype=np.double)\n    self._prev_data: npt.NDArray[np.double] = self._data\n    self._failed_reads = 0\n\n    self._calibration_offset: npt.NDArray[np.double] = np.zeros(shape=(1, 6), dtype=np.double)\n    self._zero_calibration_offset: npt.NDArray[np.double] = self._calibration_offset\n    self._is_calibrated: bool = False\n    self._is_streaming: bool = False\n    self._enable_diagnostics: bool = enable_diagnostics\n    self._data_potentially_invalid: bool = False\n    if self._enable_diagnostics:\n        self._diagnostics_counter = Counter()\n    self._num_broken_wire_pre_exception: int = 5\n</code></pre>"},{"location":"api/sensors/loadcell/#opensourceleg.sensors.loadcell.DephyLoadcellAmplifier.calibrate","title":"<code>calibrate(number_of_iterations=2000, reset=False, data_callback=None)</code>","text":"<p>Perform a zeroing (calibration) routine for the load cell.</p> <p>This method obtains an initial zero-load reading that is subtracted from subsequent measurements. If the sensor has already been calibrated and 'reset' is False, a log message is displayed.</p> <p>Parameters:</p> Name Type Description Default <code>number_of_iterations</code> <code>int</code> <p>Number of iterations to average for calibration. Defaults to 2000.</p> <code>2000</code> <code>reset</code> <code>bool</code> <p>If True, forces recalibration by resetting the current calibration. Defaults to False.</p> <code>False</code> <code>data_callback</code> <code>Optional[Callable[[], NDArray[uint8]]]</code> <p>Optional callback to provide raw data. Defaults to None.</p> <code>None</code> Source code in <code>opensourceleg/sensors/loadcell.py</code> <pre><code>def calibrate(\n    self,\n    number_of_iterations: int = 2000,\n    reset: bool = False,\n    data_callback: Optional[Callable[[], npt.NDArray[np.uint16]]] = None,\n) -&gt; None:\n    \"\"\"\n    Perform a zeroing (calibration) routine for the load cell.\n\n    This method obtains an initial zero-load reading that is subtracted from subsequent\n    measurements. If the sensor has already been calibrated and 'reset' is False, a log message\n    is displayed.\n\n    Args:\n        number_of_iterations (int, optional): Number of iterations to average for calibration.\n            Defaults to 2000.\n        reset (bool, optional): If True, forces recalibration by resetting the current calibration.\n            Defaults to False.\n        data_callback (Optional[Callable[[], npt.NDArray[np.uint8]]], optional): Optional callback\n            to provide raw data. Defaults to None.\n    \"\"\"\n    if not self.is_calibrated:\n        LOGGER.info(\n            f\"[{self.__repr__()}] Initiating zeroing routine, please ensure that there is no ground contact force.\"\n        )\n        input(\"Press any key to start.\")\n\n        self.update(data_callback=data_callback)\n        self._calibration_offset = self._data\n\n        for _ in range(number_of_iterations):\n            self.update(\n                calibration_offset=self._zero_calibration_offset,\n                data_callback=data_callback,\n            )\n            iterative_calibration_offset = self._data\n            self._calibration_offset = (iterative_calibration_offset + self._calibration_offset) / 2.0\n\n        self._is_calibrated = True\n        LOGGER.info(f\"[{self.__repr__()}] Calibration routine complete.\")\n\n    elif reset:\n        self.reset()\n        self.calibrate()\n    else:\n        LOGGER.info(\n            f\"[{self.__repr__()}] Loadcell has already been zeroed. \"\n            \"To recalibrate, set reset=True in the calibrate method or call reset() first.\"\n        )\n</code></pre>"},{"location":"api/sensors/loadcell/#opensourceleg.sensors.loadcell.DephyLoadcellAmplifier.check_data","title":"<code>check_data(data)</code>","text":"<p>Watches raw values from the load cell to try to catch broken wires. Symptom is indicated by saturation at either max or min ADC values.</p> Source code in <code>opensourceleg/sensors/loadcell.py</code> <pre><code>def check_data(self, data: npt.NDArray[np.uint16]) -&gt; None:\n    \"\"\"\n    Watches raw values from the load cell to try to catch broken wires.\n    Symptom is indicated by saturation at either max or min ADC values.\n    \"\"\"\n    ADC_saturated_high = np.any(data == self.ADC_RANGE)  # Use np.any for NumPy arrays\n    ADC_saturated_low = np.any(data == 0)  # Use np.any for NumPy arrays\n    concerning_data_found = bool(ADC_saturated_high or ADC_saturated_low)\n    self._diagnostics_counter.update(concerning_data_found)\n    if self._diagnostics_counter.current_count &gt;= self._num_broken_wire_pre_exception:\n        raise LoadcellBrokenWireDetectedException(\n            f\"[{self.__repr__()}] Consistent saturation in readings, check wiring. ADC values: {self._data}.\"\n        )\n</code></pre>"},{"location":"api/sensors/loadcell/#opensourceleg.sensors.loadcell.DephyLoadcellAmplifier.reset","title":"<code>reset()</code>","text":"<p>Reset the load cell calibration.</p> <p>Resets the calibration offset to the zero value and marks the sensor as uncalibrated.</p> Source code in <code>opensourceleg/sensors/loadcell.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"\n    Reset the load cell calibration.\n\n    Resets the calibration offset to the zero value and marks the sensor as uncalibrated.\n    \"\"\"\n    self._calibration_offset = self._zero_calibration_offset\n    self._is_calibrated = False\n</code></pre>"},{"location":"api/sensors/loadcell/#opensourceleg.sensors.loadcell.DephyLoadcellAmplifier.start","title":"<code>start()</code>","text":"<p>Start the load cell sensor.</p> <p>If using I2C Mode, it opens the I2C connection using SMBus, waits briefly for hardware stabilization, and sets the streaming flag to True.</p> Source code in <code>opensourceleg/sensors/loadcell.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"\n    Start the load cell sensor.\n\n    If using I2C Mode, it opens the I2C connection using SMBus, waits briefly for hardware stabilization,\n    and sets the streaming flag to True.\n    \"\"\"\n    self._smbus = SMBus(self._bus)\n    time.sleep(1)\n    self._is_streaming = True\n</code></pre>"},{"location":"api/sensors/loadcell/#opensourceleg.sensors.loadcell.DephyLoadcellAmplifier.stop","title":"<code>stop()</code>","text":"<p>Stop the load cell sensor.</p> <p>Sets the streaming flag to False and closes the I2C connection if it is open.</p> Source code in <code>opensourceleg/sensors/loadcell.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"\n    Stop the load cell sensor.\n\n    Sets the streaming flag to False and closes the I2C connection if it is open.\n    \"\"\"\n    self._is_streaming = False\n    if hasattr(self, \"_smbus\"):\n        self._smbus.close()\n</code></pre>"},{"location":"api/sensors/loadcell/#opensourceleg.sensors.loadcell.DephyLoadcellAmplifier.update","title":"<code>update(calibration_offset=None, data_callback=None)</code>","text":"<p>Query the load cell for the latest data and update internal state.</p> <p>Reads raw ADC data (either via a provided callback or by reading from I2C), converts it to engineering units using the calibration matrix, amplifier gain, and excitation voltage, and subtracts any calibration offset.</p> <p>Parameters:</p> Name Type Description Default <code>calibration_offset</code> <code>Optional[NDArray[double]]</code> <p>An offset to subtract from the processed data. If None, uses the current calibration offset.</p> <code>None</code> <code>data_callback</code> <code>Optional[Callable[..., NDArray[uint8]]]</code> <p>A callback function to provide raw data. If not provided, the sensor's internal i2c method is used.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the update method fails due to misconfiguration.</p> Source code in <code>opensourceleg/sensors/loadcell.py</code> <pre><code>def update(\n    self,\n    calibration_offset: Optional[npt.NDArray[np.double]] = None,\n    data_callback: Optional[Callable[..., npt.NDArray[np.uint16]]] = None,\n) -&gt; None:\n    \"\"\"\n    Query the load cell for the latest data and update internal state.\n\n    Reads raw ADC data (either via a provided callback or by reading from I2C),\n    converts it to engineering units using the calibration matrix, amplifier gain,\n    and excitation voltage, and subtracts any calibration offset.\n\n    Args:\n        calibration_offset (Optional[npt.NDArray[np.double]], optional):\n            An offset to subtract from the processed data. If None, uses the current calibration offset.\n        data_callback (Optional[Callable[..., npt.NDArray[np.uint8]]], optional):\n            A callback function to provide raw data. If not provided, the sensor's internal i2c method is used.\n\n    Raises:\n        ValueError: If the update method fails due to misconfiguration.\n    \"\"\"\n    data = data_callback() if data_callback else self._read_compressed_strain()\n\n    if self._enable_diagnostics:\n        self.check_data(data)\n\n    if calibration_offset is None:\n        calibration_offset = self._calibration_offset\n\n    signed_data = ((data - self.OFFSET) / self.ADC_RANGE) * self._exc\n    coupled_data = signed_data * 1000 / (self._exc * self._amp_gain)\n\n    # Process the data using the calibration matrix and subtract the offset.\n    self._data = np.transpose(a=self._calibration_matrix.dot(b=np.transpose(a=coupled_data))) - calibration_offset\n</code></pre>"},{"location":"api/sensors/loadcell/#opensourceleg.sensors.loadcell.LoadcellBrokenWireDetectedException","title":"<code>LoadcellBrokenWireDetectedException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when a broken wire is detected in the load cell. Indicated by saturated ADC values (0 or 4095).</p> <p>Attributes:</p> Name Type Description <code>message</code> <code>str</code> <p>Description of the error.</p> Source code in <code>opensourceleg/sensors/loadcell.py</code> <pre><code>class LoadcellBrokenWireDetectedException(Exception):\n    \"\"\"\n    Exception raised when a broken wire is detected in the load cell.\n    Indicated by saturated ADC values (0 or 4095).\n\n    Attributes:\n        message (str): Description of the error.\n    \"\"\"\n\n    def __init__(self, message: str = \"Load cell broken wire detected.\") -&gt; None:\n        \"\"\"\n        Initialize the LoadcellBrokenWireDetectedException.\n\n        Args:\n            message (str, optional): Error message. Defaults to \"Load cell broken wire detected.\".\n        \"\"\"\n        super().__init__(message)\n</code></pre>"},{"location":"api/sensors/loadcell/#opensourceleg.sensors.loadcell.LoadcellBrokenWireDetectedException.__init__","title":"<code>__init__(message='Load cell broken wire detected.')</code>","text":"<p>Initialize the LoadcellBrokenWireDetectedException.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Error message. Defaults to \"Load cell broken wire detected.\".</p> <code>'Load cell broken wire detected.'</code> Source code in <code>opensourceleg/sensors/loadcell.py</code> <pre><code>def __init__(self, message: str = \"Load cell broken wire detected.\") -&gt; None:\n    \"\"\"\n    Initialize the LoadcellBrokenWireDetectedException.\n\n    Args:\n        message (str, optional): Error message. Defaults to \"Load cell broken wire detected.\".\n    \"\"\"\n    super().__init__(message)\n</code></pre>"},{"location":"api/sensors/loadcell/#opensourceleg.sensors.loadcell.LoadcellNotRespondingException","title":"<code>LoadcellNotRespondingException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when the load cell fails to respond.</p> <p>Attributes:</p> Name Type Description <code>message</code> <code>str</code> <p>Description of the error.</p> Source code in <code>opensourceleg/sensors/loadcell.py</code> <pre><code>class LoadcellNotRespondingException(Exception):\n    \"\"\"\n    Exception raised when the load cell fails to respond.\n\n    Attributes:\n        message (str): Description of the error.\n    \"\"\"\n\n    def __init__(self, message: str = \"Load cell unresponsive.\") -&gt; None:\n        \"\"\"\n        Initialize the LoadcellNotRespondingException.\n\n        Args:\n            message (str, optional): Error message. Defaults to \"Load cell unresponsive.\".\n        \"\"\"\n        super().__init__(message)\n</code></pre>"},{"location":"api/sensors/loadcell/#opensourceleg.sensors.loadcell.LoadcellNotRespondingException.__init__","title":"<code>__init__(message='Load cell unresponsive.')</code>","text":"<p>Initialize the LoadcellNotRespondingException.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Error message. Defaults to \"Load cell unresponsive.\".</p> <code>'Load cell unresponsive.'</code> Source code in <code>opensourceleg/sensors/loadcell.py</code> <pre><code>def __init__(self, message: str = \"Load cell unresponsive.\") -&gt; None:\n    \"\"\"\n    Initialize the LoadcellNotRespondingException.\n\n    Args:\n        message (str, optional): Error message. Defaults to \"Load cell unresponsive.\".\n    \"\"\"\n    super().__init__(message)\n</code></pre>"},{"location":"api/sensors/loadcell/#opensourceleg.sensors.loadcell.NBLoadcellDAQ","title":"<code>NBLoadcellDAQ</code>","text":"<p>               Bases: <code>LoadcellBase</code></p> <p>Implementation of a load cell DAQ system using the ADS131M0x ADC.</p> <p>This class provides methods for acquiring, calibrating, and processing load cell data. It uses an ADC to read raw data, applies a calibration matrix, and computes forces and moments.</p> <p>Attributes:</p> Name Type Description <code>calibration_matrix</code> <code>ndarray</code> <p>A matrix used to convert raw ADC data into forces and moments.</p> <code>excitation_voltage</code> <code>float</code> <p>The excitation voltage applied to the load cell.</p> <code>amp_gain</code> <code>ndarray</code> <p>Amplifier gain values for each channel.</p> <code>adc</code> <code>ADS131M0x</code> <p>The ADC instance used for data acquisition.</p> <code>is_calibrated</code> <code>bool</code> <p>Indicates whether the load cell has been calibrated.</p> <code>is_streaming</code> <code>bool</code> <p>Indicates whether the ADC is currently streaming data.</p> Source code in <code>opensourceleg/sensors/loadcell.py</code> <pre><code>class NBLoadcellDAQ(LoadcellBase):\n    \"\"\"\n    Implementation of a load cell DAQ system using the ADS131M0x ADC.\n\n    This class provides methods for acquiring, calibrating, and processing load cell data.\n    It uses an ADC to read raw data, applies a calibration matrix, and computes forces and moments.\n\n    Attributes:\n        calibration_matrix (np.ndarray): A matrix used to convert raw ADC data into forces and moments.\n        excitation_voltage (float): The excitation voltage applied to the load cell.\n        amp_gain (np.ndarray): Amplifier gain values for each channel.\n        adc (ADS131M0x): The ADC instance used for data acquisition.\n        is_calibrated (bool): Indicates whether the load cell has been calibrated.\n        is_streaming (bool): Indicates whether the ADC is currently streaming data.\n    \"\"\"\n\n    def __init__(\n        self,\n        calibration_matrix: npt.NDArray[np.double],\n        tag: str = \"NBLoadcellDAQ\",\n        excitation_voltage: float = 5.0,\n        amp_gain: Optional[list[int]] = None,\n        offline: bool = False,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the NBLoadcellDAQ instance.\n\n        Args:\n            calibration_matrix (np.ndarray): A matrix used to convert raw ADC data into forces and moments.\n            tag (str): Identifier for the load cell instance. Defaults to 'NBLoadcellDAQ'.\n            excitation_voltage (float): The excitation voltage applied to the load cell. Defaults to 5.0 V.\n            amp_gain (list[int): Amplifier gain values for each channel. Defaults to [34, 34, 34, 151, 151, 151].\n            offline (bool): If True, the load cell operates in offline mode. Defaults to False.\n            **kwargs: Additional arguments passed to the ADS131M0x ADC instance.\n        \"\"\"\n        if amp_gain is None:\n            amp_gain = [34, 34, 34, 151, 151, 151]\n        super().__init__(tag=tag, offline=offline)\n\n        self._adc = ADS131M0x(**kwargs)\n        self.calibration_matrix = calibration_matrix\n        self.excitation_voltage = excitation_voltage\n        self._offset = np.zeros(self.adc.num_channels)\n        self.amp_gain = np.array(amp_gain)\n        self._is_calibrated = False\n\n    @property\n    def adc(self) -&gt; ADS131M0x:\n        \"\"\"\n        Get the ADC instance used for data acquisition.\n\n        Returns:\n            ADS131M0x: The ADC instance.\n        \"\"\"\n        return self._adc\n\n    def __repr__(self) -&gt; str:\n        return \"Loadcell\"\n\n    @property\n    def is_streaming(self) -&gt; bool:\n        \"\"\"\n        Check if the ADC is currently streaming data.\n\n        Returns:\n            bool: True if the ADC is streaming, False otherwise.\n        \"\"\"\n        return self.adc._streaming\n\n    def start(self) -&gt; None:\n        \"\"\"\n        Start the load cell DAQ system.\n\n        This method initializes the ADC and begins data acquisition.\n        \"\"\"\n        LOGGER.info(f\"[{self.__repr__()}] Starting data acquisition...\")\n        self.adc.start()\n\n    def stop(self) -&gt; None:\n        \"\"\"\n        Stop the load cell DAQ system.\n\n        This method stops the ADC and ends data acquisition.\n        \"\"\"\n        LOGGER.info(f\"[{self.__repr__()}] Stopping data acquisition...\")\n        self.adc.stop()\n\n    def update(self) -&gt; None:\n        \"\"\"\n        Update the load cell data.\n\n        Reads the latest data from the ADC, applies amplifier gains and calibration offsets,\n        and computes forces and moments using the calibration matrix.\n        \"\"\"\n        self.adc.update()\n\n        # Apply calibration offsets and amplifier gains\n        coupled = self.adc.data - self._offset\n        coupled[1::2] *= -1  # Invert odd-indexed channels for correct orientation\n\n        gains = self.amp_gain * self.adc.gains\n        normalized = coupled / (self.excitation_voltage * gains)\n\n        # Compute forces and moments using the calibration matrix\n        self._data = self.calibration_matrix @ normalized\n\n    def reset(self) -&gt; None:\n        \"\"\"\n        Reset the load cell DAQ system.\n\n        Resets the ADC and clears any calibration offsets.\n        \"\"\"\n        LOGGER.info(f\"[{self.__repr__()}] Resetting calibration offsets...\")\n        self.adc.reset()\n        self._offset = np.zeros(self.adc.num_channels)\n        self._is_calibrated = False\n\n    def calibrate(self, n_samples: int = 1024) -&gt; None:\n        \"\"\"\n        Perform a calibration routine to zero the load cell.\n\n        This method determines the zero-load offset by averaging multiple samples\n        and stores it for subsequent data processing.\n\n        Args:\n            n_samples (int, optional): Number of samples to average for calibration. Defaults to 1024.\n        \"\"\"\n        LOGGER.info(f\"[{self.__repr__()}] Calibrating ADS131M0x...\")\n        self.adc.calibrate()\n        LOGGER.info(f\"[{self.__repr__()}] Starting calibration with {n_samples} samples...\")\n        offsets = np.empty((n_samples, self.adc.num_channels))\n\n        for i in range(n_samples):\n            self.adc.update()\n            offsets[i] = self.adc.data\n\n        self._offset = offsets.mean(axis=0)\n        self._is_calibrated = True\n        LOGGER.info(f\"[{self.__repr__()}] Calibration complete.\")\n\n    @property\n    def is_calibrated(self) -&gt; bool:\n        \"\"\"\n        Check if the load cell has been calibrated.\n\n        Returns:\n            bool: True if the load cell has been calibrated, False otherwise.\n        \"\"\"\n        return self._is_calibrated\n\n    @property\n    def data(self) -&gt; Any:\n        \"\"\"\n        Get the latest processed load cell data.\n\n        Returns:\n            np.ndarray: A 1D vector containing [Fx, Fy, Fz, Mx, My, Mz], where:\n                - Fx, Fy, Fz are forces in Newtons.\n                - Mx, My, Mz are moments in Newton-meters.\n        \"\"\"\n        return self._data\n\n    @property\n    def fx(self) -&gt; float:\n        \"\"\"\n        Get the latest force in the x (medial/lateral) direction in Newtons.\n\n        Returns:\n            float: Force (N) along the x-axis.\n        \"\"\"\n        return float(self.data[0])\n\n    @property\n    def fy(self) -&gt; float:\n        \"\"\"\n        Get the latest force in the y (anterior/posterior) direction in Newtons.\n\n        Returns:\n            float: Force (N) along the y-axis.\n        \"\"\"\n        return float(self.data[1])\n\n    @property\n    def fz(self) -&gt; float:\n        \"\"\"\n        Get the latest force in the z (vertical) direction in Newtons.\n\n        Returns:\n            float: Force (N) along the z-axis.\n        \"\"\"\n        return float(self.data[2])\n\n    @property\n    def mx(self) -&gt; float:\n        \"\"\"\n        Get the latest moment about the x (medial/lateral) axis in Nm.\n\n        Returns:\n            float: Moment (Nm) about the x-axis.\n        \"\"\"\n        return float(self.data[3])\n\n    @property\n    def my(self) -&gt; float:\n        \"\"\"\n        Get the latest moment about the y (anterior/posterior) axis in Nm.\n\n        Returns:\n            float: Moment (Nm) about the y-axis.\n        \"\"\"\n        return float(self.data[4])\n\n    @property\n    def mz(self) -&gt; float:\n        \"\"\"\n        Get the latest moment about the z (vertical) axis in Nm.\n\n        Returns:\n            float: Moment (Nm) about the z-axis.\n        \"\"\"\n        return float(self.data[5])\n</code></pre>"},{"location":"api/sensors/loadcell/#opensourceleg.sensors.loadcell.NBLoadcellDAQ.adc","title":"<code>adc</code>  <code>property</code>","text":"<p>Get the ADC instance used for data acquisition.</p> <p>Returns:</p> Name Type Description <code>ADS131M0x</code> <code>ADS131M0x</code> <p>The ADC instance.</p>"},{"location":"api/sensors/loadcell/#opensourceleg.sensors.loadcell.NBLoadcellDAQ.data","title":"<code>data</code>  <code>property</code>","text":"<p>Get the latest processed load cell data.</p> <p>Returns:</p> Type Description <code>Any</code> <p>np.ndarray: A 1D vector containing [Fx, Fy, Fz, Mx, My, Mz], where: - Fx, Fy, Fz are forces in Newtons. - Mx, My, Mz are moments in Newton-meters.</p>"},{"location":"api/sensors/loadcell/#opensourceleg.sensors.loadcell.NBLoadcellDAQ.fx","title":"<code>fx</code>  <code>property</code>","text":"<p>Get the latest force in the x (medial/lateral) direction in Newtons.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Force (N) along the x-axis.</p>"},{"location":"api/sensors/loadcell/#opensourceleg.sensors.loadcell.NBLoadcellDAQ.fy","title":"<code>fy</code>  <code>property</code>","text":"<p>Get the latest force in the y (anterior/posterior) direction in Newtons.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Force (N) along the y-axis.</p>"},{"location":"api/sensors/loadcell/#opensourceleg.sensors.loadcell.NBLoadcellDAQ.fz","title":"<code>fz</code>  <code>property</code>","text":"<p>Get the latest force in the z (vertical) direction in Newtons.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Force (N) along the z-axis.</p>"},{"location":"api/sensors/loadcell/#opensourceleg.sensors.loadcell.NBLoadcellDAQ.is_calibrated","title":"<code>is_calibrated</code>  <code>property</code>","text":"<p>Check if the load cell has been calibrated.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the load cell has been calibrated, False otherwise.</p>"},{"location":"api/sensors/loadcell/#opensourceleg.sensors.loadcell.NBLoadcellDAQ.is_streaming","title":"<code>is_streaming</code>  <code>property</code>","text":"<p>Check if the ADC is currently streaming data.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the ADC is streaming, False otherwise.</p>"},{"location":"api/sensors/loadcell/#opensourceleg.sensors.loadcell.NBLoadcellDAQ.mx","title":"<code>mx</code>  <code>property</code>","text":"<p>Get the latest moment about the x (medial/lateral) axis in Nm.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Moment (Nm) about the x-axis.</p>"},{"location":"api/sensors/loadcell/#opensourceleg.sensors.loadcell.NBLoadcellDAQ.my","title":"<code>my</code>  <code>property</code>","text":"<p>Get the latest moment about the y (anterior/posterior) axis in Nm.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Moment (Nm) about the y-axis.</p>"},{"location":"api/sensors/loadcell/#opensourceleg.sensors.loadcell.NBLoadcellDAQ.mz","title":"<code>mz</code>  <code>property</code>","text":"<p>Get the latest moment about the z (vertical) axis in Nm.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Moment (Nm) about the z-axis.</p>"},{"location":"api/sensors/loadcell/#opensourceleg.sensors.loadcell.NBLoadcellDAQ.__init__","title":"<code>__init__(calibration_matrix, tag='NBLoadcellDAQ', excitation_voltage=5.0, amp_gain=None, offline=False, **kwargs)</code>","text":"<p>Initialize the NBLoadcellDAQ instance.</p> <p>Parameters:</p> Name Type Description Default <code>calibration_matrix</code> <code>ndarray</code> <p>A matrix used to convert raw ADC data into forces and moments.</p> required <code>tag</code> <code>str</code> <p>Identifier for the load cell instance. Defaults to 'NBLoadcellDAQ'.</p> <code>'NBLoadcellDAQ'</code> <code>excitation_voltage</code> <code>float</code> <p>The excitation voltage applied to the load cell. Defaults to 5.0 V.</p> <code>5.0</code> <code>amp_gain</code> <code>list[int</code> <p>Amplifier gain values for each channel. Defaults to [34, 34, 34, 151, 151, 151].</p> <code>None</code> <code>offline</code> <code>bool</code> <p>If True, the load cell operates in offline mode. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the ADS131M0x ADC instance.</p> <code>{}</code> Source code in <code>opensourceleg/sensors/loadcell.py</code> <pre><code>def __init__(\n    self,\n    calibration_matrix: npt.NDArray[np.double],\n    tag: str = \"NBLoadcellDAQ\",\n    excitation_voltage: float = 5.0,\n    amp_gain: Optional[list[int]] = None,\n    offline: bool = False,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Initialize the NBLoadcellDAQ instance.\n\n    Args:\n        calibration_matrix (np.ndarray): A matrix used to convert raw ADC data into forces and moments.\n        tag (str): Identifier for the load cell instance. Defaults to 'NBLoadcellDAQ'.\n        excitation_voltage (float): The excitation voltage applied to the load cell. Defaults to 5.0 V.\n        amp_gain (list[int): Amplifier gain values for each channel. Defaults to [34, 34, 34, 151, 151, 151].\n        offline (bool): If True, the load cell operates in offline mode. Defaults to False.\n        **kwargs: Additional arguments passed to the ADS131M0x ADC instance.\n    \"\"\"\n    if amp_gain is None:\n        amp_gain = [34, 34, 34, 151, 151, 151]\n    super().__init__(tag=tag, offline=offline)\n\n    self._adc = ADS131M0x(**kwargs)\n    self.calibration_matrix = calibration_matrix\n    self.excitation_voltage = excitation_voltage\n    self._offset = np.zeros(self.adc.num_channels)\n    self.amp_gain = np.array(amp_gain)\n    self._is_calibrated = False\n</code></pre>"},{"location":"api/sensors/loadcell/#opensourceleg.sensors.loadcell.NBLoadcellDAQ.calibrate","title":"<code>calibrate(n_samples=1024)</code>","text":"<p>Perform a calibration routine to zero the load cell.</p> <p>This method determines the zero-load offset by averaging multiple samples and stores it for subsequent data processing.</p> <p>Parameters:</p> Name Type Description Default <code>n_samples</code> <code>int</code> <p>Number of samples to average for calibration. Defaults to 1024.</p> <code>1024</code> Source code in <code>opensourceleg/sensors/loadcell.py</code> <pre><code>def calibrate(self, n_samples: int = 1024) -&gt; None:\n    \"\"\"\n    Perform a calibration routine to zero the load cell.\n\n    This method determines the zero-load offset by averaging multiple samples\n    and stores it for subsequent data processing.\n\n    Args:\n        n_samples (int, optional): Number of samples to average for calibration. Defaults to 1024.\n    \"\"\"\n    LOGGER.info(f\"[{self.__repr__()}] Calibrating ADS131M0x...\")\n    self.adc.calibrate()\n    LOGGER.info(f\"[{self.__repr__()}] Starting calibration with {n_samples} samples...\")\n    offsets = np.empty((n_samples, self.adc.num_channels))\n\n    for i in range(n_samples):\n        self.adc.update()\n        offsets[i] = self.adc.data\n\n    self._offset = offsets.mean(axis=0)\n    self._is_calibrated = True\n    LOGGER.info(f\"[{self.__repr__()}] Calibration complete.\")\n</code></pre>"},{"location":"api/sensors/loadcell/#opensourceleg.sensors.loadcell.NBLoadcellDAQ.reset","title":"<code>reset()</code>","text":"<p>Reset the load cell DAQ system.</p> <p>Resets the ADC and clears any calibration offsets.</p> Source code in <code>opensourceleg/sensors/loadcell.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"\n    Reset the load cell DAQ system.\n\n    Resets the ADC and clears any calibration offsets.\n    \"\"\"\n    LOGGER.info(f\"[{self.__repr__()}] Resetting calibration offsets...\")\n    self.adc.reset()\n    self._offset = np.zeros(self.adc.num_channels)\n    self._is_calibrated = False\n</code></pre>"},{"location":"api/sensors/loadcell/#opensourceleg.sensors.loadcell.NBLoadcellDAQ.start","title":"<code>start()</code>","text":"<p>Start the load cell DAQ system.</p> <p>This method initializes the ADC and begins data acquisition.</p> Source code in <code>opensourceleg/sensors/loadcell.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"\n    Start the load cell DAQ system.\n\n    This method initializes the ADC and begins data acquisition.\n    \"\"\"\n    LOGGER.info(f\"[{self.__repr__()}] Starting data acquisition...\")\n    self.adc.start()\n</code></pre>"},{"location":"api/sensors/loadcell/#opensourceleg.sensors.loadcell.NBLoadcellDAQ.stop","title":"<code>stop()</code>","text":"<p>Stop the load cell DAQ system.</p> <p>This method stops the ADC and ends data acquisition.</p> Source code in <code>opensourceleg/sensors/loadcell.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"\n    Stop the load cell DAQ system.\n\n    This method stops the ADC and ends data acquisition.\n    \"\"\"\n    LOGGER.info(f\"[{self.__repr__()}] Stopping data acquisition...\")\n    self.adc.stop()\n</code></pre>"},{"location":"api/sensors/loadcell/#opensourceleg.sensors.loadcell.NBLoadcellDAQ.update","title":"<code>update()</code>","text":"<p>Update the load cell data.</p> <p>Reads the latest data from the ADC, applies amplifier gains and calibration offsets, and computes forces and moments using the calibration matrix.</p> Source code in <code>opensourceleg/sensors/loadcell.py</code> <pre><code>def update(self) -&gt; None:\n    \"\"\"\n    Update the load cell data.\n\n    Reads the latest data from the ADC, applies amplifier gains and calibration offsets,\n    and computes forces and moments using the calibration matrix.\n    \"\"\"\n    self.adc.update()\n\n    # Apply calibration offsets and amplifier gains\n    coupled = self.adc.data - self._offset\n    coupled[1::2] *= -1  # Invert odd-indexed channels for correct orientation\n\n    gains = self.amp_gain * self.adc.gains\n    normalized = coupled / (self.excitation_voltage * gains)\n\n    # Compute forces and moments using the calibration matrix\n    self._data = self.calibration_matrix @ normalized\n</code></pre>"},{"location":"api/sensors/sensors_base/","title":"Base","text":""},{"location":"api/sensors/sensors_base/#opensourceleg.sensors.base.ADCBase","title":"<code>ADCBase</code>","text":"<p>               Bases: <code>SensorBase</code>, <code>ABC</code></p> <p>Abstract base class for ADC (Analog-to-Digital Converter) sensors.</p> <p>ADC sensors are used to convert analog signals into digital data.</p> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>class ADCBase(SensorBase, ABC):\n    \"\"\"\n    Abstract base class for ADC (Analog-to-Digital Converter) sensors.\n\n    ADC sensors are used to convert analog signals into digital data.\n    \"\"\"\n\n    # ADC-specific offline configuration\n    _OFFLINE_METHODS: ClassVar[list[str]] = [*SensorBase._OFFLINE_METHODS, \"reset\", \"calibrate\"]\n\n    def __init__(self, tag: str, offline: bool = False, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Initialize the ADC sensor.\n        \"\"\"\n        super().__init__(tag=tag, offline=offline, **kwargs)\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Return a string representation of the ADC sensor.\n\n        Returns:\n            str: \"ADCBase\"\n        \"\"\"\n        return \"ADCBase\"\n\n    def reset(self) -&gt; None:\n        \"\"\"\n        Reset the ADC sensor.\n\n        Implementations should clear any stored state or calibration.\n        \"\"\"\n        pass\n\n    def calibrate(self) -&gt; None:\n        \"\"\"\n        Calibrate the ADC sensor.\n\n        Implementations should perform necessary calibration procedures.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/sensors/sensors_base/#opensourceleg.sensors.base.ADCBase.__init__","title":"<code>__init__(tag, offline=False, **kwargs)</code>","text":"<p>Initialize the ADC sensor.</p> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>def __init__(self, tag: str, offline: bool = False, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Initialize the ADC sensor.\n    \"\"\"\n    super().__init__(tag=tag, offline=offline, **kwargs)\n</code></pre>"},{"location":"api/sensors/sensors_base/#opensourceleg.sensors.base.ADCBase.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the ADC sensor.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>\"ADCBase\"</p> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Return a string representation of the ADC sensor.\n\n    Returns:\n        str: \"ADCBase\"\n    \"\"\"\n    return \"ADCBase\"\n</code></pre>"},{"location":"api/sensors/sensors_base/#opensourceleg.sensors.base.ADCBase.calibrate","title":"<code>calibrate()</code>","text":"<p>Calibrate the ADC sensor.</p> <p>Implementations should perform necessary calibration procedures.</p> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>def calibrate(self) -&gt; None:\n    \"\"\"\n    Calibrate the ADC sensor.\n\n    Implementations should perform necessary calibration procedures.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/sensors/sensors_base/#opensourceleg.sensors.base.ADCBase.reset","title":"<code>reset()</code>","text":"<p>Reset the ADC sensor.</p> <p>Implementations should clear any stored state or calibration.</p> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"\n    Reset the ADC sensor.\n\n    Implementations should clear any stored state or calibration.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/sensors/sensors_base/#opensourceleg.sensors.base.EncoderBase","title":"<code>EncoderBase</code>","text":"<p>               Bases: <code>SensorBase</code>, <code>ABC</code></p> <p>Abstract base class for encoder sensors.</p> <p>Encoders are used to measure position and velocity.</p> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>class EncoderBase(SensorBase, ABC):\n    \"\"\"\n    Abstract base class for encoder sensors.\n\n    Encoders are used to measure position and velocity.\n    \"\"\"\n\n    # Encoder-specific offline configuration\n    _OFFLINE_PROPERTIES: ClassVar[list[str]] = [*SensorBase._OFFLINE_PROPERTIES, \"position\", \"velocity\"]\n    _OFFLINE_PROPERTY_DEFAULTS: ClassVar[dict[str, Any]] = {\n        **SensorBase._OFFLINE_PROPERTY_DEFAULTS,\n        \"position\": 0.0,\n        \"velocity\": 0.0,\n    }\n\n    def __init__(\n        self,\n        tag: str,\n        offline: bool = False,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the encoder sensor.\n        \"\"\"\n        super().__init__(tag=tag, offline=offline, **kwargs)\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Return a string representation of the encoder sensor.\n\n        Returns:\n            str: \"EncoderBase\"\n        \"\"\"\n        return \"EncoderBase\"\n\n    @property\n    @abstractmethod\n    def position(self) -&gt; float:\n        \"\"\"\n        Get the current encoder position.\n\n        Returns:\n            float: The current position value.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def velocity(self) -&gt; float:\n        \"\"\"\n        Get the current encoder velocity.\n\n        Returns:\n            float: The current velocity value.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/sensors/sensors_base/#opensourceleg.sensors.base.EncoderBase.position","title":"<code>position</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the current encoder position.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The current position value.</p>"},{"location":"api/sensors/sensors_base/#opensourceleg.sensors.base.EncoderBase.velocity","title":"<code>velocity</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the current encoder velocity.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The current velocity value.</p>"},{"location":"api/sensors/sensors_base/#opensourceleg.sensors.base.EncoderBase.__init__","title":"<code>__init__(tag, offline=False, **kwargs)</code>","text":"<p>Initialize the encoder sensor.</p> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>def __init__(\n    self,\n    tag: str,\n    offline: bool = False,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Initialize the encoder sensor.\n    \"\"\"\n    super().__init__(tag=tag, offline=offline, **kwargs)\n</code></pre>"},{"location":"api/sensors/sensors_base/#opensourceleg.sensors.base.EncoderBase.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the encoder sensor.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>\"EncoderBase\"</p> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Return a string representation of the encoder sensor.\n\n    Returns:\n        str: \"EncoderBase\"\n    \"\"\"\n    return \"EncoderBase\"\n</code></pre>"},{"location":"api/sensors/sensors_base/#opensourceleg.sensors.base.IMUBase","title":"<code>IMUBase</code>","text":"<p>               Bases: <code>SensorBase</code>, <code>ABC</code></p> <p>Abstract base class for Inertial Measurement Unit (IMU) sensors.</p> <p>IMUs typically provide acceleration and gyroscopic data.</p> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>class IMUBase(SensorBase, ABC):\n    \"\"\"\n    Abstract base class for Inertial Measurement Unit (IMU) sensors.\n\n    IMUs typically provide acceleration and gyroscopic data.\n    \"\"\"\n\n    # IMU-specific offline configuration\n    _OFFLINE_PROPERTIES: ClassVar[list[str]] = [\n        *SensorBase._OFFLINE_PROPERTIES,\n        \"acc_x\",\n        \"acc_y\",\n        \"acc_z\",\n        \"gyro_x\",\n        \"gyro_y\",\n        \"gyro_z\",\n    ]\n    _OFFLINE_PROPERTY_DEFAULTS: ClassVar[dict[str, Any]] = {\n        **SensorBase._OFFLINE_PROPERTY_DEFAULTS,\n        \"acc_x\": 0.0,\n        \"acc_y\": 0.0,\n        \"acc_z\": 0.0,  # Gravity in z-axis when stationary\n        \"gyro_x\": 0.0,\n        \"gyro_y\": 0.0,\n        \"gyro_z\": 0.0,\n    }\n\n    def __init__(self, tag: str, offline: bool = False, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Initialize the IMU sensor.\n        \"\"\"\n        super().__init__(tag=tag, offline=offline, **kwargs)\n\n    @property\n    @abstractmethod\n    def acc_x(self) -&gt; float:\n        \"\"\"\n        Get the estimated linear acceleration along the x-axis.\n\n        Returns:\n            float: Acceleration in m/s^2 along the x-axis.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def acc_y(self) -&gt; float:\n        \"\"\"\n        Get the estimated linear acceleration along the y-axis.\n\n        Returns:\n            float: Acceleration in m/s^2 along the y-axis.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def acc_z(self) -&gt; float:\n        \"\"\"\n        Get the estimated linear acceleration along the z-axis.\n\n        Returns:\n            float: Acceleration in m/s^2 along the z-axis.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def gyro_x(self) -&gt; float:\n        \"\"\"\n        Get the gyroscopic measurement along the x-axis.\n\n        Returns:\n            float: Angular velocity in rad/s along the x-axis.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def gyro_y(self) -&gt; float:\n        \"\"\"\n        Get the gyroscopic measurement along the y-axis.\n\n        Returns:\n            float: Angular velocity in rad/s along the y-axis.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def gyro_z(self) -&gt; float:\n        \"\"\"\n        Get the gyroscopic measurement along the z-axis.\n\n        Returns:\n            float: Angular velocity in rad/s along the z-axis.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/sensors/sensors_base/#opensourceleg.sensors.base.IMUBase.acc_x","title":"<code>acc_x</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the estimated linear acceleration along the x-axis.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Acceleration in m/s^2 along the x-axis.</p>"},{"location":"api/sensors/sensors_base/#opensourceleg.sensors.base.IMUBase.acc_y","title":"<code>acc_y</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the estimated linear acceleration along the y-axis.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Acceleration in m/s^2 along the y-axis.</p>"},{"location":"api/sensors/sensors_base/#opensourceleg.sensors.base.IMUBase.acc_z","title":"<code>acc_z</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the estimated linear acceleration along the z-axis.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Acceleration in m/s^2 along the z-axis.</p>"},{"location":"api/sensors/sensors_base/#opensourceleg.sensors.base.IMUBase.gyro_x","title":"<code>gyro_x</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the gyroscopic measurement along the x-axis.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Angular velocity in rad/s along the x-axis.</p>"},{"location":"api/sensors/sensors_base/#opensourceleg.sensors.base.IMUBase.gyro_y","title":"<code>gyro_y</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the gyroscopic measurement along the y-axis.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Angular velocity in rad/s along the y-axis.</p>"},{"location":"api/sensors/sensors_base/#opensourceleg.sensors.base.IMUBase.gyro_z","title":"<code>gyro_z</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the gyroscopic measurement along the z-axis.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Angular velocity in rad/s along the z-axis.</p>"},{"location":"api/sensors/sensors_base/#opensourceleg.sensors.base.IMUBase.__init__","title":"<code>__init__(tag, offline=False, **kwargs)</code>","text":"<p>Initialize the IMU sensor.</p> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>def __init__(self, tag: str, offline: bool = False, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Initialize the IMU sensor.\n    \"\"\"\n    super().__init__(tag=tag, offline=offline, **kwargs)\n</code></pre>"},{"location":"api/sensors/sensors_base/#opensourceleg.sensors.base.LoadcellBase","title":"<code>LoadcellBase</code>","text":"<p>               Bases: <code>SensorBase</code>, <code>ABC</code></p> <p>Abstract base class for load cell sensors.</p> <p>Load cells are used to measure forces and moments.</p> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>class LoadcellBase(SensorBase, ABC):\n    \"\"\"\n    Abstract base class for load cell sensors.\n\n    Load cells are used to measure forces and moments.\n    \"\"\"\n\n    # Load cell-specific offline configuration\n    _OFFLINE_METHODS: ClassVar[list[str]] = [*SensorBase._OFFLINE_METHODS, \"calibrate\", \"reset\"]\n    _OFFLINE_PROPERTIES: ClassVar[list[str]] = [\n        *SensorBase._OFFLINE_PROPERTIES,\n        \"fx\",\n        \"fy\",\n        \"fz\",\n        \"mx\",\n        \"my\",\n        \"mz\",\n        \"is_calibrated\",\n    ]\n    _OFFLINE_PROPERTY_DEFAULTS: ClassVar[dict[str, Any]] = {\n        **SensorBase._OFFLINE_PROPERTY_DEFAULTS,\n        \"fx\": 0.0,\n        \"fy\": 0.0,\n        \"fz\": 0.0,  # Could be -9.81 * mass for gravity simulation\n        \"mx\": 0.0,\n        \"my\": 0.0,\n        \"mz\": 0.0,\n        \"is_calibrated\": True,\n    }\n\n    def __init__(self, tag: str, offline: bool = False, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Initialize the load cell sensor.\n        \"\"\"\n        super().__init__(tag=tag, offline=offline, **kwargs)\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Return a string representation of the load cell sensor.\n\n        Returns:\n            str: \"LoadcellBase\"\n        \"\"\"\n        return \"LoadcellBase\"\n\n    @abstractmethod\n    def calibrate(self) -&gt; None:\n        \"\"\"\n        Calibrate the load cell sensor.\n\n        Implementations should perform the calibration procedure to ensure accurate readings.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def reset(self) -&gt; None:\n        \"\"\"\n        Reset the load cell sensor.\n\n        Implementations should reset the sensor state and any calibration data.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def fx(self) -&gt; float:\n        \"\"\"\n        Get the force along the x-axis.\n\n        Returns:\n            float: The force measured along the x-axis.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def fy(self) -&gt; float:\n        \"\"\"\n        Get the force along the y-axis.\n\n        Returns:\n            float: The force measured along the y-axis.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def fz(self) -&gt; float:\n        \"\"\"\n        Get the force along the z-axis.\n\n        Returns:\n            float: The force measured along the z-axis.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def mx(self) -&gt; float:\n        \"\"\"\n        Get the moment about the x-axis.\n\n        Returns:\n            float: The moment measured about the x-axis.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def my(self) -&gt; float:\n        \"\"\"\n        Get the moment about the y-axis.\n\n        Returns:\n            float: The moment measured about the y-axis.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def mz(self) -&gt; float:\n        \"\"\"\n        Get the moment about the z-axis.\n\n        Returns:\n            float: The moment measured about the z-axis.\n        \"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def is_calibrated(self) -&gt; bool:\n        \"\"\"\n        Check if the load cell sensor is calibrated.\n\n        Returns:\n            bool: True if calibrated, False otherwise.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/sensors/sensors_base/#opensourceleg.sensors.base.LoadcellBase.fx","title":"<code>fx</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the force along the x-axis.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The force measured along the x-axis.</p>"},{"location":"api/sensors/sensors_base/#opensourceleg.sensors.base.LoadcellBase.fy","title":"<code>fy</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the force along the y-axis.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The force measured along the y-axis.</p>"},{"location":"api/sensors/sensors_base/#opensourceleg.sensors.base.LoadcellBase.fz","title":"<code>fz</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the force along the z-axis.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The force measured along the z-axis.</p>"},{"location":"api/sensors/sensors_base/#opensourceleg.sensors.base.LoadcellBase.is_calibrated","title":"<code>is_calibrated</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Check if the load cell sensor is calibrated.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if calibrated, False otherwise.</p>"},{"location":"api/sensors/sensors_base/#opensourceleg.sensors.base.LoadcellBase.mx","title":"<code>mx</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the moment about the x-axis.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The moment measured about the x-axis.</p>"},{"location":"api/sensors/sensors_base/#opensourceleg.sensors.base.LoadcellBase.my","title":"<code>my</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the moment about the y-axis.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The moment measured about the y-axis.</p>"},{"location":"api/sensors/sensors_base/#opensourceleg.sensors.base.LoadcellBase.mz","title":"<code>mz</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the moment about the z-axis.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The moment measured about the z-axis.</p>"},{"location":"api/sensors/sensors_base/#opensourceleg.sensors.base.LoadcellBase.__init__","title":"<code>__init__(tag, offline=False, **kwargs)</code>","text":"<p>Initialize the load cell sensor.</p> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>def __init__(self, tag: str, offline: bool = False, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Initialize the load cell sensor.\n    \"\"\"\n    super().__init__(tag=tag, offline=offline, **kwargs)\n</code></pre>"},{"location":"api/sensors/sensors_base/#opensourceleg.sensors.base.LoadcellBase.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the load cell sensor.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>\"LoadcellBase\"</p> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Return a string representation of the load cell sensor.\n\n    Returns:\n        str: \"LoadcellBase\"\n    \"\"\"\n    return \"LoadcellBase\"\n</code></pre>"},{"location":"api/sensors/sensors_base/#opensourceleg.sensors.base.LoadcellBase.calibrate","title":"<code>calibrate()</code>  <code>abstractmethod</code>","text":"<p>Calibrate the load cell sensor.</p> <p>Implementations should perform the calibration procedure to ensure accurate readings.</p> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>@abstractmethod\ndef calibrate(self) -&gt; None:\n    \"\"\"\n    Calibrate the load cell sensor.\n\n    Implementations should perform the calibration procedure to ensure accurate readings.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/sensors/sensors_base/#opensourceleg.sensors.base.LoadcellBase.reset","title":"<code>reset()</code>  <code>abstractmethod</code>","text":"<p>Reset the load cell sensor.</p> <p>Implementations should reset the sensor state and any calibration data.</p> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>@abstractmethod\ndef reset(self) -&gt; None:\n    \"\"\"\n    Reset the load cell sensor.\n\n    Implementations should reset the sensor state and any calibration data.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/sensors/sensors_base/#opensourceleg.sensors.base.SensorBase","title":"<code>SensorBase</code>","text":"<p>               Bases: <code>OfflineMixin</code>, <code>ABC</code></p> <p>Abstract base class for sensors.</p> <p>Defines the common interface for sensors including starting, stopping, updating, and streaming status.</p> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>class SensorBase(OfflineMixin, ABC):\n    \"\"\"\n    Abstract base class for sensors.\n\n    Defines the common interface for sensors including starting, stopping,\n    updating, and streaming status.\n    \"\"\"\n\n    # Base sensor offline configuration\n    _OFFLINE_METHODS: ClassVar[list[str]] = [\"start\", \"stop\", \"update\"]\n    _OFFLINE_PROPERTIES: ClassVar[list[str]] = [\"data\", \"is_streaming\"]\n    _OFFLINE_PROPERTY_DEFAULTS: ClassVar[dict[str, Any]] = {\n        \"data\": None,\n        \"is_streaming\": True,\n    }\n\n    def __init__(\n        self,\n        tag: str,\n        offline: bool = False,\n        **kwargs: Any,\n    ) -&gt; None:\n        self._tag = tag\n        # Initialize OfflineMixin first\n        super().__init__(offline=offline, **kwargs)\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Return a string representation of the sensor.\n\n        Returns:\n            str: A string identifying the sensor class.\n        \"\"\"\n        return f\"{self.tag}[{self.__class__.__name__}]\"\n\n    @property\n    @abstractmethod\n    def data(self) -&gt; Any:\n        \"\"\"\n        Get the sensor data.\n\n        Returns:\n            Any: The current data from the sensor.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def start(self) -&gt; None:\n        \"\"\"\n        Start the sensor streaming.\n\n        Implementations should handle initializing the sensor and beginning data acquisition.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def stop(self) -&gt; None:\n        \"\"\"\n        Stop the sensor streaming.\n\n        Implementations should handle gracefully shutting down the sensor.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def update(self) -&gt; None:\n        \"\"\"\n        Update the sensor state or data.\n\n        Implementations should refresh or poll the sensor data as needed.\n        \"\"\"\n        pass\n\n    def __enter__(self) -&gt; \"SensorBase\":\n        \"\"\"\n        Enter the runtime context for the sensor.\n\n        This method calls start() and returns the sensor instance.\n\n        Returns:\n            SensorBase: The sensor instance.\n        \"\"\"\n        self.start()\n        return self\n\n    def __exit__(self, exc_type: Any, exc_value: Any, traceback: Any) -&gt; None:\n        \"\"\"\n        Exit the runtime context for the sensor.\n\n        This method calls stop() to shut down the sensor.\n\n        Args:\n            exc_type (Any): Exception type if raised.\n            exc_value (Any): Exception value if raised.\n            traceback (Any): Traceback if an exception occurred.\n        \"\"\"\n        self.stop()\n\n    @property\n    @abstractmethod\n    def is_streaming(self) -&gt; bool:\n        \"\"\"\n        Check if the sensor is currently streaming.\n\n        Returns:\n            bool: True if the sensor is streaming, False otherwise.\n        \"\"\"\n        pass\n\n    @property\n    def tag(self) -&gt; str:\n        \"\"\"\n        Get the sensor tag.\n\n        Returns:\n            str: The unique identifier for the sensor.\n\n        Examples:\n            &gt;&gt;&gt; sensor.tag\n            \"sensor1\"\n        \"\"\"\n        return self._tag\n</code></pre>"},{"location":"api/sensors/sensors_base/#opensourceleg.sensors.base.SensorBase.data","title":"<code>data</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Get the sensor data.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The current data from the sensor.</p>"},{"location":"api/sensors/sensors_base/#opensourceleg.sensors.base.SensorBase.is_streaming","title":"<code>is_streaming</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Check if the sensor is currently streaming.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the sensor is streaming, False otherwise.</p>"},{"location":"api/sensors/sensors_base/#opensourceleg.sensors.base.SensorBase.tag","title":"<code>tag</code>  <code>property</code>","text":"<p>Get the sensor tag.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The unique identifier for the sensor.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sensor.tag\n\"sensor1\"\n</code></pre>"},{"location":"api/sensors/sensors_base/#opensourceleg.sensors.base.SensorBase.__enter__","title":"<code>__enter__()</code>","text":"<p>Enter the runtime context for the sensor.</p> <p>This method calls start() and returns the sensor instance.</p> <p>Returns:</p> Name Type Description <code>SensorBase</code> <code>SensorBase</code> <p>The sensor instance.</p> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>def __enter__(self) -&gt; \"SensorBase\":\n    \"\"\"\n    Enter the runtime context for the sensor.\n\n    This method calls start() and returns the sensor instance.\n\n    Returns:\n        SensorBase: The sensor instance.\n    \"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"api/sensors/sensors_base/#opensourceleg.sensors.base.SensorBase.__exit__","title":"<code>__exit__(exc_type, exc_value, traceback)</code>","text":"<p>Exit the runtime context for the sensor.</p> <p>This method calls stop() to shut down the sensor.</p> <p>Parameters:</p> Name Type Description Default <code>exc_type</code> <code>Any</code> <p>Exception type if raised.</p> required <code>exc_value</code> <code>Any</code> <p>Exception value if raised.</p> required <code>traceback</code> <code>Any</code> <p>Traceback if an exception occurred.</p> required Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>def __exit__(self, exc_type: Any, exc_value: Any, traceback: Any) -&gt; None:\n    \"\"\"\n    Exit the runtime context for the sensor.\n\n    This method calls stop() to shut down the sensor.\n\n    Args:\n        exc_type (Any): Exception type if raised.\n        exc_value (Any): Exception value if raised.\n        traceback (Any): Traceback if an exception occurred.\n    \"\"\"\n    self.stop()\n</code></pre>"},{"location":"api/sensors/sensors_base/#opensourceleg.sensors.base.SensorBase.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the sensor.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string identifying the sensor class.</p> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Return a string representation of the sensor.\n\n    Returns:\n        str: A string identifying the sensor class.\n    \"\"\"\n    return f\"{self.tag}[{self.__class__.__name__}]\"\n</code></pre>"},{"location":"api/sensors/sensors_base/#opensourceleg.sensors.base.SensorBase.start","title":"<code>start()</code>  <code>abstractmethod</code>","text":"<p>Start the sensor streaming.</p> <p>Implementations should handle initializing the sensor and beginning data acquisition.</p> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>@abstractmethod\ndef start(self) -&gt; None:\n    \"\"\"\n    Start the sensor streaming.\n\n    Implementations should handle initializing the sensor and beginning data acquisition.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/sensors/sensors_base/#opensourceleg.sensors.base.SensorBase.stop","title":"<code>stop()</code>  <code>abstractmethod</code>","text":"<p>Stop the sensor streaming.</p> <p>Implementations should handle gracefully shutting down the sensor.</p> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>@abstractmethod\ndef stop(self) -&gt; None:\n    \"\"\"\n    Stop the sensor streaming.\n\n    Implementations should handle gracefully shutting down the sensor.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/sensors/sensors_base/#opensourceleg.sensors.base.SensorBase.update","title":"<code>update()</code>  <code>abstractmethod</code>","text":"<p>Update the sensor state or data.</p> <p>Implementations should refresh or poll the sensor data as needed.</p> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>@abstractmethod\ndef update(self) -&gt; None:\n    \"\"\"\n    Update the sensor state or data.\n\n    Implementations should refresh or poll the sensor data as needed.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/sensors/sensors_base/#opensourceleg.sensors.base.SensorNotStreamingException","title":"<code>SensorNotStreamingException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when an operation is attempted on a sensor that is not streaming.</p> <p>This exception indicates that the sensor is not actively streaming data.</p> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>class SensorNotStreamingException(Exception):\n    \"\"\"\n    Exception raised when an operation is attempted on a sensor that is not streaming.\n\n    This exception indicates that the sensor is not actively streaming data.\n    \"\"\"\n\n    def __init__(self, sensor_name: str = \"Sensor\") -&gt; None:\n        \"\"\"\n        Initialize the SensorNotStreamingException.\n\n        Args:\n            sensor_name (str, optional): The name or identifier of the sensor. Defaults to \"Sensor\".\n        \"\"\"\n        super().__init__(\n            f\"{sensor_name} is not streaming, please ensure that the connections are intact, \"\n            f\"power is on, and the start method is called.\"\n        )\n</code></pre>"},{"location":"api/sensors/sensors_base/#opensourceleg.sensors.base.SensorNotStreamingException.__init__","title":"<code>__init__(sensor_name='Sensor')</code>","text":"<p>Initialize the SensorNotStreamingException.</p> <p>Parameters:</p> Name Type Description Default <code>sensor_name</code> <code>str</code> <p>The name or identifier of the sensor. Defaults to \"Sensor\".</p> <code>'Sensor'</code> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>def __init__(self, sensor_name: str = \"Sensor\") -&gt; None:\n    \"\"\"\n    Initialize the SensorNotStreamingException.\n\n    Args:\n        sensor_name (str, optional): The name or identifier of the sensor. Defaults to \"Sensor\".\n    \"\"\"\n    super().__init__(\n        f\"{sensor_name} is not streaming, please ensure that the connections are intact, \"\n        f\"power is on, and the start method is called.\"\n    )\n</code></pre>"},{"location":"api/sensors/sensors_base/#opensourceleg.sensors.base.check_sensor_stream","title":"<code>check_sensor_stream(func)</code>","text":"<p>Decorator to ensure that a sensor is streaming before executing the decorated method.</p> <p>If the sensor is not streaming, a SensorNotStreamingException is raised.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>The sensor method to be wrapped.</p> required <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable</code> <p>The wrapped method that checks streaming status before execution.</p> Source code in <code>opensourceleg/sensors/base.py</code> <pre><code>def check_sensor_stream(func: Callable) -&gt; Callable:\n    \"\"\"\n    Decorator to ensure that a sensor is streaming before executing the decorated method.\n\n    If the sensor is not streaming, a SensorNotStreamingException is raised.\n\n    Args:\n        func (Callable): The sensor method to be wrapped.\n\n    Returns:\n        Callable: The wrapped method that checks streaming status before execution.\n    \"\"\"\n\n    @wraps(func)\n    def wrapper(self: Any, *args: Any, **kwargs: Any) -&gt; Any:\n        # TODO: This could be a generic type that points to actuator, sensor, etc.\n        if not self.is_streaming:\n            raise SensorNotStreamingException(sensor_name=self.__repr__())\n        return func(self, *args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"api/utilities/profile/","title":"Profiler","text":""},{"location":"api/utilities/profile/#opensourceleg.utilities.profile.Profiler","title":"<code>Profiler</code>","text":"<p>A class to profile the execution speed of real-time code.</p> Can use in four ways <ol> <li>tic/toc</li> <li>lambda</li> <li>decorator</li> <li>context manager</li> </ol> <p>See examples in the main block of this file.</p> <p>Based on original implementation in https://github.com/UM-LoCoLab/NeuroLocoMiddleware</p> <p>Note:     This profiler bases its calculation on the system time and includes in its calculations     any time spent waiting for user input, interfacing with I/O, etc.     Use caution when profiling any code with such components, as differences in user response     or external systems can affect the result.</p> Author <ul> <li>Dr. Gray Cortright Thomas gthomas@tamu.edu</li> <li>Kevin Best tkevinbest@gmail.com</li> </ul> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the profiler instance.</p> required Source code in <code>opensourceleg/utilities/profile.py</code> <pre><code>class Profiler:\n    \"\"\"\n    A class to profile the execution speed of real-time code.\n\n    Can use in four ways:\n        1. tic/toc\n        2. lambda\n        3. decorator\n        4. context manager\n\n    See examples in the main block of this file.\n\n    Based on original implementation in https://github.com/UM-LoCoLab/NeuroLocoMiddleware\n\n    **Note**:\n        This profiler bases its calculation on the system time and includes in its calculations\n        any time spent waiting for user input, interfacing with I/O, etc.\n        Use caution when profiling any code with such components, as differences in user response\n        or external systems can affect the result.\n\n    Author:\n        - Dr. Gray Cortright Thomas &lt;gthomas@tamu.edu&gt;\n        - Kevin Best &lt;tkevinbest@gmail.com&gt;\n\n    Args:\n        name (str): The name of the profiler instance.\n    \"\"\"\n\n    def __init__(self, name: str):\n        self._N: int = 0\n        self._agg: float = 0.0\n        self._aggvar: float = 0.0\n        self.name: str = name\n        self._t0: Union[float, None] = None\n\n    def __del__(self) -&gt; None:\n        \"\"\"\n        Destructor to print profiling results when the instance is deleted.\n        \"\"\"\n        try:\n            mean: float = self.agg / self.N\n            stddev: float = sqrt((self.aggvar - self.N * mean**2) / (self.N - 1))\n        except ZeroDivisionError:\n            mean = float(\"NaN\")\n            stddev = float(\"NaN\")\n        print(\n            f\"Profiler Results - {self.name}: N = {self.N}, avg: {mean * 1e3} ms, \"\n            f\"stddev: {stddev * 1e3} ms, total: {self.agg} s\"\n        )\n\n    def __enter__(self) -&gt; None:\n        self.tic()\n\n    def __exit__(self, *args: Any) -&gt; None:\n        self.toc()\n\n    @property\n    def N(self) -&gt; int:\n        \"\"\"\n        Get the number of recorded intervals.\n\n        Returns:\n            int: The number of recorded intervals.\n        \"\"\"\n        return self._N\n\n    @property\n    def agg(self) -&gt; float:\n        \"\"\"\n        Get the aggregate time of all intervals.\n\n        Returns:\n            float: The aggregate time.\n        \"\"\"\n        return self._agg\n\n    @property\n    def aggvar(self) -&gt; float:\n        \"\"\"\n        Get the aggregate variance of all intervals.\n\n        Returns:\n            float: The aggregate variance.\n        \"\"\"\n        return self._aggvar\n\n    def tic(self) -&gt; None:\n        \"\"\"\n        Start a new timing interval.\n\n        Example:\n            profiler = Profiler(\"example\")\n            profiler.tic()\n            time.sleep(0.1)\n            profiler.toc()\n        \"\"\"\n        self._t0 = time.perf_counter()\n\n    def toc(self) -&gt; float:\n        \"\"\"\n        End the current timing interval and record its duration.\n\n        Returns:\n            float: The duration of the interval.\n\n        Example:\n            profiler = Profiler(\"example\")\n            profiler.tic()\n            time.sleep(0.1)\n            duration = profiler.toc()\n        \"\"\"\n        if self._t0 is not None:\n            t: float = time.perf_counter() - self._t0\n            self._N += 1\n            self._agg += t\n            self._aggvar += t**2\n            return t\n        return 0.0\n\n    def profile(self, func: Callable[[], Any]) -&gt; Any:\n        \"\"\"\n        Profile a function by measuring its execution time.\n\n        Args:\n            func (callable): The function to profile.\n\n        Returns:\n            Any: The return value of the function.\n\n        Example:\n            profiler = Profiler(\"example\")\n            result = profiler.profile(lambda: time.sleep(0.1))\n        \"\"\"\n        self.tic()\n        x: Any = func()\n        self.toc()\n        return x\n\n    def decorate(self, func: Callable[..., Any]) -&gt; Callable[..., Any]:\n        \"\"\"\n        Decorate a function to automatically profile its execution time.\n\n        Args:\n            func (callable): The function to decorate.\n\n        Returns:\n            callable: The decorated function.\n\n        Example:\n            profiler = Profiler(\"example\")\n\n            @profiler.decorate\n            def my_function():\n                time.sleep(0.1)\n\n            my_function()\n        \"\"\"\n\n        def ret(*args: Any, **kwargs: Any) -&gt; Any:\n            self.tic()\n            x: Any = func(*args, **kwargs)\n            self.toc()\n            return x\n\n        return ret\n</code></pre>"},{"location":"api/utilities/profile/#opensourceleg.utilities.profile.Profiler.N","title":"<code>N</code>  <code>property</code>","text":"<p>Get the number of recorded intervals.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of recorded intervals.</p>"},{"location":"api/utilities/profile/#opensourceleg.utilities.profile.Profiler.agg","title":"<code>agg</code>  <code>property</code>","text":"<p>Get the aggregate time of all intervals.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The aggregate time.</p>"},{"location":"api/utilities/profile/#opensourceleg.utilities.profile.Profiler.aggvar","title":"<code>aggvar</code>  <code>property</code>","text":"<p>Get the aggregate variance of all intervals.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The aggregate variance.</p>"},{"location":"api/utilities/profile/#opensourceleg.utilities.profile.Profiler.__del__","title":"<code>__del__()</code>","text":"<p>Destructor to print profiling results when the instance is deleted.</p> Source code in <code>opensourceleg/utilities/profile.py</code> <pre><code>def __del__(self) -&gt; None:\n    \"\"\"\n    Destructor to print profiling results when the instance is deleted.\n    \"\"\"\n    try:\n        mean: float = self.agg / self.N\n        stddev: float = sqrt((self.aggvar - self.N * mean**2) / (self.N - 1))\n    except ZeroDivisionError:\n        mean = float(\"NaN\")\n        stddev = float(\"NaN\")\n    print(\n        f\"Profiler Results - {self.name}: N = {self.N}, avg: {mean * 1e3} ms, \"\n        f\"stddev: {stddev * 1e3} ms, total: {self.agg} s\"\n    )\n</code></pre>"},{"location":"api/utilities/profile/#opensourceleg.utilities.profile.Profiler.decorate","title":"<code>decorate(func)</code>","text":"<p>Decorate a function to automatically profile its execution time.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>callable</code> <p>The function to decorate.</p> required <p>Returns:</p> Name Type Description <code>callable</code> <code>Callable[..., Any]</code> <p>The decorated function.</p> Example <p>profiler = Profiler(\"example\")</p> <p>@profiler.decorate def my_function():     time.sleep(0.1)</p> <p>my_function()</p> Source code in <code>opensourceleg/utilities/profile.py</code> <pre><code>def decorate(self, func: Callable[..., Any]) -&gt; Callable[..., Any]:\n    \"\"\"\n    Decorate a function to automatically profile its execution time.\n\n    Args:\n        func (callable): The function to decorate.\n\n    Returns:\n        callable: The decorated function.\n\n    Example:\n        profiler = Profiler(\"example\")\n\n        @profiler.decorate\n        def my_function():\n            time.sleep(0.1)\n\n        my_function()\n    \"\"\"\n\n    def ret(*args: Any, **kwargs: Any) -&gt; Any:\n        self.tic()\n        x: Any = func(*args, **kwargs)\n        self.toc()\n        return x\n\n    return ret\n</code></pre>"},{"location":"api/utilities/profile/#opensourceleg.utilities.profile.Profiler.profile","title":"<code>profile(func)</code>","text":"<p>Profile a function by measuring its execution time.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>callable</code> <p>The function to profile.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The return value of the function.</p> Example <p>profiler = Profiler(\"example\") result = profiler.profile(lambda: time.sleep(0.1))</p> Source code in <code>opensourceleg/utilities/profile.py</code> <pre><code>def profile(self, func: Callable[[], Any]) -&gt; Any:\n    \"\"\"\n    Profile a function by measuring its execution time.\n\n    Args:\n        func (callable): The function to profile.\n\n    Returns:\n        Any: The return value of the function.\n\n    Example:\n        profiler = Profiler(\"example\")\n        result = profiler.profile(lambda: time.sleep(0.1))\n    \"\"\"\n    self.tic()\n    x: Any = func()\n    self.toc()\n    return x\n</code></pre>"},{"location":"api/utilities/profile/#opensourceleg.utilities.profile.Profiler.tic","title":"<code>tic()</code>","text":"<p>Start a new timing interval.</p> Example <p>profiler = Profiler(\"example\") profiler.tic() time.sleep(0.1) profiler.toc()</p> Source code in <code>opensourceleg/utilities/profile.py</code> <pre><code>def tic(self) -&gt; None:\n    \"\"\"\n    Start a new timing interval.\n\n    Example:\n        profiler = Profiler(\"example\")\n        profiler.tic()\n        time.sleep(0.1)\n        profiler.toc()\n    \"\"\"\n    self._t0 = time.perf_counter()\n</code></pre>"},{"location":"api/utilities/profile/#opensourceleg.utilities.profile.Profiler.toc","title":"<code>toc()</code>","text":"<p>End the current timing interval and record its duration.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The duration of the interval.</p> Example <p>profiler = Profiler(\"example\") profiler.tic() time.sleep(0.1) duration = profiler.toc()</p> Source code in <code>opensourceleg/utilities/profile.py</code> <pre><code>def toc(self) -&gt; float:\n    \"\"\"\n    End the current timing interval and record its duration.\n\n    Returns:\n        float: The duration of the interval.\n\n    Example:\n        profiler = Profiler(\"example\")\n        profiler.tic()\n        time.sleep(0.1)\n        duration = profiler.toc()\n    \"\"\"\n    if self._t0 is not None:\n        t: float = time.perf_counter() - self._t0\n        self._N += 1\n        self._agg += t\n        self._aggvar += t**2\n        return t\n    return 0.0\n</code></pre>"},{"location":"api/utilities/softrealtimeloop/","title":"SoftRealtimeLoop","text":""},{"location":"api/utilities/softrealtimeloop/#opensourceleg.utilities.softrealtimeloop.LoopKiller","title":"<code>LoopKiller</code>","text":"<p>Soft Realtime Loop---a class designed to allow clean exits from infinite loops with the potential for post-loop cleanup operations executing.</p> <p>The Loop Killer object watches for the key shutdown signals on the UNIX operating system (which runs on the PI) when it detects a shutdown signal, it sets a flag, which is used by the Soft Realtime Loop to stop iterating. Typically, it detects the CTRL-C from your keyboard, which sends a SIGTERM signal.</p> <p>the function_in_loop argument to the Soft Realtime Loop's blocking_loop method is the function to be run every loop. A typical usage would set function_in_loop to be a method of an object, so that the object could store program state. See the 'ifmain' for two examples.</p>"},{"location":"api/utilities/softrealtimeloop/#opensourceleg.utilities.softrealtimeloop.LoopKiller--this-library-will-soon-be-hosted-as-a-pip-module-and-added-as-a-python-dependency","title":"This library will soon be hosted as a PIP module and added as a python dependency.","text":""},{"location":"api/utilities/softrealtimeloop/#opensourceleg.utilities.softrealtimeloop.LoopKiller--httpsgithubcomum-locolabneurolocomiddlewareblobmainsoftrealtimelooppy","title":"https://github.com/UM-LoCoLab/NeuroLocoMiddleware/blob/main/SoftRealtimeLoop.py","text":"<p>Author: Gray C. Thomas, Ph.D https://github.com/GrayThomas, https://graythomas.github.io</p> Source code in <code>opensourceleg/utilities/softrealtimeloop.py</code> <pre><code>class LoopKiller:\n    \"\"\"\n    Soft Realtime Loop---a class designed to allow clean exits from infinite loops\n    with the potential for post-loop cleanup operations executing.\n\n    The Loop Killer object watches for the key shutdown signals on the UNIX operating system (which runs on the PI)\n    when it detects a shutdown signal, it sets a flag, which is used by the Soft Realtime Loop to stop iterating.\n    Typically, it detects the CTRL-C from your keyboard, which sends a SIGTERM signal.\n\n    the function_in_loop argument to the Soft Realtime Loop's blocking_loop method is the function to be run every loop.\n    A typical usage would set function_in_loop to be a method of an object, so that the object\n    could store program state. See the 'ifmain' for two examples.\n\n    # This library will soon be hosted as a PIP module and added as a python dependency.\n    # https://github.com/UM-LoCoLab/NeuroLocoMiddleware/blob/main/SoftRealtimeLoop.py\n\n    Author: Gray C. Thomas, Ph.D\n    https://github.com/GrayThomas, https://graythomas.github.io\n\n    \"\"\"\n\n    def __init__(self, fade_time: float = 0.0):\n        if os.name == \"posix\":\n            self.signals = [signal.SIGTERM, signal.SIGINT, signal.SIGHUP]\n        else:\n            self.signals = [signal.SIGTERM, signal.SIGINT]\n\n        for sig in self.signals:\n            signal.signal(sig, self.handle_signal)\n\n        self._fade_time: float = fade_time\n        self._soft_kill_time: float = 0.0\n\n    def __repr__(self) -&gt; str:\n        return \"LoopKiller\"\n\n    def handle_signal(self, signum: Any, frame: Any) -&gt; None:\n        \"\"\"\n        Method to handle the signal from the operating system.\n        This method is called when the operating system sends a signal to the process.\n        The signal is typically a shutdown signal, such as SIGTERM, SIGINT, or SIGHUP.\n\n        Args:\n            signum (Any): The signal number.\n            frame (Any): The frame object.\n\n        Returns:\n            None\n\n        Example:\n            &gt;&gt;&gt; killer = LoopKiller()\n            &gt;&gt;&gt; killer.handle_signal(signal.SIGTERM, None)\n        \"\"\"\n        self.kill_now = True\n\n    def get_fade(self) -&gt; float:\n        \"\"\"\n        Interpolates from 1 to zero with soft fade out.\n\n        Returns:\n            float: The fade value.\n\n        Example:\n            &gt;&gt;&gt; killer = LoopKiller()\n            &gt;&gt;&gt; killer.get_fade()\n        \"\"\"\n        if self._kill_soon:\n            t = time.monotonic() - self._soft_kill_time\n            if t &gt;= self._fade_time:\n                return 0.0\n            return 1.0 - (t / self._fade_time)\n        return 1.0\n\n    _kill_now = False\n    _kill_soon = False\n\n    @property\n    def kill_now(self) -&gt; bool:\n        \"\"\"\n        Property to get the kill_now value.\n        If the kill_now value is True, the loop will stop iterating.\n        If the kill_now value is False, the loop will continue iterating.\n\n        Returns:\n            bool: The kill_now value.\n\n        Example:\n            &gt;&gt;&gt; killer = LoopKiller()\n            &gt;&gt;&gt; killer.kill_now\n        \"\"\"\n\n        if self._kill_now:\n            return True\n        if self._kill_soon:\n            t = time.monotonic() - self._soft_kill_time\n            if t &gt; self._fade_time:\n                self._kill_now = True\n        return self._kill_now\n\n    @kill_now.setter\n    def kill_now(self, val: bool) -&gt; None:\n        \"\"\"\n        Setter for the kill_now value. If true is set twice, then the loop will stop iterating immediately.\n\n        Args:\n            val (bool): The value to set the kill_now value to.\n\n        Returns:\n            None\n        \"\"\"\n        if val:\n            if self._kill_soon:  # if you kill twice, then it becomes immediate\n                self._kill_now = True\n            else:\n                if self._fade_time &gt; 0.0:\n                    self._kill_soon = True\n                    self._soft_kill_time = time.monotonic()\n                else:\n                    self._kill_now = True\n        else:\n            self._kill_now = False\n            self._kill_soon = False\n            self._soft_kill_time = 0.0\n</code></pre>"},{"location":"api/utilities/softrealtimeloop/#opensourceleg.utilities.softrealtimeloop.LoopKiller.kill_now","title":"<code>kill_now</code>  <code>property</code> <code>writable</code>","text":"<p>Property to get the kill_now value. If the kill_now value is True, the loop will stop iterating. If the kill_now value is False, the loop will continue iterating.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>The kill_now value.</p> Example <p>killer = LoopKiller() killer.kill_now</p>"},{"location":"api/utilities/softrealtimeloop/#opensourceleg.utilities.softrealtimeloop.LoopKiller.get_fade","title":"<code>get_fade()</code>","text":"<p>Interpolates from 1 to zero with soft fade out.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The fade value.</p> Example <p>killer = LoopKiller() killer.get_fade()</p> Source code in <code>opensourceleg/utilities/softrealtimeloop.py</code> <pre><code>def get_fade(self) -&gt; float:\n    \"\"\"\n    Interpolates from 1 to zero with soft fade out.\n\n    Returns:\n        float: The fade value.\n\n    Example:\n        &gt;&gt;&gt; killer = LoopKiller()\n        &gt;&gt;&gt; killer.get_fade()\n    \"\"\"\n    if self._kill_soon:\n        t = time.monotonic() - self._soft_kill_time\n        if t &gt;= self._fade_time:\n            return 0.0\n        return 1.0 - (t / self._fade_time)\n    return 1.0\n</code></pre>"},{"location":"api/utilities/softrealtimeloop/#opensourceleg.utilities.softrealtimeloop.LoopKiller.handle_signal","title":"<code>handle_signal(signum, frame)</code>","text":"<p>Method to handle the signal from the operating system. This method is called when the operating system sends a signal to the process. The signal is typically a shutdown signal, such as SIGTERM, SIGINT, or SIGHUP.</p> <p>Parameters:</p> Name Type Description Default <code>signum</code> <code>Any</code> <p>The signal number.</p> required <code>frame</code> <code>Any</code> <p>The frame object.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Example <p>killer = LoopKiller() killer.handle_signal(signal.SIGTERM, None)</p> Source code in <code>opensourceleg/utilities/softrealtimeloop.py</code> <pre><code>def handle_signal(self, signum: Any, frame: Any) -&gt; None:\n    \"\"\"\n    Method to handle the signal from the operating system.\n    This method is called when the operating system sends a signal to the process.\n    The signal is typically a shutdown signal, such as SIGTERM, SIGINT, or SIGHUP.\n\n    Args:\n        signum (Any): The signal number.\n        frame (Any): The frame object.\n\n    Returns:\n        None\n\n    Example:\n        &gt;&gt;&gt; killer = LoopKiller()\n        &gt;&gt;&gt; killer.handle_signal(signal.SIGTERM, None)\n    \"\"\"\n    self.kill_now = True\n</code></pre>"},{"location":"api/utilities/softrealtimeloop/#opensourceleg.utilities.softrealtimeloop.SoftRealtimeLoop","title":"<code>SoftRealtimeLoop</code>","text":"<p>Soft Realtime Loop---a class designed to allow clean exits from infinite loops with the potential for post-loop cleanup operations executing.</p> <p>The Loop Killer object watches for the key shutdown signals on the UNIX operating system (which runs on the PI). When it detects a shutdown signal, it sets a flag, which is used by the Soft Realtime Loop to stop iterating. Typically, it detects the CTRL-C from your keyboard, which sends a SIGTERM signal.</p> <p>The <code>function_in_loop</code> argument to the Soft Realtime Loop's <code>run</code> method is the function to be run every loop. A typical usage would set <code>function_in_loop</code> to be a method of an object, so that the object could store program state. See the <code>if __name__ == \"__main__\"</code> section for examples.</p> <p>This library is based on the original implementation in: https://github.com/UM-LoCoLab/NeuroLocoMiddleware/blob/main/SoftRealtimeLoop.py</p> Author <ul> <li>Gray C. Thomas, Ph.D https://graythomas.github.io</li> <li>Jos\u00e9 Montes P\u00e9rez https://github.com/jmontp</li> <li>Senthur Ayyappan https://github.com/senthurayyappan</li> <li>Kevin Best https://github.com/tkevinbest</li> </ul> Source code in <code>opensourceleg/utilities/softrealtimeloop.py</code> <pre><code>class SoftRealtimeLoop:\n    \"\"\"\n    Soft Realtime Loop---a class designed to allow clean exits from infinite loops\n    with the potential for post-loop cleanup operations executing.\n\n    The Loop Killer object watches for the key shutdown signals on the UNIX operating system (which runs on the PI).\n    When it detects a shutdown signal, it sets a flag, which is used by the Soft Realtime Loop to stop iterating.\n    Typically, it detects the CTRL-C from your keyboard, which sends a SIGTERM signal.\n\n    The `function_in_loop` argument to the Soft Realtime Loop's `run` method is the function to be run every loop.\n    A typical usage would set `function_in_loop` to be a method of an object, so that the object could store\n    program state. See the `if __name__ == \"__main__\"` section for examples.\n\n    This library is based on the original implementation in:\n    https://github.com/UM-LoCoLab/NeuroLocoMiddleware/blob/main/SoftRealtimeLoop.py\n\n    Author:\n        - Gray C. Thomas, Ph.D &lt;https://graythomas.github.io&gt;\n        - Jos\u00e9 Montes P\u00e9rez &lt;https://github.com/jmontp&gt;\n        - Senthur Ayyappan &lt;https://github.com/senthurayyappan&gt;\n        - Kevin Best &lt;https://github.com/tkevinbest&gt;\n    \"\"\"\n\n    def __init__(\n        self, dt: float = 0.001, report: bool = True, fade: float = 0.0, maintain_original_phase: bool = False\n    ):\n        \"\"\"\n        Initializes the SoftRealtimeLoop.\n\n        Args:\n            dt (float): The time step of the loop in seconds. Default is 0.001 (1ms).\n            report (bool): If True, the loop will print a report at the end of the loop. Default is True.\n            fade (float): The time in seconds to fade out the loop when it is killed. Default is 0.0.\n            maintain_original_phase (bool): If True, the iterator will try to keep the time elapsed\n                equal to (loop_number * dt). If False, the iterator will only look at the difference\n                between the current loop and the previous loop. Default is False.\n        \"\"\"\n        self._fade_time: float = fade\n        self.dt: float = dt\n        self.report: bool = report\n        self._maintain_original_phase: bool = maintain_original_phase  # Can only be configured at init\n        self.loop_start_time: float = time.monotonic()\n        self.loop_deadline: float = self.loop_start_time + self.dt\n        self.iteration_start_time: float = self.loop_start_time\n        self.sum_err: float = 0.0\n        self.sum_var: float = 0.0\n        self.sleep_t_agg: float = 0.0\n        self.n: int = 0\n        self.killer = LoopKiller(fade_time=self._fade_time)\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Returns a string representation of the SoftRealtimeLoop.\n\n        Returns:\n            str: The string representation of the loop.\n        \"\"\"\n        return \"SoftRealtimeLoop\"\n\n    def __del__(self) -&gt; None:\n        \"\"\"\n        Destructor for the SoftRealtimeLoop.\n        Prints the performance report if reporting is enabled.\n        \"\"\"\n        self.print_report()\n\n    def print_report(self) -&gt; None:\n        \"\"\"\n        Prints a performance report for the loop, including average error,\n        standard deviation of error, and percentage of time spent sleeping.\n        \"\"\"\n        if self.report and self.n &gt; 0:\n            print(\"In %d cycles at %.2f Hz:\" % (self.n, 1.0 / self.dt))\n            print(\"\\tavg error: %.3f milliseconds\" % (1e3 * self.sum_err / self.n))\n            if self.n &gt; 1:\n                print(\n                    \"\\tstddev error: %.3f milliseconds\"\n                    % (1e3 * sqrt(max(0, (self.sum_var - self.sum_err**2 / self.n) / (self.n - 1))))\n                )\n            else:\n                print(\"\\tstddev error: N/A (need at least 2 samples)\")\n\n            total_time = self.time_since_start\n            print(f\"\\ttotal time: {total_time:.1f} s\")\n            if total_time &gt; 0:\n                print(\"\\tpercent of time sleeping: %.1f %%\" % (self.sleep_t_agg / total_time * 100.0))\n            else:\n                print(\"\\tpercent of time sleeping: N/A (total time is zero)\")\n\n    def reset(self) -&gt; None:\n        \"\"\"\n        Resets the loop state and signal handlers to their initial state.\n        This allows reusing the same loop instance instead of creating a new one.\n\n        Example:\n            &gt;&gt;&gt; loop = SoftRealtimeLoop()\n            &gt;&gt;&gt; loop.run(some_function)\n            &gt;&gt;&gt; loop.reset()  # Reset for reuse\n            &gt;&gt;&gt; loop.run(another_function)\n        \"\"\"\n        if self.n &gt; 0:\n            self.print_report()\n        self.loop_start_time = time.monotonic()\n        self.loop_deadline = self.loop_start_time + self.dt\n        self.iteration_start_time = self.loop_start_time\n        self.sum_err = 0.0\n        self.sum_var = 0.0\n        self.sleep_t_agg = 0.0\n        self.n = 0\n        self.killer = LoopKiller(fade_time=self._fade_time)\n\n    def run(self, function_to_run: Callable[[], int]) -&gt; None:\n        \"\"\"\n        Runs the loop with the specified function.\n\n        Args:\n            function_to_run (Callable[[], int]): The function to execute in each loop iteration.\n                The function should return 0 to stop the loop.\n\n        Example:\n            &gt;&gt;&gt; loop = SoftRealtimeLoop()\n            &gt;&gt;&gt; loop.run(some_function)\n        \"\"\"\n        for _t in self:\n            result = function_to_run()\n            if result == 0:\n                self.stop()\n\n    @property\n    def fade(self) -&gt; float:\n        \"\"\"\n        Gets the fade value, which interpolates from 1 to 0 during a fade-out.\n\n        Returns:\n            float: The fade value.\n\n        Example:\n            &gt;&gt;&gt; loop = SoftRealtimeLoop()\n            &gt;&gt;&gt; loop.fade\n        \"\"\"\n        return self.killer.get_fade()\n\n    def stop(self) -&gt; None:\n        \"\"\"\n        Stops the loop by setting the kill flag.\n\n        Example:\n            &gt;&gt;&gt; loop = SoftRealtimeLoop()\n            &gt;&gt;&gt; loop.stop()\n        \"\"\"\n        self.killer.kill_now = True\n\n    def __iter__(self) -&gt; \"SoftRealtimeLoop\":\n        \"\"\"\n        Resets the loop and returns the iterator object.\n\n        Returns:\n            SoftRealtimeLoop: The iterator object.\n        \"\"\"\n        self.reset()\n        return self\n\n    def __next__(self) -&gt; float:\n        \"\"\"\n        Advances the loop to the next iteration.\n\n        Returns:\n            float: The time since the loop started.\n\n        Raises:\n            StopIteration: If the loop is stopped.\n        \"\"\"\n        if self._maintain_original_phase:\n            return self._next_original_phase()\n        else:\n            return self._next_consistent_dt()\n\n    def _next_original_phase(self) -&gt; float:\n        \"\"\"\n        Advances the loop using the maintain original phase method.\n\n        Returns:\n            float: The time since the loop started.\n\n        Raises:\n            StopIteration: If the loop is stopped.\n        \"\"\"\n        if self.killer.kill_now:\n            raise StopIteration\n\n        if self.n == 0:\n            self.n += 1\n            return self.time_since_start\n\n        ## Sleep the amount we need to satisfy the dt.\n        sleep_curr_loop = 0.0\n        # Calculate the time we need to sleep\n        sleep_time = self.loop_deadline - 2 * PRECISION_OF_SLEEP - time.monotonic()\n\n        while time.monotonic() &lt; self.loop_deadline - 2 * PRECISION_OF_SLEEP and not self.killer.kill_now:\n            t_pre_sleep = time.monotonic()\n            time.sleep(max(PRECISION_OF_SLEEP, self.loop_deadline - time.monotonic() - PRECISION_OF_SLEEP))\n            self.sleep_t_agg += time.monotonic() - t_pre_sleep\n\n        while sleep_time &gt; 0 and not self.killer.kill_now:\n            # Calculate the time spent sleeping\n            t_pre_sleep = time.monotonic()\n            # Sleep for the time we need to satisfy the dt\n            time.sleep(max(PRECISION_OF_SLEEP, sleep_time + PRECISION_OF_SLEEP))\n            # Update the time spent sleeping to calculate the sleep percentage\n            sleep_curr_loop += time.monotonic() - t_pre_sleep\n            # Recalculate if we still need to sleep\n            sleep_time = self.loop_deadline - 2 * PRECISION_OF_SLEEP - time.monotonic()\n\n        # Update the time slept\n        self.sleep_t_agg += sleep_curr_loop\n\n        # Busy wait until the time we should be running at\n        while time.monotonic() &lt; self.loop_deadline and not self.killer.kill_now:\n            if not hasattr(signal, \"sigtimedwait\"):\n                continue\n\n            if os.name == \"posix\" and signal.sigtimedwait(self.killer.signals, 0):\n                self.stop()\n\n        # If the loop is killed while we were waiting, raise a StopIteration\n        if self.killer.kill_now:\n            raise StopIteration\n\n        error = time.monotonic() - self.loop_deadline  # seconds\n        self.sum_err += error\n        self.sum_var += error**2\n        self.n += 1\n\n        # Increase the dt naively based on the time that we should have slept\n        self.loop_deadline += self.dt\n\n        return self.loop_deadline - self.loop_start_time\n\n    def _next_consistent_dt(self) -&gt; float:\n        \"\"\"\n        Advances the loop with a consistent time step.\n\n        Returns:\n            float: The time since the loop started.\n\n        Raises:\n            StopIteration: If the loop is stopped.\n        \"\"\"\n        if self.n == 0:\n            self.n += 1\n            return self.time_since_start\n\n        # If the loop is killed, raise a StopIteration\n        if self.killer.kill_now:\n            raise StopIteration\n\n        time_since_last_loop = time.monotonic() - self.iteration_start_time\n        sleep_time = max(self.dt - time_since_last_loop - 2 * PRECISION_OF_SLEEP, 0)\n        actual_time_to_sleep = max(PRECISION_OF_SLEEP, sleep_time)\n        time.sleep(actual_time_to_sleep)\n        # Update the time slept\n        self.sleep_t_agg += actual_time_to_sleep\n\n        # Busy wait to compensate for sleep durations precision\n        time_to_busy_wait = time.monotonic() + PRECISION_OF_SLEEP\n        while time.monotonic() &lt; time_to_busy_wait and not self.killer.kill_now:\n            if os.name == \"posix\" and hasattr(signal, \"sigtimedwait\") and signal.sigtimedwait(self.killer.signals, 0):\n                self.stop()\n                raise StopIteration\n\n        ## Handle how much error that we have in a given loop\n        # Calculate the error for the loop and update the max errors\n        error = (self.current_time - self.iteration_start_time) - self.dt\n        # Update the statistics for the error\n        self.sum_err += abs(error)\n        self.sum_var += abs(error) ** 2\n        self.n += 1\n\n        # Update the previous loop time\n        self.iteration_start_time = self.current_time\n\n        return self.time_since_start\n\n    @property\n    def time_since_start(self) -&gt; float:\n        \"\"\"\n        Gets the time elapsed since the loop started.\n\n        Returns:\n            float: The time since the loop started.\n        \"\"\"\n        return self.current_time - self.loop_start_time\n\n    @property\n    def current_time(self) -&gt; float:\n        \"\"\"\n        Gets the current monotonic time.\n\n        Returns:\n            float: The current monotonic time.\n        \"\"\"\n        return time.monotonic()\n</code></pre>"},{"location":"api/utilities/softrealtimeloop/#opensourceleg.utilities.softrealtimeloop.SoftRealtimeLoop.current_time","title":"<code>current_time</code>  <code>property</code>","text":"<p>Gets the current monotonic time.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The current monotonic time.</p>"},{"location":"api/utilities/softrealtimeloop/#opensourceleg.utilities.softrealtimeloop.SoftRealtimeLoop.fade","title":"<code>fade</code>  <code>property</code>","text":"<p>Gets the fade value, which interpolates from 1 to 0 during a fade-out.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The fade value.</p> Example <p>loop = SoftRealtimeLoop() loop.fade</p>"},{"location":"api/utilities/softrealtimeloop/#opensourceleg.utilities.softrealtimeloop.SoftRealtimeLoop.time_since_start","title":"<code>time_since_start</code>  <code>property</code>","text":"<p>Gets the time elapsed since the loop started.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The time since the loop started.</p>"},{"location":"api/utilities/softrealtimeloop/#opensourceleg.utilities.softrealtimeloop.SoftRealtimeLoop.__del__","title":"<code>__del__()</code>","text":"<p>Destructor for the SoftRealtimeLoop. Prints the performance report if reporting is enabled.</p> Source code in <code>opensourceleg/utilities/softrealtimeloop.py</code> <pre><code>def __del__(self) -&gt; None:\n    \"\"\"\n    Destructor for the SoftRealtimeLoop.\n    Prints the performance report if reporting is enabled.\n    \"\"\"\n    self.print_report()\n</code></pre>"},{"location":"api/utilities/softrealtimeloop/#opensourceleg.utilities.softrealtimeloop.SoftRealtimeLoop.__init__","title":"<code>__init__(dt=0.001, report=True, fade=0.0, maintain_original_phase=False)</code>","text":"<p>Initializes the SoftRealtimeLoop.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>float</code> <p>The time step of the loop in seconds. Default is 0.001 (1ms).</p> <code>0.001</code> <code>report</code> <code>bool</code> <p>If True, the loop will print a report at the end of the loop. Default is True.</p> <code>True</code> <code>fade</code> <code>float</code> <p>The time in seconds to fade out the loop when it is killed. Default is 0.0.</p> <code>0.0</code> <code>maintain_original_phase</code> <code>bool</code> <p>If True, the iterator will try to keep the time elapsed equal to (loop_number * dt). If False, the iterator will only look at the difference between the current loop and the previous loop. Default is False.</p> <code>False</code> Source code in <code>opensourceleg/utilities/softrealtimeloop.py</code> <pre><code>def __init__(\n    self, dt: float = 0.001, report: bool = True, fade: float = 0.0, maintain_original_phase: bool = False\n):\n    \"\"\"\n    Initializes the SoftRealtimeLoop.\n\n    Args:\n        dt (float): The time step of the loop in seconds. Default is 0.001 (1ms).\n        report (bool): If True, the loop will print a report at the end of the loop. Default is True.\n        fade (float): The time in seconds to fade out the loop when it is killed. Default is 0.0.\n        maintain_original_phase (bool): If True, the iterator will try to keep the time elapsed\n            equal to (loop_number * dt). If False, the iterator will only look at the difference\n            between the current loop and the previous loop. Default is False.\n    \"\"\"\n    self._fade_time: float = fade\n    self.dt: float = dt\n    self.report: bool = report\n    self._maintain_original_phase: bool = maintain_original_phase  # Can only be configured at init\n    self.loop_start_time: float = time.monotonic()\n    self.loop_deadline: float = self.loop_start_time + self.dt\n    self.iteration_start_time: float = self.loop_start_time\n    self.sum_err: float = 0.0\n    self.sum_var: float = 0.0\n    self.sleep_t_agg: float = 0.0\n    self.n: int = 0\n    self.killer = LoopKiller(fade_time=self._fade_time)\n</code></pre>"},{"location":"api/utilities/softrealtimeloop/#opensourceleg.utilities.softrealtimeloop.SoftRealtimeLoop.__iter__","title":"<code>__iter__()</code>","text":"<p>Resets the loop and returns the iterator object.</p> <p>Returns:</p> Name Type Description <code>SoftRealtimeLoop</code> <code>SoftRealtimeLoop</code> <p>The iterator object.</p> Source code in <code>opensourceleg/utilities/softrealtimeloop.py</code> <pre><code>def __iter__(self) -&gt; \"SoftRealtimeLoop\":\n    \"\"\"\n    Resets the loop and returns the iterator object.\n\n    Returns:\n        SoftRealtimeLoop: The iterator object.\n    \"\"\"\n    self.reset()\n    return self\n</code></pre>"},{"location":"api/utilities/softrealtimeloop/#opensourceleg.utilities.softrealtimeloop.SoftRealtimeLoop.__next__","title":"<code>__next__()</code>","text":"<p>Advances the loop to the next iteration.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The time since the loop started.</p> <p>Raises:</p> Type Description <code>StopIteration</code> <p>If the loop is stopped.</p> Source code in <code>opensourceleg/utilities/softrealtimeloop.py</code> <pre><code>def __next__(self) -&gt; float:\n    \"\"\"\n    Advances the loop to the next iteration.\n\n    Returns:\n        float: The time since the loop started.\n\n    Raises:\n        StopIteration: If the loop is stopped.\n    \"\"\"\n    if self._maintain_original_phase:\n        return self._next_original_phase()\n    else:\n        return self._next_consistent_dt()\n</code></pre>"},{"location":"api/utilities/softrealtimeloop/#opensourceleg.utilities.softrealtimeloop.SoftRealtimeLoop.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns a string representation of the SoftRealtimeLoop.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The string representation of the loop.</p> Source code in <code>opensourceleg/utilities/softrealtimeloop.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Returns a string representation of the SoftRealtimeLoop.\n\n    Returns:\n        str: The string representation of the loop.\n    \"\"\"\n    return \"SoftRealtimeLoop\"\n</code></pre>"},{"location":"api/utilities/softrealtimeloop/#opensourceleg.utilities.softrealtimeloop.SoftRealtimeLoop.print_report","title":"<code>print_report()</code>","text":"<p>Prints a performance report for the loop, including average error, standard deviation of error, and percentage of time spent sleeping.</p> Source code in <code>opensourceleg/utilities/softrealtimeloop.py</code> <pre><code>def print_report(self) -&gt; None:\n    \"\"\"\n    Prints a performance report for the loop, including average error,\n    standard deviation of error, and percentage of time spent sleeping.\n    \"\"\"\n    if self.report and self.n &gt; 0:\n        print(\"In %d cycles at %.2f Hz:\" % (self.n, 1.0 / self.dt))\n        print(\"\\tavg error: %.3f milliseconds\" % (1e3 * self.sum_err / self.n))\n        if self.n &gt; 1:\n            print(\n                \"\\tstddev error: %.3f milliseconds\"\n                % (1e3 * sqrt(max(0, (self.sum_var - self.sum_err**2 / self.n) / (self.n - 1))))\n            )\n        else:\n            print(\"\\tstddev error: N/A (need at least 2 samples)\")\n\n        total_time = self.time_since_start\n        print(f\"\\ttotal time: {total_time:.1f} s\")\n        if total_time &gt; 0:\n            print(\"\\tpercent of time sleeping: %.1f %%\" % (self.sleep_t_agg / total_time * 100.0))\n        else:\n            print(\"\\tpercent of time sleeping: N/A (total time is zero)\")\n</code></pre>"},{"location":"api/utilities/softrealtimeloop/#opensourceleg.utilities.softrealtimeloop.SoftRealtimeLoop.reset","title":"<code>reset()</code>","text":"<p>Resets the loop state and signal handlers to their initial state. This allows reusing the same loop instance instead of creating a new one.</p> Example <p>loop = SoftRealtimeLoop() loop.run(some_function) loop.reset()  # Reset for reuse loop.run(another_function)</p> Source code in <code>opensourceleg/utilities/softrealtimeloop.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"\n    Resets the loop state and signal handlers to their initial state.\n    This allows reusing the same loop instance instead of creating a new one.\n\n    Example:\n        &gt;&gt;&gt; loop = SoftRealtimeLoop()\n        &gt;&gt;&gt; loop.run(some_function)\n        &gt;&gt;&gt; loop.reset()  # Reset for reuse\n        &gt;&gt;&gt; loop.run(another_function)\n    \"\"\"\n    if self.n &gt; 0:\n        self.print_report()\n    self.loop_start_time = time.monotonic()\n    self.loop_deadline = self.loop_start_time + self.dt\n    self.iteration_start_time = self.loop_start_time\n    self.sum_err = 0.0\n    self.sum_var = 0.0\n    self.sleep_t_agg = 0.0\n    self.n = 0\n    self.killer = LoopKiller(fade_time=self._fade_time)\n</code></pre>"},{"location":"api/utilities/softrealtimeloop/#opensourceleg.utilities.softrealtimeloop.SoftRealtimeLoop.run","title":"<code>run(function_to_run)</code>","text":"<p>Runs the loop with the specified function.</p> <p>Parameters:</p> Name Type Description Default <code>function_to_run</code> <code>Callable[[], int]</code> <p>The function to execute in each loop iteration. The function should return 0 to stop the loop.</p> required Example <p>loop = SoftRealtimeLoop() loop.run(some_function)</p> Source code in <code>opensourceleg/utilities/softrealtimeloop.py</code> <pre><code>def run(self, function_to_run: Callable[[], int]) -&gt; None:\n    \"\"\"\n    Runs the loop with the specified function.\n\n    Args:\n        function_to_run (Callable[[], int]): The function to execute in each loop iteration.\n            The function should return 0 to stop the loop.\n\n    Example:\n        &gt;&gt;&gt; loop = SoftRealtimeLoop()\n        &gt;&gt;&gt; loop.run(some_function)\n    \"\"\"\n    for _t in self:\n        result = function_to_run()\n        if result == 0:\n            self.stop()\n</code></pre>"},{"location":"api/utilities/softrealtimeloop/#opensourceleg.utilities.softrealtimeloop.SoftRealtimeLoop.stop","title":"<code>stop()</code>","text":"<p>Stops the loop by setting the kill flag.</p> Example <p>loop = SoftRealtimeLoop() loop.stop()</p> Source code in <code>opensourceleg/utilities/softrealtimeloop.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"\n    Stops the loop by setting the kill flag.\n\n    Example:\n        &gt;&gt;&gt; loop = SoftRealtimeLoop()\n        &gt;&gt;&gt; loop.stop()\n    \"\"\"\n    self.killer.kill_now = True\n</code></pre>"},{"location":"examples/basic_motion/","title":"Basic Motion Example","text":""},{"location":"examples/basic_motion/#overview","title":"Overview","text":"<p>This example demonstrates how to create basic sinusoidal motions for the knee and ankle joints of the OSL using <code>DephyActuator</code>s in position control mode. The reference positions are updated in real-time using an instance of <code>SoftRealtimeLoop</code>. The loop runs continuously until interrupted with <code>Ctrl+C</code>.</p> <p>Note: This script is not intended for walking or load-bearing use. Ensure the OSL is in a safe configuration, such as being securely fixed to a benchtop, allowing the joints to move freely.</p>"},{"location":"examples/basic_motion/#full-code-for-this-example","title":"Full Code for This Example","text":"<pre><code>\"\"\"\nA basic motion script that moves the osl joints through their range of motion.\nThis script can be helpful when getting started to make sure the OSL is functional.\n\nKevin Best\nNeurobionics Lab\nRobotics Department\nUniversity of Michigan\nOctober 26, 2023\n\"\"\"\n\nimport numpy as np\n\nfrom opensourceleg.actuators.base import CONTROL_MODES\nfrom opensourceleg.actuators.dephy import DephyActuator\nfrom opensourceleg.utilities import SoftRealtimeLoop, units\n\nFREQUENCY = 200\n\nknee = DephyActuator(\n    tag=\"knee\",\n    firmware_version=\"7.2.0\",\n    port=\"/dev/ttyACM0\",\n    gear_ratio=9 * 83 / 18,\n    frequency=FREQUENCY,\n)\n\nankle = DephyActuator(\n    tag=\"ankle\",\n    firmware_version=\"7.2.0\",\n    port=\"/dev/ttyACM1\",\n    gear_ratio=9 * 83 / 18,\n    frequency=FREQUENCY,\n)\n\nacutators = [knee, ankle]\n\nclock = SoftRealtimeLoop(dt=1 / FREQUENCY)\n\n\ndef make_periodic_trajectory(period, minimum, maximum):\n    amplitude = (maximum - minimum) / 2\n    mean = amplitude + minimum\n    return lambda t: amplitude * np.cos(t * 2 * np.pi / period) + mean\n\n\nankle_traj = make_periodic_trajectory(10, -20, 20)\nknee_traj = make_periodic_trajectory(10, 10, 90)\n\nwith knee, ankle:\n    for actuator in acutators:\n        actuator.home()\n\n    input(\"Homing complete: Press enter to continue\")\n\n    knee.set_control_mode(CONTROL_MODES.POSITION)\n    ankle.set_control_mode(CONTROL_MODES.POSITION)\n    knee.set_position_gains(kp=5)\n    ankle.set_position_gains(kp=5)\n\n    for t in clock:\n        knee.update()\n        ankle.update()\n\n        knee_setpoint = units.convert_to_default(knee_traj(t), units.Position.deg)\n        ankle_setpoint = units.convert_to_default(ankle_traj(t), units.Position.deg)\n\n        knee.set_output_position(knee_setpoint)\n        ankle.set_output_position(ankle_setpoint)\n\n        print(\n            f\"Ankle Desired {ankle_setpoint:+.2f} rad, Ankle Actual {ankle.output_position:+.2f} rad, \\\n                Knee Desired {knee_setpoint:+.2f} rad, Ankle Desired {knee.output_position:+.2f} rad\",\n            end=\"\\r\",\n        )\n\nprint(\"\\n\")\n</code></pre>"},{"location":"examples/fsm_walking_ankle_controller/","title":"FSM Walking Ankle Controller","text":""},{"location":"examples/fsm_walking_ankle_controller/#overview","title":"Overview","text":"<p>This example demonstrates how to use a finite state machine (FSM) to control the OSL ankle joint with impedance control. The FSM uses load cell feedback and the motor encoder (or optionally the joint encoder) to transition between states, applying different impedance parameters for each phase of the gait cycle. This script is intended for testing and development with the OSL hardware.</p> <p>The FSM implements four distinct gait phases:</p> <ol> <li>Early Stance: Initial foot contact with moderate stiffness for shock absorption</li> <li>Late Stance: High stiffness for push-off power generation during heel rise</li> <li>Early Swing: Low stiffness allowing rapid dorsiflexion for ground clearance</li> <li>Late Swing: Maintains dorsiflexion position preparing for next heel strike</li> </ol> <p>The figure below shows the basic execution of the controller:</p> <p></p> <p>The implementation is entirely in Python and uses the <code>StateMachine</code> class from the control subpackage of this library.</p>"},{"location":"examples/fsm_walking_ankle_controller/#python-implementation","title":"Python Implementation","text":""},{"location":"examples/fsm_walking_ankle_controller/#setup-and-configuration","title":"Setup and Configuration","text":"<p>First, perform the necessary imports and define the hardware and control parameters:</p> <pre><code>\"\"\"\nA finite state machine to control the OSL ankle with impedance control.\nThis script can be helpful to test the OSL ankle using the load cell.\nThe fsm runs with the motor encoder, but the joint encoder can be also used.\n\nMatteo Crotti\nSoft Robotics for Human Cooperation and Rehabilitation Lab/Neurobionics Lab\nIstituto Italiano di Tecnologia/University of Michigan\nJune 6, 2025\n\"\"\"\n\nimport numpy as np\n\nfrom opensourceleg.actuators.base import CONTROL_MODES\nfrom opensourceleg.actuators.dephy import DephyActuator\nfrom opensourceleg.control.fsm import State, StateMachine\nfrom opensourceleg.logging.logger import Logger\nfrom opensourceleg.robots.osl import OpenSourceLeg\nfrom opensourceleg.sensors.loadcell import NBLoadcellDAQ\nfrom opensourceleg.utilities import SoftRealtimeLoop\n\nGEAR_RATIO = 9 * (83 / 18)\nFREQUENCY = 200\n\n\nLOADCELL_CALIBRATION_MATRIX_M3554E = np.array([\n    (-943.401, 4.143, 8.825, -16.57, 952.216, 10.892),\n    (539.853, 14.985, -1111.656, -0.812, 546.9, -18.949),\n    (13.155, 533.082, -4.582, 534.843, 10.827, 536.327),\n    (0.138, -10.419, 0.202, 0.14, 0.063, 10.518),\n    (-0.075, 6.213, -0.239, -12.094, 0.181, 6.156),\n    (-19.912, 0.082, -20.347, 0.022, -19.486, 0.013),\n])\n</code></pre> <p>Next, define the tunable FSM parameters for each state and the transition thresholds:</p> <pre><code>BODY_WEIGHT = 10 * 9.8\n\n# STATE 1: EARLY STANCE\nANKLE_K_ESTANCE = 19.874\nANKLE_B_ESTANCE = 0\nANKLE_THETA_ESTANCE = -2\nLOAD_LSTANCE: float = 1.0 * BODY_WEIGHT * 0.25\nANKLE_THETA_ESTANCE_TO_LSTANCE = np.deg2rad(8.0)\n\n# STATE 2: LATE STANCE\nANKLE_K_LSTANCE = 81  # 79.498\nANKLE_B_LSTANCE = 0.063\nANKLE_THETA_LSTANCE = -20\nLOAD_ESWING: float = 1.0 * BODY_WEIGHT * 0.15\n\n# STATE 3: EARLY SWING\nANKLE_K_ESWING = 7.949\nANKLE_B_ESWING = 0.0\nANKLE_THETA_ESWING = 25\nANKLE_DTHETA_ESWING_TO_LSWING = 3\nANKLE_THETA_ESWING_TO_LSWING = np.deg2rad(15.0)\n\n# STATE 4: LATE SWING\nANKLE_K_LSWING = 7.949\nANKLE_B_LSWING = 0.06  # 0.0\nANKLE_THETA_LSWING = 15\nLOAD_ESTANCE: float = 1.0 * BODY_WEIGHT * 0.4\nANKLE_THETA_LSWING_TO_ESTANCE = np.deg2rad(16.0)\n</code></pre> <p>Note: These parameters were roughly tuned for a moderately paced walking gait. You may want to tune them to better suit your intended use case.</p>"},{"location":"examples/fsm_walking_ankle_controller/#fsm-definition","title":"FSM Definition","text":"<p>The FSM consists of four states representing the phases of the gait cycle, each with specific impedance parameters. We first define the transition criteria functions that determine when to switch between states based on sensor feedback:</p>"},{"location":"examples/fsm_walking_ankle_controller/#transition-functions","title":"Transition Functions","text":"<p>The transition criteria are implemented as functions that take the OSL object and return a boolean indicating whether the transition should occur:</p> <ul> <li>Early Stance \u2192 Late Stance: Triggered when load cell force exceeds threshold AND ankle position is dorsiflexed enough</li> <li>Late Stance \u2192 Early Swing: Triggered when load cell force drops below threshold (heel off)</li> <li>Early Swing \u2192 Late Swing: Triggered when ankle reaches target dorsiflexion AND velocity decreases</li> <li>Late Swing \u2192 Early Stance: Triggered when load cell force increases (heel strike) OR ankle plantarflexes sufficiently</li> </ul>"},{"location":"examples/fsm_walking_ankle_controller/#state-machine-creation","title":"State Machine Creation","text":"<p>Next, we create a function that returns an instance of the <code>StateMachine</code> class. Create the FSM by defining the states, their impedance parameters, and the transition criteria functions. Each transition is based on sensor feedback or joint state:</p> <pre><code># ---------------------------------------------------- #\ndef estance_to_lstance(osl: OpenSourceLeg) -&gt; bool:\n    \"\"\"\n    Transition from early stance to late stance when the loadcell\n    reads a force greater than a threshold and the ankle position\n    is greater than a threshold.\n    \"\"\"\n    if osl.loadcell is None:\n        raise ValueError(\"Loadcell is not connected\")\n    if osl.ankle is None:\n        raise ValueError(\"Ankle is not connected\")\n    return bool(-(osl.loadcell.fz) &gt; LOAD_LSTANCE and osl.ankle.output_position &gt; ANKLE_THETA_ESTANCE_TO_LSTANCE)\n\n\ndef lstance_to_eswing(osl: OpenSourceLeg) -&gt; bool:\n    \"\"\"\n    Transition from late stance to early swing when the loadcell\n    reads a force less than a threshold.\n    \"\"\"\n    if osl.loadcell is None:\n        raise ValueError(\"Loadcell is not connected\")\n    return bool(-(osl.loadcell.fz) &lt; LOAD_ESWING)\n\n\ndef eswing_to_lswing(osl: OpenSourceLeg) -&gt; bool:\n    \"\"\"\n    Transition from early swing to late swing when the ankle angle\n    is greater than a threshold and the ankle velocity is less than\n    a threshold.\n    \"\"\"\n    if osl.ankle is None:\n        raise ValueError(\"Ankle is not connected\")\n\n    return bool(\n        osl.ankle.output_position &gt; ANKLE_THETA_ESWING_TO_LSWING\n        and osl.ankle.output_velocity &lt; ANKLE_DTHETA_ESWING_TO_LSWING\n    )\n\n\ndef lswing_to_estance(osl: OpenSourceLeg) -&gt; bool:\n    \"\"\"\n    Transition from late swing to early stance when the loadcell\n    reads a force greater than a threshold or the ankle angle is\n    less than a threshold.\n    \"\"\"\n    if osl.loadcell is None:\n        raise ValueError(\"Loadcell is not connected\")\n    if osl.ankle is None:\n        raise ValueError(\"Ankle is not connected\")\n    return bool(-osl.loadcell.fz &gt; LOAD_ESTANCE or osl.ankle.output_position &lt; ANKLE_THETA_LSWING_TO_ESTANCE)\n\n\ndef create_simple_walking_fsm(osl: OpenSourceLeg) -&gt; StateMachine:\n    e_stance = State(\n        name=\"e_stance\",\n        ankle_theta=ANKLE_THETA_ESTANCE,\n        ankle_stiffness=ANKLE_K_ESTANCE,\n        ankle_damping=ANKLE_B_ESTANCE,\n    )\n\n    l_stance = State(\n        name=\"l_stance\",\n        ankle_theta=ANKLE_THETA_LSTANCE,\n        ankle_stiffness=ANKLE_K_LSTANCE,\n        ankle_damping=ANKLE_B_LSTANCE,\n    )\n\n    e_swing = State(\n        name=\"e_swing\",\n        ankle_theta=ANKLE_THETA_ESWING,\n        ankle_stiffness=ANKLE_K_ESWING,\n        ankle_damping=ANKLE_B_ESWING,\n    )\n\n    l_swing = State(\n        name=\"l_swing\",\n        ankle_theta=ANKLE_THETA_LSWING,\n        ankle_stiffness=ANKLE_K_LSWING,\n        ankle_damping=ANKLE_B_LSWING,\n    )\n\n    fsm = StateMachine(\n        states=[\n            e_stance,\n            l_stance,\n            e_swing,\n            l_swing,\n        ],\n        initial_state_name=\"e_stance\",\n    )\n\n    fsm.add_transition(\n        source=e_stance,\n        destination=l_stance,\n        event_name=\"foot_flat\",\n        criteria=estance_to_lstance,\n    )\n    fsm.add_transition(\n        source=l_stance,\n        destination=e_swing,\n        event_name=\"heel_off\",\n        criteria=lstance_to_eswing,\n    )\n    fsm.add_transition(\n        source=e_swing,\n        destination=l_swing,\n        event_name=\"toe_off\",\n        criteria=eswing_to_lswing,\n    )\n    fsm.add_transition(\n        source=l_swing,\n        destination=e_stance,\n        event_name=\"heel_strike\",\n        criteria=lswing_to_estance,\n    )\n    return fsm\n</code></pre> <p>Note: If instantiating the OSL hardware and sensors is unfamiliar, check out the the tutorials pages.</p>"},{"location":"examples/fsm_walking_ankle_controller/#hardware-initialization","title":"Hardware Initialization","text":"<p>Initialize the required hardware components including the Dephy actuator, load cell sensor, data logger, and real-time control loop. The system uses a 200Hz control frequency for responsive control:</p> <pre><code>if __name__ == \"__main__\":\n    actuators = {\n        \"ankle\": DephyActuator(\n            tag=\"ankle\",\n            port=\"/dev/ttyACM0\",\n            gear_ratio=GEAR_RATIO,\n            frequency=FREQUENCY,\n            debug_level=0,\n            dephy_log=False,\n        ),\n    }\n\n    sensors = {\n        \"loadcell\": NBLoadcellDAQ(\n            LOADCELL_CALIBRATION_MATRIX_M3554E,\n            tag=\"loadcell\",\n            excitation_voltage=5.0,\n            amp_gain=[34] * 3 + [151] * 3,\n            spi_bus=1,\n        ),\n    }\n\n    clock = SoftRealtimeLoop(dt=1 / FREQUENCY)\n    fsm_logger = Logger(\n        log_path=\"./logs\",\n        file_name=\"fsm.log\",\n    )\n\n    osl = OpenSourceLeg(\n        tag=\"osl\",\n        actuators=actuators,\n        sensors=sensors,\n    )\n\n    osl_fsm = create_simple_walking_fsm(osl)\n</code></pre>"},{"location":"examples/fsm_walking_ankle_controller/#main-loop","title":"Main Loop","text":"<p>The main control loop homes the OSL, sets the ankle to impedance mode, and runs the control algorithm. In each iteration, the system updates hardware sensors, evaluates FSM transitions, applies impedance control, and logs relevant data:</p>"},{"location":"examples/fsm_walking_ankle_controller/#full-code","title":"Full Code","text":"<pre><code>\"\"\"\nA finite state machine to control the OSL ankle with impedance control.\nThis script can be helpful to test the OSL ankle using the load cell.\nThe fsm runs with the motor encoder, but the joint encoder can be also used.\n\nMatteo Crotti\nSoft Robotics for Human Cooperation and Rehabilitation Lab/Neurobionics Lab\nIstituto Italiano di Tecnologia/University of Michigan\nJune 6, 2025\n\"\"\"\n\nimport numpy as np\n\nfrom opensourceleg.actuators.base import CONTROL_MODES\nfrom opensourceleg.actuators.dephy import DephyActuator\nfrom opensourceleg.control.fsm import State, StateMachine\nfrom opensourceleg.logging.logger import Logger\nfrom opensourceleg.robots.osl import OpenSourceLeg\nfrom opensourceleg.sensors.loadcell import NBLoadcellDAQ\nfrom opensourceleg.utilities import SoftRealtimeLoop\n\nGEAR_RATIO = 9 * (83 / 18)\nFREQUENCY = 200\n\n\nLOADCELL_CALIBRATION_MATRIX_M3554E = np.array([\n    (-943.401, 4.143, 8.825, -16.57, 952.216, 10.892),\n    (539.853, 14.985, -1111.656, -0.812, 546.9, -18.949),\n    (13.155, 533.082, -4.582, 534.843, 10.827, 536.327),\n    (0.138, -10.419, 0.202, 0.14, 0.063, 10.518),\n    (-0.075, 6.213, -0.239, -12.094, 0.181, 6.156),\n    (-19.912, 0.082, -20.347, 0.022, -19.486, 0.013),\n])\n\n# ------------- TUNABLE FSM PARAMETERS ---------------- #\nBODY_WEIGHT = 10 * 9.8\n\n# STATE 1: EARLY STANCE\nANKLE_K_ESTANCE = 19.874\nANKLE_B_ESTANCE = 0\nANKLE_THETA_ESTANCE = -2\nLOAD_LSTANCE: float = 1.0 * BODY_WEIGHT * 0.25\nANKLE_THETA_ESTANCE_TO_LSTANCE = np.deg2rad(8.0)\n\n# STATE 2: LATE STANCE\nANKLE_K_LSTANCE = 81  # 79.498\nANKLE_B_LSTANCE = 0.063\nANKLE_THETA_LSTANCE = -20\nLOAD_ESWING: float = 1.0 * BODY_WEIGHT * 0.15\n\n# STATE 3: EARLY SWING\nANKLE_K_ESWING = 7.949\nANKLE_B_ESWING = 0.0\nANKLE_THETA_ESWING = 25\nANKLE_DTHETA_ESWING_TO_LSWING = 3\nANKLE_THETA_ESWING_TO_LSWING = np.deg2rad(15.0)\n\n# STATE 4: LATE SWING\nANKLE_K_LSWING = 7.949\nANKLE_B_LSWING = 0.06  # 0.0\nANKLE_THETA_LSWING = 15\nLOAD_ESTANCE: float = 1.0 * BODY_WEIGHT * 0.4\nANKLE_THETA_LSWING_TO_ESTANCE = np.deg2rad(16.0)\n\n\n# ---------------------------------------------------- #\ndef estance_to_lstance(osl: OpenSourceLeg) -&gt; bool:\n    \"\"\"\n    Transition from early stance to late stance when the loadcell\n    reads a force greater than a threshold and the ankle position\n    is greater than a threshold.\n    \"\"\"\n    if osl.loadcell is None:\n        raise ValueError(\"Loadcell is not connected\")\n    if osl.ankle is None:\n        raise ValueError(\"Ankle is not connected\")\n    return bool(-(osl.loadcell.fz) &gt; LOAD_LSTANCE and osl.ankle.output_position &gt; ANKLE_THETA_ESTANCE_TO_LSTANCE)\n\n\ndef lstance_to_eswing(osl: OpenSourceLeg) -&gt; bool:\n    \"\"\"\n    Transition from late stance to early swing when the loadcell\n    reads a force less than a threshold.\n    \"\"\"\n    if osl.loadcell is None:\n        raise ValueError(\"Loadcell is not connected\")\n    return bool(-(osl.loadcell.fz) &lt; LOAD_ESWING)\n\n\ndef eswing_to_lswing(osl: OpenSourceLeg) -&gt; bool:\n    \"\"\"\n    Transition from early swing to late swing when the ankle angle\n    is greater than a threshold and the ankle velocity is less than\n    a threshold.\n    \"\"\"\n    if osl.ankle is None:\n        raise ValueError(\"Ankle is not connected\")\n\n    return bool(\n        osl.ankle.output_position &gt; ANKLE_THETA_ESWING_TO_LSWING\n        and osl.ankle.output_velocity &lt; ANKLE_DTHETA_ESWING_TO_LSWING\n    )\n\n\ndef lswing_to_estance(osl: OpenSourceLeg) -&gt; bool:\n    \"\"\"\n    Transition from late swing to early stance when the loadcell\n    reads a force greater than a threshold or the ankle angle is\n    less than a threshold.\n    \"\"\"\n    if osl.loadcell is None:\n        raise ValueError(\"Loadcell is not connected\")\n    if osl.ankle is None:\n        raise ValueError(\"Ankle is not connected\")\n    return bool(-osl.loadcell.fz &gt; LOAD_ESTANCE or osl.ankle.output_position &lt; ANKLE_THETA_LSWING_TO_ESTANCE)\n\n\ndef create_simple_walking_fsm(osl: OpenSourceLeg) -&gt; StateMachine:\n    e_stance = State(\n        name=\"e_stance\",\n        ankle_theta=ANKLE_THETA_ESTANCE,\n        ankle_stiffness=ANKLE_K_ESTANCE,\n        ankle_damping=ANKLE_B_ESTANCE,\n    )\n\n    l_stance = State(\n        name=\"l_stance\",\n        ankle_theta=ANKLE_THETA_LSTANCE,\n        ankle_stiffness=ANKLE_K_LSTANCE,\n        ankle_damping=ANKLE_B_LSTANCE,\n    )\n\n    e_swing = State(\n        name=\"e_swing\",\n        ankle_theta=ANKLE_THETA_ESWING,\n        ankle_stiffness=ANKLE_K_ESWING,\n        ankle_damping=ANKLE_B_ESWING,\n    )\n\n    l_swing = State(\n        name=\"l_swing\",\n        ankle_theta=ANKLE_THETA_LSWING,\n        ankle_stiffness=ANKLE_K_LSWING,\n        ankle_damping=ANKLE_B_LSWING,\n    )\n\n    fsm = StateMachine(\n        states=[\n            e_stance,\n            l_stance,\n            e_swing,\n            l_swing,\n        ],\n        initial_state_name=\"e_stance\",\n    )\n\n    fsm.add_transition(\n        source=e_stance,\n        destination=l_stance,\n        event_name=\"foot_flat\",\n        criteria=estance_to_lstance,\n    )\n    fsm.add_transition(\n        source=l_stance,\n        destination=e_swing,\n        event_name=\"heel_off\",\n        criteria=lstance_to_eswing,\n    )\n    fsm.add_transition(\n        source=e_swing,\n        destination=l_swing,\n        event_name=\"toe_off\",\n        criteria=eswing_to_lswing,\n    )\n    fsm.add_transition(\n        source=l_swing,\n        destination=e_stance,\n        event_name=\"heel_strike\",\n        criteria=lswing_to_estance,\n    )\n    return fsm\n\n\nif __name__ == \"__main__\":\n    actuators = {\n        \"ankle\": DephyActuator(\n            tag=\"ankle\",\n            port=\"/dev/ttyACM0\",\n            gear_ratio=GEAR_RATIO,\n            frequency=FREQUENCY,\n            debug_level=0,\n            dephy_log=False,\n        ),\n    }\n\n    sensors = {\n        \"loadcell\": NBLoadcellDAQ(\n            LOADCELL_CALIBRATION_MATRIX_M3554E,\n            tag=\"loadcell\",\n            excitation_voltage=5.0,\n            amp_gain=[34] * 3 + [151] * 3,\n            spi_bus=1,\n        ),\n    }\n\n    clock = SoftRealtimeLoop(dt=1 / FREQUENCY)\n    fsm_logger = Logger(\n        log_path=\"./logs\",\n        file_name=\"fsm.log\",\n    )\n\n    osl = OpenSourceLeg(\n        tag=\"osl\",\n        actuators=actuators,\n        sensors=sensors,\n    )\n\n    osl_fsm = create_simple_walking_fsm(osl)\n\n    with fsm_logger, osl, osl_fsm:\n        osl.update()\n        osl.home()\n\n        input(\"Press Enter to start walking...\")\n\n        # ankle\n        osl.ankle.set_control_mode(mode=CONTROL_MODES.IMPEDANCE)\n        osl.ankle.set_impedance_gains()\n\n        for t in clock:\n            osl.update()\n            osl_fsm.update(osl=osl)\n            osl.ankle.set_output_impedance(\n                k=osl_fsm.current_state.ankle_stiffness,\n                b=osl_fsm.current_state.ankle_damping,\n            )\n\n            osl.ankle.set_output_position(np.deg2rad(osl_fsm.current_state.ankle_theta))\n\n            fsm_logger.info(\n                f\"T: {t:.3f}s, \"\n                f\"Current state: {osl_fsm.current_state.name}; \"\n                f\"Loadcell Fz: {osl.loadcell.fz:.3f} N; \"\n                f\"Ankle theta: {np.rad2deg(osl.ankle.output_position):.3f} deg; \"\n                f\"Ankle winding temperature: {osl.ankle.winding_temperature:.3f} c; \"\n            )\n</code></pre>"},{"location":"examples/fsm_walking_ankle_controller/#notes","title":"Notes","text":""},{"location":"examples/fsm_walking_ankle_controller/#hardware-requirements","title":"Hardware Requirements","text":"<ul> <li>This example is designed for use with the OSL hardware and requires the appropriate sensors and actuators to be connected.</li> <li>A 6-axis load cell (NBLoadcellDAQ) is required for ground reaction force measurements.</li> <li>The Dephy actuator must be properly configured and connected via USB.</li> </ul>"},{"location":"examples/fsm_walking_ankle_controller/#parameter-tuning","title":"Parameter Tuning","text":"<ul> <li>The FSM transitions and impedance parameters may need to be tuned for your specific application or hardware setup.</li> <li>Body weight scaling affects the load thresholds - adjust <code>BODY_WEIGHT</code> parameter accordingly</li> </ul>"},{"location":"examples/fsm_walking_ankle_controller/#additional-resources","title":"Additional Resources","text":"<ul> <li>For more information on the OSL library and hardware setup, refer to the tutorials.</li> </ul>"},{"location":"examples/fsm_walking_controller/","title":"Finite State Machine Controller","text":""},{"location":"examples/fsm_walking_controller/#overview","title":"Overview","text":"<p>The library ships with three example implementations of the same finite state machine (FSM) walking controller. The figure below shows the basic execution of the controller:</p> <p></p> <p>The first implementation is entirely in Python and uses the <code>StateMachine</code> class from the control subpackage of this library. If you plan to write your controllers exclusively in Python, this example is a good starting point.</p> <p>The library also supports using compiled <code>C</code> and <code>C++</code> library functions via the <code>CompiledController</code> class. You can see a basic example of this module on the tutorials page, which may be helpful to review before starting with this example. We've duplicated the FSM behavior in both <code>C++</code> and <code>MATLAB</code>. The source code for these control implementations is available in this repository. Refer to the documentation in that repository for instructions on compiling both the <code>C++</code> and the <code>MATLAB</code> source code.</p>"},{"location":"examples/fsm_walking_controller/#python-implementation","title":"Python Implementation","text":""},{"location":"examples/fsm_walking_controller/#setup-and-configuration","title":"Setup and Configuration","text":"<p>First, we'll perform some standard imports:</p> <pre><code>import numpy as np\n\nfrom opensourceleg.actuators.base import CONTROL_MODES\nfrom opensourceleg.actuators.dephy import DephyActuator\nfrom opensourceleg.control.fsm import State, StateMachine\nfrom opensourceleg.logging.logger import Logger\nfrom opensourceleg.robots.osl import OpenSourceLeg\nfrom opensourceleg.sensors.encoder import AS5048B\nfrom opensourceleg.sensors.loadcell import NBLoadcellDAQ\nfrom opensourceleg.utilities import SoftRealtimeLoop\n\nGEAR_RATIO = 9 * (83 / 18)\nFREQUENCY = 200\nLOADCELL_CALIBRATION_MATRIX = np.array([\n    (-38.72600, -1817.74700, 9.84900, 43.37400, -44.54000, 1824.67000),\n    (-8.61600, 1041.14900, 18.86100, -2098.82200, 31.79400, 1058.6230),\n    (-1047.16800, 8.63900, -1047.28200, -20.70000, -1073.08800, -8.92300),\n    (20.57600, -0.04000, -0.24600, 0.55400, -21.40800, -0.47600),\n    (-12.13400, -1.10800, 24.36100, 0.02300, -12.14100, 0.79200),\n    (-0.65100, -28.28700, 0.02200, -25.23000, 0.47300, -27.3070),\n])\n</code></pre> <p>Next, we'll define all the tunable FSM parameters. These include the impedance parameters for each state as well as the transitions between states:</p> <pre><code># ------------- TUNABLE FSM PARAMETERS ---------------- #\nBODY_WEIGHT = 10 * 9.8  # 30 * 9.8\n\n# STATE 1: EARLY STANCE\nKNEE_K_ESTANCE = 99.372\nKNEE_B_ESTANCE = 3.180\nKNEE_THETA_ESTANCE = 5\nANKLE_K_ESTANCE = 19.874\nANKLE_B_ESTANCE = 0\nANKLE_THETA_ESTANCE = -2\nLOAD_LSTANCE: float = 1.0 * BODY_WEIGHT * 0.25\nANKLE_THETA_ESTANCE_TO_LSTANCE = np.deg2rad(6.0)\n\n# STATE 2: LATE STANCE\nKNEE_K_LSTANCE = 99.372\nKNEE_B_LSTANCE = 1.272\nKNEE_THETA_LSTANCE = 8\nANKLE_K_LSTANCE = 79.498\nANKLE_B_LSTANCE = 0.063\nANKLE_THETA_LSTANCE = -20\nLOAD_ESWING: float = 1.0 * BODY_WEIGHT * 0.15\n\n# STATE 3: EARLY SWING\nKNEE_K_ESWING = 39.749\nKNEE_B_ESWING = 0.063\nKNEE_THETA_ESWING = 60\nANKLE_K_ESWING = 7.949\nANKLE_B_ESWING = 0.0\nANKLE_THETA_ESWING = 25\nKNEE_THETA_ESWING_TO_LSWING = np.deg2rad(50)\nKNEE_DTHETA_ESWING_TO_LSWING = 3\n\n# STATE 4: LATE SWING\nKNEE_K_LSWING = 15.899\nKNEE_B_LSWING = 3.816\nKNEE_THETA_LSWING = 5\nANKLE_K_LSWING = 7.949\nANKLE_B_LSWING = 0.0\nANKLE_THETA_LSWING = 15\nLOAD_ESTANCE: float = 1.0 * BODY_WEIGHT * 0.4\nKNEE_THETA_LSWING_TO_ESTANCE = np.deg2rad(30)\n\n# ---------------------------------------------------- #\n</code></pre> <p>Note: These parameters were roughly tuned for a moderately paced walking gait. You may want to tune them to better suit your intended use case.</p> <p>Next, we create a function that returns an instance of the <code>StateMachine</code> class. We start by making <code>State</code> objects for each of our four states and the include the impedance parameters in each. We also define transition criteria functions that determine when to move between states. We add the states and transition functions to an instance of the <code>StateMachine</code> class, specifiying that the initial state is <code>e_stance</code>.</p> <pre><code>def create_simple_walking_fsm(osl: OpenSourceLeg) -&gt; StateMachine:\n    e_stance = State(\n        name=\"e_stance\",\n        knee_theta=KNEE_THETA_ESTANCE,\n        knee_stiffness=KNEE_K_ESTANCE,\n        knee_damping=KNEE_B_ESTANCE,\n        ankle_theta=ANKLE_THETA_ESTANCE,\n        ankle_stiffness=ANKLE_K_ESTANCE,\n        ankle_damping=ANKLE_B_ESTANCE,\n    )\n\n    l_stance = State(\n        name=\"l_stance\",\n        knee_theta=KNEE_THETA_LSTANCE,\n        knee_stiffness=KNEE_K_LSTANCE,\n        knee_damping=KNEE_B_LSTANCE,\n        ankle_theta=ANKLE_THETA_LSTANCE,\n        ankle_stiffness=ANKLE_K_LSTANCE,\n        ankle_damping=ANKLE_B_LSTANCE,\n    )\n\n    e_swing = State(\n        name=\"e_swing\",\n        knee_theta=KNEE_THETA_ESWING,\n        knee_stiffness=KNEE_K_ESWING,\n        knee_damping=KNEE_B_ESWING,\n        ankle_theta=ANKLE_THETA_ESWING,\n        ankle_stiffness=ANKLE_K_ESWING,\n        ankle_damping=ANKLE_B_ESWING,\n    )\n\n    l_swing = State(\n        name=\"l_swing\",\n        knee_theta=KNEE_THETA_LSWING,\n        knee_stiffness=KNEE_K_LSWING,\n        knee_damping=KNEE_B_LSWING,\n        ankle_theta=ANKLE_THETA_LSWING,\n        ankle_stiffness=ANKLE_K_LSWING,\n        ankle_damping=ANKLE_B_LSWING,\n    )\n\n    def estance_to_lstance(osl: OpenSourceLeg) -&gt; bool:\n        \"\"\"\n        Transition from early stance to late stance when the loadcell\n        reads a force greater than a threshold.\n        \"\"\"\n        if osl.loadcell is None:\n            raise ValueError(\"Loadcell is not connected\")\n        return bool(osl.loadcell.fz &gt; LOAD_LSTANCE and osl.ankle.output_position &gt; ANKLE_THETA_ESTANCE_TO_LSTANCE)\n\n    def lstance_to_eswing(osl: OpenSourceLeg) -&gt; bool:\n        \"\"\"\n        Transition from late stance to early swing when the loadcell\n        reads a force less than a threshold.\n        \"\"\"\n        if osl.loadcell is None:\n            raise ValueError(\"Loadcell is not connected\")\n        return bool(osl.loadcell.fz &lt; LOAD_ESWING)\n\n    def eswing_to_lswing(osl: OpenSourceLeg) -&gt; bool:\n        \"\"\"\n        Transition from early swing to late swing when the knee angle\n        is greater than a threshold and the knee velocity is less than\n        a threshold.\n        \"\"\"\n        if osl.knee is None:\n            raise ValueError(\"Knee is not connected\")\n        return bool(\n            osl.knee.output_position &gt; KNEE_THETA_ESWING_TO_LSWING\n            and osl.knee.output_velocity &lt; KNEE_DTHETA_ESWING_TO_LSWING\n        )\n\n    def lswing_to_estance(osl: OpenSourceLeg) -&gt; bool:\n        \"\"\"\n        Transition from late swing to early stance when the loadcell\n        reads a force greater than a threshold or the knee angle is\n        less than a threshold.\n        \"\"\"\n        if osl.knee is None:\n            raise ValueError(\"Knee is not connected\")\n        if osl.loadcell is None:\n            raise ValueError(\"Loadcell is not connected\")\n        return bool(osl.loadcell.fz &gt; LOAD_ESTANCE or osl.knee.output_position &lt; KNEE_THETA_LSWING_TO_ESTANCE)\n\n    fsm = StateMachine(\n        states=[\n            e_stance,\n            l_stance,\n            e_swing,\n            l_swing,\n        ],\n        initial_state_name=\"e_stance\",\n    )\n\n    fsm.add_transition(\n        source=e_stance,\n        destination=l_stance,\n        event_name=\"foot_flat\",\n        criteria=estance_to_lstance,\n    )\n    fsm.add_transition(\n        source=l_stance,\n        destination=e_swing,\n        event_name=\"heel_off\",\n        criteria=lstance_to_eswing,\n    )\n    fsm.add_transition(\n        source=e_swing,\n        destination=l_swing,\n        event_name=\"toe_off\",\n        criteria=eswing_to_lswing,\n    )\n    fsm.add_transition(\n        source=l_swing,\n        destination=e_stance,\n        event_name=\"heel_strike\",\n        criteria=lswing_to_estance,\n    )\n    return fsm\n</code></pre> <p>Note: If instantiating the OSL hardware and sensors is unfamiliar, check out the the tutorials pages.</p> <p>Next, we initialize the standard actuators, sensors, logger, and loop classes for the OSL: <pre><code>if __name__ == \"__main__\":\n    actuators = {\n        \"knee\": DephyActuator(\n            tag=\"knee\",\n            port=\"/dev/ttyACM0\",\n            gear_ratio=GEAR_RATIO,\n            frequency=FREQUENCY,\n            debug_level=0,\n            dephy_log=False,\n        ),\n        \"ankle\": DephyActuator(\n            tag=\"ankle\",\n            port=\"/dev/ttyACM1\",\n            gear_ratio=GEAR_RATIO,\n            frequency=FREQUENCY,\n            debug_level=0,\n            dephy_log=False,\n        ),\n    }\n\n    sensors = {\n        # \"loadcell\": DephyLoadcellAmplifier(\n        #     calibration_matrix=LOADCELL_CALIBRATION_MATRIX,\n        # ),\n        \"loadcell\": NBLoadcellDAQ(\n            LOADCELL_CALIBRATION_MATRIX,\n            tag=\"loadcell\",\n            excitation_voltage=5.0,\n            amp_gain=[34] * 3 + [151] * 3,\n            spi_bus=1,\n        ),\n        \"joint_encoder_knee\": AS5048B(\n            tag=\"joint_encoder_knee\",\n            bus=\"/dev/i2c-2\",\n            A1_adr_pin=False,\n            A2_adr_pin=False,\n            zero_position=0,\n            enable_diagnostics=False,\n        ),\n        \"joint_encoder_ankle\": AS5048B(\n            tag=\"joint_encoder_ankle\",\n            bus=\"/dev/i2c-3\",\n            A1_adr_pin=False,\n            A2_adr_pin=False,\n            zero_position=0,\n            enable_diagnostics=False,\n        ),\n    }\n\n    clock = SoftRealtimeLoop(dt=1 / FREQUENCY)\n    fsm_logger = Logger(\n        log_path=\"./logs\",\n        file_name=\"fsm.log\",\n</code></pre></p> <p>We then call the FSM definition function we made above and initialize/home the hardware: <pre><code>    osl = OpenSourceLeg(\n        tag=\"osl\",\n        actuators=actuators,\n        sensors=sensors,\n    )\n\n    osl_fsm = create_simple_walking_fsm(osl)\n\n    # Zeroing the joint encoders\n    def knee_homing_complete():\n        osl.joint_encoder_knee.update()\n        osl.joint_encoder_knee.zero_position = osl.joint_encoder_knee.counts\n        print(\"Knee homing complete!\")\n</code></pre></p>"},{"location":"examples/fsm_walking_controller/#main-loop","title":"Main Loop","text":"<p>Now that everything is set up, we enter the main loop. During each iteration of the main loop, we call the update method for both the OSL and the FSM. We then write the current impedance parameters for each joint to the hardware. A print statement and logging are also included for debugging:</p> <pre><code>        osl.joint_encoder_ankle.update()\n        # The hard stop for ankle is at 30 deg from the zero position\n        osl.joint_encoder_ankle.zero_position = osl.joint_encoder_ankle.counts - osl.joint_encoder_ankle.deg_to_counts(\n            30\n        )\n        print(\"Ankle homing complete!\")\n\n    callbacks = {\"knee\": knee_homing_complete, \"ankle\": ankle_homing_complete}\n\n    with osl, osl_fsm:\n        osl.update()\n        osl.home(callbacks=callbacks)\n        input(\"Press Enter to start walking...\")\n\n        # knee\n        osl.knee.set_control_mode(mode=CONTROL_MODES.IMPEDANCE)\n        osl.knee.set_impedance_cc_pidf_gains()\n        osl.knee.set_output_impedance()\n\n        # ankle\n        osl.ankle.set_control_mode(mode=CONTROL_MODES.IMPEDANCE)\n        osl.ankle.set_impedance_cc_pidf_gains()\n        osl.ankle.set_output_impedance()\n\n        osl.loadcell.reset()\n</code></pre>"},{"location":"examples/fsm_walking_controller/#full-code-for-the-python-implementation","title":"Full Code for The Python Implementation","text":"<pre><code>import numpy as np\n\nfrom opensourceleg.actuators.base import CONTROL_MODES\nfrom opensourceleg.actuators.dephy import DephyActuator\nfrom opensourceleg.control.fsm import State, StateMachine\nfrom opensourceleg.logging.logger import Logger\nfrom opensourceleg.robots.osl import OpenSourceLeg\nfrom opensourceleg.sensors.encoder import AS5048B\nfrom opensourceleg.sensors.loadcell import NBLoadcellDAQ\nfrom opensourceleg.utilities import SoftRealtimeLoop\n\nGEAR_RATIO = 9 * (83 / 18)\nFREQUENCY = 200\nLOADCELL_CALIBRATION_MATRIX = np.array([\n    (-38.72600, -1817.74700, 9.84900, 43.37400, -44.54000, 1824.67000),\n    (-8.61600, 1041.14900, 18.86100, -2098.82200, 31.79400, 1058.6230),\n    (-1047.16800, 8.63900, -1047.28200, -20.70000, -1073.08800, -8.92300),\n    (20.57600, -0.04000, -0.24600, 0.55400, -21.40800, -0.47600),\n    (-12.13400, -1.10800, 24.36100, 0.02300, -12.14100, 0.79200),\n    (-0.65100, -28.28700, 0.02200, -25.23000, 0.47300, -27.3070),\n])\n\n# ------------- TUNABLE FSM PARAMETERS ---------------- #\nBODY_WEIGHT = 10 * 9.8  # 30 * 9.8\n\n# STATE 1: EARLY STANCE\nKNEE_K_ESTANCE = 99.372\nKNEE_B_ESTANCE = 3.180\nKNEE_THETA_ESTANCE = 5\nANKLE_K_ESTANCE = 19.874\nANKLE_B_ESTANCE = 0\nANKLE_THETA_ESTANCE = -2\nLOAD_LSTANCE: float = 1.0 * BODY_WEIGHT * 0.25\nANKLE_THETA_ESTANCE_TO_LSTANCE = np.deg2rad(6.0)\n\n# STATE 2: LATE STANCE\nKNEE_K_LSTANCE = 99.372\nKNEE_B_LSTANCE = 1.272\nKNEE_THETA_LSTANCE = 8\nANKLE_K_LSTANCE = 79.498\nANKLE_B_LSTANCE = 0.063\nANKLE_THETA_LSTANCE = -20\nLOAD_ESWING: float = 1.0 * BODY_WEIGHT * 0.15\n\n# STATE 3: EARLY SWING\nKNEE_K_ESWING = 39.749\nKNEE_B_ESWING = 0.063\nKNEE_THETA_ESWING = 60\nANKLE_K_ESWING = 7.949\nANKLE_B_ESWING = 0.0\nANKLE_THETA_ESWING = 25\nKNEE_THETA_ESWING_TO_LSWING = np.deg2rad(50)\nKNEE_DTHETA_ESWING_TO_LSWING = 3\n\n# STATE 4: LATE SWING\nKNEE_K_LSWING = 15.899\nKNEE_B_LSWING = 3.816\nKNEE_THETA_LSWING = 5\nANKLE_K_LSWING = 7.949\nANKLE_B_LSWING = 0.0\nANKLE_THETA_LSWING = 15\nLOAD_ESTANCE: float = 1.0 * BODY_WEIGHT * 0.4\nKNEE_THETA_LSWING_TO_ESTANCE = np.deg2rad(30)\n\n# ---------------------------------------------------- #\n\n\ndef create_simple_walking_fsm(osl: OpenSourceLeg) -&gt; StateMachine:\n    e_stance = State(\n        name=\"e_stance\",\n        knee_theta=KNEE_THETA_ESTANCE,\n        knee_stiffness=KNEE_K_ESTANCE,\n        knee_damping=KNEE_B_ESTANCE,\n        ankle_theta=ANKLE_THETA_ESTANCE,\n        ankle_stiffness=ANKLE_K_ESTANCE,\n        ankle_damping=ANKLE_B_ESTANCE,\n    )\n\n    l_stance = State(\n        name=\"l_stance\",\n        knee_theta=KNEE_THETA_LSTANCE,\n        knee_stiffness=KNEE_K_LSTANCE,\n        knee_damping=KNEE_B_LSTANCE,\n        ankle_theta=ANKLE_THETA_LSTANCE,\n        ankle_stiffness=ANKLE_K_LSTANCE,\n        ankle_damping=ANKLE_B_LSTANCE,\n    )\n\n    e_swing = State(\n        name=\"e_swing\",\n        knee_theta=KNEE_THETA_ESWING,\n        knee_stiffness=KNEE_K_ESWING,\n        knee_damping=KNEE_B_ESWING,\n        ankle_theta=ANKLE_THETA_ESWING,\n        ankle_stiffness=ANKLE_K_ESWING,\n        ankle_damping=ANKLE_B_ESWING,\n    )\n\n    l_swing = State(\n        name=\"l_swing\",\n        knee_theta=KNEE_THETA_LSWING,\n        knee_stiffness=KNEE_K_LSWING,\n        knee_damping=KNEE_B_LSWING,\n        ankle_theta=ANKLE_THETA_LSWING,\n        ankle_stiffness=ANKLE_K_LSWING,\n        ankle_damping=ANKLE_B_LSWING,\n    )\n\n    def estance_to_lstance(osl: OpenSourceLeg) -&gt; bool:\n        \"\"\"\n        Transition from early stance to late stance when the loadcell\n        reads a force greater than a threshold.\n        \"\"\"\n        if osl.loadcell is None:\n            raise ValueError(\"Loadcell is not connected\")\n        return bool(osl.loadcell.fz &gt; LOAD_LSTANCE and osl.ankle.output_position &gt; ANKLE_THETA_ESTANCE_TO_LSTANCE)\n\n    def lstance_to_eswing(osl: OpenSourceLeg) -&gt; bool:\n        \"\"\"\n        Transition from late stance to early swing when the loadcell\n        reads a force less than a threshold.\n        \"\"\"\n        if osl.loadcell is None:\n            raise ValueError(\"Loadcell is not connected\")\n        return bool(osl.loadcell.fz &lt; LOAD_ESWING)\n\n    def eswing_to_lswing(osl: OpenSourceLeg) -&gt; bool:\n        \"\"\"\n        Transition from early swing to late swing when the knee angle\n        is greater than a threshold and the knee velocity is less than\n        a threshold.\n        \"\"\"\n        if osl.knee is None:\n            raise ValueError(\"Knee is not connected\")\n        return bool(\n            osl.knee.output_position &gt; KNEE_THETA_ESWING_TO_LSWING\n            and osl.knee.output_velocity &lt; KNEE_DTHETA_ESWING_TO_LSWING\n        )\n\n    def lswing_to_estance(osl: OpenSourceLeg) -&gt; bool:\n        \"\"\"\n        Transition from late swing to early stance when the loadcell\n        reads a force greater than a threshold or the knee angle is\n        less than a threshold.\n        \"\"\"\n        if osl.knee is None:\n            raise ValueError(\"Knee is not connected\")\n        if osl.loadcell is None:\n            raise ValueError(\"Loadcell is not connected\")\n        return bool(osl.loadcell.fz &gt; LOAD_ESTANCE or osl.knee.output_position &lt; KNEE_THETA_LSWING_TO_ESTANCE)\n\n    fsm = StateMachine(\n        states=[\n            e_stance,\n            l_stance,\n            e_swing,\n            l_swing,\n        ],\n        initial_state_name=\"e_stance\",\n    )\n\n    fsm.add_transition(\n        source=e_stance,\n        destination=l_stance,\n        event_name=\"foot_flat\",\n        criteria=estance_to_lstance,\n    )\n    fsm.add_transition(\n        source=l_stance,\n        destination=e_swing,\n        event_name=\"heel_off\",\n        criteria=lstance_to_eswing,\n    )\n    fsm.add_transition(\n        source=e_swing,\n        destination=l_swing,\n        event_name=\"toe_off\",\n        criteria=eswing_to_lswing,\n    )\n    fsm.add_transition(\n        source=l_swing,\n        destination=e_stance,\n        event_name=\"heel_strike\",\n        criteria=lswing_to_estance,\n    )\n    return fsm\n\n\nif __name__ == \"__main__\":\n    actuators = {\n        \"knee\": DephyActuator(\n            tag=\"knee\",\n            port=\"/dev/ttyACM0\",\n            gear_ratio=GEAR_RATIO,\n            frequency=FREQUENCY,\n            debug_level=0,\n            dephy_log=False,\n        ),\n        \"ankle\": DephyActuator(\n            tag=\"ankle\",\n            port=\"/dev/ttyACM1\",\n            gear_ratio=GEAR_RATIO,\n            frequency=FREQUENCY,\n            debug_level=0,\n            dephy_log=False,\n        ),\n    }\n\n    sensors = {\n        # \"loadcell\": DephyLoadcellAmplifier(\n        #     calibration_matrix=LOADCELL_CALIBRATION_MATRIX,\n        # ),\n        \"loadcell\": NBLoadcellDAQ(\n            LOADCELL_CALIBRATION_MATRIX,\n            tag=\"loadcell\",\n            excitation_voltage=5.0,\n            amp_gain=[34] * 3 + [151] * 3,\n            spi_bus=1,\n        ),\n        \"joint_encoder_knee\": AS5048B(\n            tag=\"joint_encoder_knee\",\n            bus=\"/dev/i2c-2\",\n            A1_adr_pin=False,\n            A2_adr_pin=False,\n            zero_position=0,\n            enable_diagnostics=False,\n        ),\n        \"joint_encoder_ankle\": AS5048B(\n            tag=\"joint_encoder_ankle\",\n            bus=\"/dev/i2c-3\",\n            A1_adr_pin=False,\n            A2_adr_pin=False,\n            zero_position=0,\n            enable_diagnostics=False,\n        ),\n    }\n\n    clock = SoftRealtimeLoop(dt=1 / FREQUENCY)\n    fsm_logger = Logger(\n        log_path=\"./logs\",\n        file_name=\"fsm.log\",\n    )\n\n    osl = OpenSourceLeg(\n        tag=\"osl\",\n        actuators=actuators,\n        sensors=sensors,\n    )\n\n    osl_fsm = create_simple_walking_fsm(osl)\n\n    # Zeroing the joint encoders\n    def knee_homing_complete():\n        osl.joint_encoder_knee.update()\n        osl.joint_encoder_knee.zero_position = osl.joint_encoder_knee.counts\n        print(\"Knee homing complete!\")\n\n    def ankle_homing_complete():\n        osl.joint_encoder_ankle.update()\n        # The hard stop for ankle is at 30 deg from the zero position\n        osl.joint_encoder_ankle.zero_position = osl.joint_encoder_ankle.counts - osl.joint_encoder_ankle.deg_to_counts(\n            30\n        )\n        print(\"Ankle homing complete!\")\n\n    callbacks = {\"knee\": knee_homing_complete, \"ankle\": ankle_homing_complete}\n\n    with osl, osl_fsm:\n        osl.update()\n        osl.home(callbacks=callbacks)\n        input(\"Press Enter to start walking...\")\n\n        # knee\n        osl.knee.set_control_mode(mode=CONTROL_MODES.IMPEDANCE)\n        osl.knee.set_impedance_cc_pidf_gains()\n        osl.knee.set_output_impedance()\n\n        # ankle\n        osl.ankle.set_control_mode(mode=CONTROL_MODES.IMPEDANCE)\n        osl.ankle.set_impedance_cc_pidf_gains()\n        osl.ankle.set_output_impedance()\n\n        osl.loadcell.reset()\n        osl.loadcell.calibrate()\n\n        for t in clock:\n            osl.update()\n            print(\"Ankle position\", np.rad2deg(osl.sensors[\"joint_encoder_ankle\"].position))\n            print(\"Knee position\", np.rad2deg(osl.sensors[\"joint_encoder_knee\"].position))\n            osl_fsm.update(osl=osl)\n            # osl.knee.set_output_impedance(\n            #     k=osl_fsm.current_state.knee_stiffness,\n            #     b=osl_fsm.current_state.knee_damping,\n            # )\n            # osl.ankle.set_output_impedance(\n            #     k=osl_fsm.current_state.ankle_stiffness,\n            #     b=osl_fsm.current_state.ankle_damping,\n            # )\n\n            # osl.knee.set_output_position(np.deg2rad(osl_fsm.current_state.knee_theta))\n            # osl.ankle.set_output_position(np.deg2rad(osl_fsm.current_state.ankle_theta))\n\n            fsm_logger.info(\n                f\"T: {t:.3f}s, \"\n                f\"Current state: {osl_fsm.current_state.name}; \"\n                f\"Loadcell Fz: {osl.loadcell.fz:.3f} N; \"\n                f\"Knee theta: {np.rad2deg(osl.knee.output_position):.3f} deg; \"\n                f\"Ankle theta: {np.rad2deg(osl.ankle.output_position):.3f} deg; \"\n                f\"Knee winding temperature: {osl.knee.winding_temperature:.3f} c; \"\n                f\"Ankle winding temperature: {osl.ankle.winding_temperature:.3f} c; \"\n            )\n</code></pre>"},{"location":"examples/fsm_walking_controller/#c-and-matlab-implementation","title":"C++ and MATLAB Implementation","text":"<p>To get started, ensure you have compiled either the <code>C++</code> or <code>MATLAB</code> source code and have a <code>FSMController.so</code> library. If not, refer to the source repository for compilation instructions. To run this example, make sure the generated library is in the same directory as your script, or modify the search path for the library when loading the controller.</p>"},{"location":"examples/fsm_walking_controller/#load-compiled-library","title":"Load Compiled Library","text":"<p>First, perform standard imports, handle paths, and set up the hardware for the OSL joints and sensors</p> <pre><code>import inspect\nimport os\n\nimport numpy as np\n\nfrom opensourceleg.actuators.dephy import DephyActuator\nfrom opensourceleg.control.compiled import CompiledController\nfrom opensourceleg.sensors.loadcell import DephyLoadcellAmplifier\nfrom opensourceleg.utilities import SoftRealtimeLoop, units\n\nuse_offline_mode = False\nFREQUENCY = 200\nclock = SoftRealtimeLoop(dt=1 / FREQUENCY)\n\nknee = DephyActuator(\n    tag=\"knee\",\n    firmware_version=\"7.2.0\",\n    port=\"/dev/ttyACM0\",\n    gear_ratio=9 * 83 / 18,\n    frequency=FREQUENCY,\n)\n\nankle = DephyActuator(\n    tag=\"ankle\",\n    firmware_version=\"7.2.0\",\n    port=\"/dev/ttyACM1\",\n    gear_ratio=9 * 83 / 18,\n    frequency=FREQUENCY,\n)\n\nactuators = [knee, ankle]\n\n\nLOADCELL_MATRIX = np.array([\n    (-38.72600, -1817.74700, 9.84900, 43.37400, -44.54000, 1824.67000),\n    (-8.61600, 1041.14900, 18.86100, -2098.82200, 31.79400, 1058.6230),\n    (-1047.16800, 8.63900, -1047.28200, -20.70000, -1073.08800, -8.92300),\n    (20.57600, -0.04000, -0.24600, 0.55400, -21.40800, -0.47600),\n    (-12.13400, -1.10800, 24.36100, 0.02300, -12.14100, 0.79200),\n    (-0.65100, -28.28700, 0.02200, -25.23000, 0.47300, -27.3070),\n])\n\nloadcell = DephyLoadcellAmplifier(\n    calibration_matrix=LOADCELL_MATRIX,\n    bus=1,\n)\n\nsensors = [loadcell]\n</code></pre> <p>Note: If instantiating the OSL hardware and sensors is unfamiliar, check out the the tutorials pages.</p> <p>Next, instantiate a <code>CompiledController</code> wrapper object:</p> <pre><code>currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))\ncontroller = CompiledController(\n    library_name=\"FSMController\",\n    library_path=currentdir,\n    main_function_name=\"FSMController\",\n    initialization_function_name=\"FSMController_initialize\",\n    cleanup_function_name=\"FSMController_terminate\",\n)\n</code></pre>"},{"location":"examples/fsm_walking_controller/#define-custom-datatypes","title":"Define Custom Datatypes","text":"<p>Define the data structures used in the controller. These must match the size and order of the structures used to create the library.</p> <pre><code>controller.define_type(\n    \"impedance_param_type\",\n    [\n        (\"stiffness\", controller.types.c_double),\n        (\"damping\", controller.types.c_double),\n        (\"eq_angle\", controller.types.c_double),\n    ],\n)\ncontroller.define_type(\n    \"joint_impedance_set\",\n    [\n        (\"early_stance\", controller.types.impedance_param_type),\n        (\"late_stance\", controller.types.impedance_param_type),\n        (\"early_swing\", controller.types.impedance_param_type),\n        (\"late_swing\", controller.types.impedance_param_type),\n    ],\n)\ncontroller.define_type(\n    \"transition_parameters\",\n    [\n        (\"min_time_in_state\", controller.types.c_double),\n        (\"loadLStance\", controller.types.c_double),\n        (\"ankleThetaEstanceToLstance\", controller.types.c_double),\n        (\"kneeThetaESwingToLSwing\", controller.types.c_double),\n        (\"kneeDthetaESwingToLSwing\", controller.types.c_double),\n        (\"loadESwing\", controller.types.c_double),\n        (\"loadEStance\", controller.types.c_double),\n        (\"kneeThetaLSwingToEStance\", controller.types.c_double),\n    ],\n)\ncontroller.define_type(\n    \"UserParameters\",\n    [\n        (\"body_weight\", controller.types.c_double),\n        (\"knee_impedance\", controller.types.joint_impedance_set),\n        (\"ankle_impedance\", controller.types.joint_impedance_set),\n        (\"transition_parameters\", controller.types.transition_parameters),\n    ],\n)\ncontroller.define_type(\"sensors\", controller.DEFAULT_SENSOR_LIST)\n\ncontroller.define_inputs(\n    input_list=[\n        (\"parameters\", controller.types.UserParameters),\n        (\"sensors\", controller.types.sensors),\n        (\"time\", controller.types.c_double),\n    ]\n)\ncontroller.define_outputs(\n    output_list=[\n        (\"current_state\", controller.types.c_int),\n        (\"time_in_current_state\", controller.types.c_double),\n        (\"knee_impedance\", controller.types.impedance_param_type),\n        (\"ankle_impedance\", controller.types.impedance_param_type),\n    ]\n)\n</code></pre>"},{"location":"examples/fsm_walking_controller/#configure-impedance-and-transition-parameters","title":"Configure Impedance and Transition Parameters","text":"<p>Configure the impedance and transition parameters based on predefined tuning. Adjust these values to achieve the desired behavior:</p> <pre><code># Populate Controller inputs as needed\ncontroller.inputs.parameters.knee_impedance.early_stance.stiffness = 99.372\ncontroller.inputs.parameters.knee_impedance.early_stance.damping = 3.180\ncontroller.inputs.parameters.knee_impedance.early_stance.eq_angle = 5\ncontroller.inputs.parameters.knee_impedance.late_stance.stiffness = 99.372\ncontroller.inputs.parameters.knee_impedance.late_stance.damping = 1.272\ncontroller.inputs.parameters.knee_impedance.late_stance.eq_angle = 8\ncontroller.inputs.parameters.knee_impedance.early_swing.stiffness = 39.746\ncontroller.inputs.parameters.knee_impedance.early_swing.damping = 0.063\ncontroller.inputs.parameters.knee_impedance.early_swing.eq_angle = 60\ncontroller.inputs.parameters.knee_impedance.late_swing.stiffness = 15.899\ncontroller.inputs.parameters.knee_impedance.late_swing.damping = 3.186\ncontroller.inputs.parameters.knee_impedance.late_swing.eq_angle = 5\ncontroller.inputs.parameters.ankle_impedance.early_stance.stiffness = 19.874\ncontroller.inputs.parameters.ankle_impedance.early_stance.damping = 0\ncontroller.inputs.parameters.ankle_impedance.early_stance.eq_angle = -2\ncontroller.inputs.parameters.ankle_impedance.late_stance.stiffness = 79.498\ncontroller.inputs.parameters.ankle_impedance.late_stance.damping = 0.063\ncontroller.inputs.parameters.ankle_impedance.late_stance.eq_angle = -20\ncontroller.inputs.parameters.ankle_impedance.early_swing.stiffness = 7.949\ncontroller.inputs.parameters.ankle_impedance.early_swing.damping = 0\ncontroller.inputs.parameters.ankle_impedance.early_swing.eq_angle = 25\ncontroller.inputs.parameters.ankle_impedance.late_swing.stiffness = 7.949\ncontroller.inputs.parameters.ankle_impedance.late_swing.damping = 0.0\ncontroller.inputs.parameters.ankle_impedance.late_swing.eq_angle = 15\n\n# Configure state machine\nbody_weight = 82  # kg\ncontroller.inputs.parameters.body_weight = body_weight\ncontroller.inputs.parameters.transition_parameters.min_time_in_state = 0.20\ncontroller.inputs.parameters.transition_parameters.loadLStance = -body_weight * 0.25\ncontroller.inputs.parameters.transition_parameters.ankleThetaEstanceToLstance = 6.0\ncontroller.inputs.parameters.transition_parameters.loadESwing = -body_weight * 0.15\ncontroller.inputs.parameters.transition_parameters.kneeThetaESwingToLSwing = 50\ncontroller.inputs.parameters.transition_parameters.kneeDthetaESwingToLSwing = 3\ncontroller.inputs.parameters.transition_parameters.loadEStance = -body_weight * 0.4\ncontroller.inputs.parameters.transition_parameters.kneeThetaLSwingToEStance = 30\n</code></pre>"},{"location":"examples/fsm_walking_controller/#main-loop_1","title":"Main Loop","text":"<p>After configuration, home the OSL joints, calibrate the loadcell, set the joints to impedance mode, and begin running the controller. During each loop iteration, update the inputs, call the <code>run()</code> method, and write outputs to the hardware:</p> <pre><code>with knee, ankle, loadcell:\n    knee.home()\n    ankle.home()\n\n    knee.set_control_mode(knee.CONTROL_MODES.IMPEDANCE)\n    ankle.set_control_mode(ankle.CONTROL_MODES.IMPEDANCE)\n\n    knee.set_impedance_cc_pidf_gains()\n    ankle.set_impedance_cc_pidf_gains()\n    # Main Loop\n    for t in clock:\n        knee.update()\n        ankle.update()\n        loadcell.update()\n\n        controller.inputs.sensors.knee_angle = units.convert_from_default(knee.output_position, units.Position.deg)\n        controller.inputs.sensors.ankle_angle = units.convert_from_default(ankle.output_position, units.Position.deg)\n        controller.inputs.sensors.knee_velocity = units.convert_from_default(\n            knee.output_velocity, units.Velocity.deg_per_s\n        )\n        controller.inputs.sensors.ankle_velocity = units.convert_from_default(\n            ankle.output_velocity, units.Velocity.deg_per_s\n        )\n        controller.inputs.sensors.Fz = loadcell.fz\n\n        # Update any control inputs that change every loop\n        controller.inputs.time = t\n\n        # Call the controller\n        outputs = controller.run()\n\n        # Test print to ensure external library call works\n        print(\n            f\"Current time in state {outputs.current_state}: {outputs.time_in_current_state:.2f} seconds, \\\n                Knee Eq {outputs.knee_impedance.eq_angle:.2f}, \\\n                Ankle Eq {outputs.ankle_impedance.eq_angle:.2f}, \\\n                Fz {loadcell.fz:.2f}\",\n            end=\"\\r\",\n        )\n\n        # Write to the hardware\n        knee.set_output_impedance(\n            k=units.convert_to_default(outputs.knee_impedance.stiffness, units.Stiffness.N_m_per_rad),\n            b=units.convert_to_default(outputs.knee_impedance.damping, units.Damping.N_m_per_rad_per_s),\n        )\n        knee.set_output_position(value=units.convert_to_default(outputs.knee_impedance.eq_angle, units.Position.deg))\n        ankle.set_output_impedance(\n            k=units.convert_to_default(outputs.ankle_impedance.stiffness, units.Stiffness.N_m_per_rad),\n            b=units.convert_to_default(outputs.ankle_impedance.damping, units.Damping.N_m_per_rad_per_s),\n        )\n        ankle.set_output_position(value=units.convert_to_default(outputs.ankle_impedance.eq_angle, units.Position.deg))\n\n    print(\"\\n\")\n</code></pre> <p>Note: Be careful with units when writing outputs to the hardware. Convert values to the appropriate units if necessary.</p>"},{"location":"examples/fsm_walking_controller/#full-code-for-the-compiled-controller-implementation","title":"Full Code for The Compiled Controller Implementation","text":"<pre><code>\"\"\"\nExample walking controller for the OSL.\n\nSenthur Raj Ayyappan, Kevin Best\nNeurobionics Lab\nRobotics Department\nUniversity of Michigan\nOctober 9, 2023\n\"\"\"\n\nimport inspect\nimport os\n\nimport numpy as np\n\nfrom opensourceleg.actuators.dephy import DephyActuator\nfrom opensourceleg.control.compiled import CompiledController\nfrom opensourceleg.sensors.loadcell import DephyLoadcellAmplifier\nfrom opensourceleg.utilities import SoftRealtimeLoop, units\n\nuse_offline_mode = False\nFREQUENCY = 200\nclock = SoftRealtimeLoop(dt=1 / FREQUENCY)\n\nknee = DephyActuator(\n    tag=\"knee\",\n    firmware_version=\"7.2.0\",\n    port=\"/dev/ttyACM0\",\n    gear_ratio=9 * 83 / 18,\n    frequency=FREQUENCY,\n)\n\nankle = DephyActuator(\n    tag=\"ankle\",\n    firmware_version=\"7.2.0\",\n    port=\"/dev/ttyACM1\",\n    gear_ratio=9 * 83 / 18,\n    frequency=FREQUENCY,\n)\n\nactuators = [knee, ankle]\n\n\nLOADCELL_MATRIX = np.array([\n    (-38.72600, -1817.74700, 9.84900, 43.37400, -44.54000, 1824.67000),\n    (-8.61600, 1041.14900, 18.86100, -2098.82200, 31.79400, 1058.6230),\n    (-1047.16800, 8.63900, -1047.28200, -20.70000, -1073.08800, -8.92300),\n    (20.57600, -0.04000, -0.24600, 0.55400, -21.40800, -0.47600),\n    (-12.13400, -1.10800, 24.36100, 0.02300, -12.14100, 0.79200),\n    (-0.65100, -28.28700, 0.02200, -25.23000, 0.47300, -27.3070),\n])\n\nloadcell = DephyLoadcellAmplifier(\n    calibration_matrix=LOADCELL_MATRIX,\n    bus=1,\n)\n\nsensors = [loadcell]\n\ncurrentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))\ncontroller = CompiledController(\n    library_name=\"FSMController\",\n    library_path=currentdir,\n    main_function_name=\"FSMController\",\n    initialization_function_name=\"FSMController_initialize\",\n    cleanup_function_name=\"FSMController_terminate\",\n)\n\ncontroller.define_type(\n    \"impedance_param_type\",\n    [\n        (\"stiffness\", controller.types.c_double),\n        (\"damping\", controller.types.c_double),\n        (\"eq_angle\", controller.types.c_double),\n    ],\n)\ncontroller.define_type(\n    \"joint_impedance_set\",\n    [\n        (\"early_stance\", controller.types.impedance_param_type),\n        (\"late_stance\", controller.types.impedance_param_type),\n        (\"early_swing\", controller.types.impedance_param_type),\n        (\"late_swing\", controller.types.impedance_param_type),\n    ],\n)\ncontroller.define_type(\n    \"transition_parameters\",\n    [\n        (\"min_time_in_state\", controller.types.c_double),\n        (\"loadLStance\", controller.types.c_double),\n        (\"ankleThetaEstanceToLstance\", controller.types.c_double),\n        (\"kneeThetaESwingToLSwing\", controller.types.c_double),\n        (\"kneeDthetaESwingToLSwing\", controller.types.c_double),\n        (\"loadESwing\", controller.types.c_double),\n        (\"loadEStance\", controller.types.c_double),\n        (\"kneeThetaLSwingToEStance\", controller.types.c_double),\n    ],\n)\ncontroller.define_type(\n    \"UserParameters\",\n    [\n        (\"body_weight\", controller.types.c_double),\n        (\"knee_impedance\", controller.types.joint_impedance_set),\n        (\"ankle_impedance\", controller.types.joint_impedance_set),\n        (\"transition_parameters\", controller.types.transition_parameters),\n    ],\n)\ncontroller.define_type(\"sensors\", controller.DEFAULT_SENSOR_LIST)\n\ncontroller.define_inputs(\n    input_list=[\n        (\"parameters\", controller.types.UserParameters),\n        (\"sensors\", controller.types.sensors),\n        (\"time\", controller.types.c_double),\n    ]\n)\ncontroller.define_outputs(\n    output_list=[\n        (\"current_state\", controller.types.c_int),\n        (\"time_in_current_state\", controller.types.c_double),\n        (\"knee_impedance\", controller.types.impedance_param_type),\n        (\"ankle_impedance\", controller.types.impedance_param_type),\n    ]\n)\n\n# Populate Controller inputs as needed\ncontroller.inputs.parameters.knee_impedance.early_stance.stiffness = 99.372\ncontroller.inputs.parameters.knee_impedance.early_stance.damping = 3.180\ncontroller.inputs.parameters.knee_impedance.early_stance.eq_angle = 5\ncontroller.inputs.parameters.knee_impedance.late_stance.stiffness = 99.372\ncontroller.inputs.parameters.knee_impedance.late_stance.damping = 1.272\ncontroller.inputs.parameters.knee_impedance.late_stance.eq_angle = 8\ncontroller.inputs.parameters.knee_impedance.early_swing.stiffness = 39.746\ncontroller.inputs.parameters.knee_impedance.early_swing.damping = 0.063\ncontroller.inputs.parameters.knee_impedance.early_swing.eq_angle = 60\ncontroller.inputs.parameters.knee_impedance.late_swing.stiffness = 15.899\ncontroller.inputs.parameters.knee_impedance.late_swing.damping = 3.186\ncontroller.inputs.parameters.knee_impedance.late_swing.eq_angle = 5\ncontroller.inputs.parameters.ankle_impedance.early_stance.stiffness = 19.874\ncontroller.inputs.parameters.ankle_impedance.early_stance.damping = 0\ncontroller.inputs.parameters.ankle_impedance.early_stance.eq_angle = -2\ncontroller.inputs.parameters.ankle_impedance.late_stance.stiffness = 79.498\ncontroller.inputs.parameters.ankle_impedance.late_stance.damping = 0.063\ncontroller.inputs.parameters.ankle_impedance.late_stance.eq_angle = -20\ncontroller.inputs.parameters.ankle_impedance.early_swing.stiffness = 7.949\ncontroller.inputs.parameters.ankle_impedance.early_swing.damping = 0\ncontroller.inputs.parameters.ankle_impedance.early_swing.eq_angle = 25\ncontroller.inputs.parameters.ankle_impedance.late_swing.stiffness = 7.949\ncontroller.inputs.parameters.ankle_impedance.late_swing.damping = 0.0\ncontroller.inputs.parameters.ankle_impedance.late_swing.eq_angle = 15\n\n# Configure state machine\nbody_weight = 82  # kg\ncontroller.inputs.parameters.body_weight = body_weight\ncontroller.inputs.parameters.transition_parameters.min_time_in_state = 0.20\ncontroller.inputs.parameters.transition_parameters.loadLStance = -body_weight * 0.25\ncontroller.inputs.parameters.transition_parameters.ankleThetaEstanceToLstance = 6.0\ncontroller.inputs.parameters.transition_parameters.loadESwing = -body_weight * 0.15\ncontroller.inputs.parameters.transition_parameters.kneeThetaESwingToLSwing = 50\ncontroller.inputs.parameters.transition_parameters.kneeDthetaESwingToLSwing = 3\ncontroller.inputs.parameters.transition_parameters.loadEStance = -body_weight * 0.4\ncontroller.inputs.parameters.transition_parameters.kneeThetaLSwingToEStance = 30\n\nwith knee, ankle, loadcell:\n    knee.home()\n    ankle.home()\n\n    knee.set_control_mode(knee.CONTROL_MODES.IMPEDANCE)\n    ankle.set_control_mode(ankle.CONTROL_MODES.IMPEDANCE)\n\n    knee.set_impedance_cc_pidf_gains()\n    ankle.set_impedance_cc_pidf_gains()\n    # Main Loop\n    for t in clock:\n        knee.update()\n        ankle.update()\n        loadcell.update()\n\n        controller.inputs.sensors.knee_angle = units.convert_from_default(knee.output_position, units.Position.deg)\n        controller.inputs.sensors.ankle_angle = units.convert_from_default(ankle.output_position, units.Position.deg)\n        controller.inputs.sensors.knee_velocity = units.convert_from_default(\n            knee.output_velocity, units.Velocity.deg_per_s\n        )\n        controller.inputs.sensors.ankle_velocity = units.convert_from_default(\n            ankle.output_velocity, units.Velocity.deg_per_s\n        )\n        controller.inputs.sensors.Fz = loadcell.fz\n\n        # Update any control inputs that change every loop\n        controller.inputs.time = t\n\n        # Call the controller\n        outputs = controller.run()\n\n        # Test print to ensure external library call works\n        print(\n            f\"Current time in state {outputs.current_state}: {outputs.time_in_current_state:.2f} seconds, \\\n                Knee Eq {outputs.knee_impedance.eq_angle:.2f}, \\\n                Ankle Eq {outputs.ankle_impedance.eq_angle:.2f}, \\\n                Fz {loadcell.fz:.2f}\",\n            end=\"\\r\",\n        )\n\n        # Write to the hardware\n        knee.set_output_impedance(\n            k=units.convert_to_default(outputs.knee_impedance.stiffness, units.Stiffness.N_m_per_rad),\n            b=units.convert_to_default(outputs.knee_impedance.damping, units.Damping.N_m_per_rad_per_s),\n        )\n        knee.set_output_position(value=units.convert_to_default(outputs.knee_impedance.eq_angle, units.Position.deg))\n        ankle.set_output_impedance(\n            k=units.convert_to_default(outputs.ankle_impedance.stiffness, units.Stiffness.N_m_per_rad),\n            b=units.convert_to_default(outputs.ankle_impedance.damping, units.Damping.N_m_per_rad_per_s),\n        )\n        ankle.set_output_position(value=units.convert_to_default(outputs.ankle_impedance.eq_angle, units.Position.deg))\n\n    print(\"\\n\")\n</code></pre>"},{"location":"tutorials/other_best_practices/","title":"Best Practices","text":""},{"location":"tutorials/other_best_practices/#softstart","title":"Softstart","text":"<p>In robotic prostheses (as well as in general robotics), startup and initialization can often produce abrupt changes in motor torque that are undesirable. These sudden step changes in torque can be unsettling to the user and unececssarily hard on the hardware. To address this, we recommend implementing a softstart mechanism. This approach ensures a smooth ramp-up of torque at startup by scaling the control parameters, such as torque, impedance gains, or position gains, over a specified period.</p> <p>Although the <code>opensourceleg</code> library does not include a built-in softstart feature, it is straightforward to implement using the <code>SaturatingRamp</code> class from the math submodule. Below, we outline the general procedure and provide an example script for a position control implementation. Similar effects for impedance, torque, and velocity control can be achieved following the same steps.</p>"},{"location":"tutorials/other_best_practices/#implementation-steps","title":"Implementation Steps","text":"<ol> <li> <p>Define a <code>SaturatingRamp</code> Instance    Create an instance of the <code>SaturatingRamp</code> class from the <code>opensourceleg.math.math</code> module, specifying the desired softstart duration (e.g., <code>SOFT_START_TIME = 1.5</code> seconds).</p> </li> <li> <p>Scale Control Parameters    During each iteration of your control loop, use the output of the <code>SaturatingRamp</code> instance to scale your control parameters (e.g., torque commands, impedance gains, or position gains). After the ramp duration, the <code>SaturatingRamp</code> object outputs a value of <code>1</code>, leaving your parameters unchanged for the remainder of the execution.</p> </li> </ol>"},{"location":"tutorials/other_best_practices/#example-position-control-with-softstart","title":"Example: Position Control with Softstart","text":"<p>Here, we walk through an example script demonstrating softstart in a position control paradigm.</p>"},{"location":"tutorials/other_best_practices/#key-code-snippets","title":"Key Code Snippets","text":"<ol> <li>Initialize the <code>SaturatingRamp</code> Instance    The following snippet shows how to create a <code>SaturatingRamp</code> instance with the desired softstart time: <pre><code>    soft_start_ramp = SaturatingRamp(SOFT_START_TIME)\n</code></pre></li> <li>Scale Control Gains    During each loop iteration, call the ramp's update method and scale the control gains with the result:</li> </ol> <pre><code>            ss_scale = soft_start_ramp.update(t)\n            actpack.set_position_gains(\n                DEFAULT_POSITION_GAINS.kp * ss_scale,\n                DEFAULT_POSITION_GAINS.kd * ss_scale,\n                DEFAULT_POSITION_GAINS.ki * ss_scale,\n            )\n            command_position = start_position + (1 / 2) * np.pi\n            actpack.set_output_position(value=command_position)\n</code></pre> <p>Here is the full script: <pre><code>import numpy as np\n\nfrom opensourceleg.actuators.base import CONTROL_MODES\nfrom opensourceleg.actuators.dephy import DEFAULT_POSITION_GAINS, DephyActuator\nfrom opensourceleg.logging.logger import Logger\nfrom opensourceleg.math.math import SaturatingRamp\nfrom opensourceleg.utilities.softrealtimeloop import SoftRealtimeLoop\n\nFREQUENCY = 1000\nDT = 1 / FREQUENCY\nGEAR_RATIO = 1.0\nSOFT_START_TIME = 1.0\n\n\ndef softstart_position_control():\n    position_logger = Logger(\n        log_path=\"./logs\",\n        file_name=\"position_control\",\n    )\n    actpack = DephyActuator(\n        port=\"/dev/ttyACM0\", gear_ratio=GEAR_RATIO, frequency=FREQUENCY, debug_level=0, dephy_log=False\n    )\n    clock = SoftRealtimeLoop(dt=DT)\n    soft_start_ramp = SaturatingRamp(SOFT_START_TIME)\n\n    with actpack:\n        actpack.set_control_mode(mode=CONTROL_MODES.POSITION)\n\n        actpack.update()\n        start_position = actpack.output_position\n\n        for t in clock:\n            ss_scale = soft_start_ramp.update(t)\n            actpack.set_position_gains(\n                DEFAULT_POSITION_GAINS.kp * ss_scale,\n                DEFAULT_POSITION_GAINS.kd * ss_scale,\n                DEFAULT_POSITION_GAINS.ki * ss_scale,\n            )\n            command_position = start_position + (1 / 2) * np.pi\n            actpack.set_output_position(value=command_position)\n\n            actpack.update()\n\n            position_logger.info(\n                f\"Time: {t}; \\\n                                 Command Position: {command_position}; \\\n                                 Output Position: {actpack.output_position}\"\n            )\n\n\nif __name__ == \"__main__\":\n    softstart_position_control()\n</code></pre></p>"},{"location":"tutorials/actuators/commanding_current/","title":"Commanding Current","text":"<p>This tutorial demonstrates how to command current to a Dephy actuator using the <code>opensourceleg</code> library. You'll learn how to implement a basic step response test by commanding a current setpoint.</p>"},{"location":"tutorials/actuators/commanding_current/#overview","title":"Overview","text":"<p>Current control is fundamental for motor control applications. This example shows how to:</p> <ul> <li>Initialize a Dephy actuator in current control mode</li> <li>Command a current step input</li> <li>Log and monitor the actuator's response</li> </ul>"},{"location":"tutorials/actuators/commanding_current/#code-structure","title":"Code Structure","text":"<p>The tutorial script is organized into four main sections:</p>"},{"location":"tutorials/actuators/commanding_current/#1-configuration","title":"1. Configuration","text":"<pre><code>from opensourceleg.actuators.base import CONTROL_MODES\nfrom opensourceleg.actuators.dephy import DephyActuator\nfrom opensourceleg.logging.logger import Logger\nfrom opensourceleg.utilities import SoftRealtimeLoop\n\nTIME_TO_STEP = 1.0\nFREQUENCY = 1000\nDT = 1 / FREQUENCY\nGEAR_RATIO = 1.0\n</code></pre> <p>Key parameters:</p> <ul> <li><code>TIME_TO_STEP</code>: Delay before applying current (1.0 second)</li> <li><code>FREQUENCY</code>: Control loop rate (1000 Hz)</li> <li><code>CURRENT_SETPOINT</code>: Target current (600 mA)</li> </ul>"},{"location":"tutorials/actuators/commanding_current/#2-initialization","title":"2. Initialization","text":"<pre><code>def current_control():\n    current_logger = Logger(\n        log_path=\"./logs\",\n        file_name=\"current_control\",\n    )\n    actpack = DephyActuator(\n        port=\"/dev/ttyACM0\", gear_ratio=GEAR_RATIO, frequency=FREQUENCY, debug_level=0, dephy_log=False\n</code></pre> <p>This section:</p> <ul> <li>Creates a data logger for recording measurements</li> <li>Initializes the Dephy actuator with specified parameters</li> <li>Sets up a real-time loop for consistent timing</li> </ul>"},{"location":"tutorials/actuators/commanding_current/#3-control-setup","title":"3. Control Setup","text":"<pre><code>    with actpack:\n        actpack.set_control_mode(mode=CONTROL_MODES.CURRENT)\n        actpack.set_current_gains()\n\n        command_current = 0\n\n        current_logger.track_function(lambda: actpack.motor_current, \"Motor Current\")\n</code></pre> <p>Before the main loop, we:</p> <ul> <li>Configure the actuator for current control mode</li> <li>Initialize current control gains</li> <li>Set up variables for tracking commanded and measured current</li> </ul>"},{"location":"tutorials/actuators/commanding_current/#4-control-loop","title":"4. Control Loop","text":"<pre><code>        for t in clock:\n            if t &gt; TIME_TO_STEP:\n                command_current = CURRENT_SETPOINT\n                actpack.set_motor_current(value=command_current)  # in mA\n\n            actpack.update()\n\n            current_logger.info(\n                f\"Time: {t}; Command Current: {command_current}; Motor Current: {actpack.motor_current}\",\n            )\n            current_logger.update()\n</code></pre> <p>The main loop:</p> <ol> <li>Starts with zero current</li> <li>After <code>TIME_TO_STEP</code>, commands <code>CURRENT_SETPOINT</code></li> <li>Updates actuator state</li> <li>Logs time, commanded current, and measured current</li> </ol>"},{"location":"tutorials/actuators/commanding_current/#running-the-example","title":"Running the Example","text":"<ol> <li> <p>Navigate to the tutorial directory:</p> <pre><code>cd tutorials/actuators/dephy\n</code></pre> </li> <li> <p>Run the script:</p> <pre><code>python commanding_current.py\n</code></pre> </li> <li> <p>Expected behavior:</p> <ul> <li>t &lt; 1.0s: Motor maintains 0 mA</li> <li>t \u2265 1.0s: Motor steps to 600 mA</li> <li>Data is continuously logged to <code>./logs/commanding_current.csv</code></li> </ul> </li> </ol> <p>If you have any questions or need further assistance, please post on the Open Source Leg community forum.</p>"},{"location":"tutorials/actuators/commanding_impedance/","title":"Commanding Impedance","text":"<p>This tutorial demonstrates how to implement impedance control with a Dephy actuator using the <code>opensourceleg</code> library. You'll learn how to command position setpoints while maintaining compliant behavior through impedance control.</p>"},{"location":"tutorials/actuators/commanding_impedance/#overview","title":"Overview","text":"<p>Impedance control allows for position control while maintaining a specified dynamic relationship between position and force. This example shows how to:</p> <ul> <li>Initialize a Dephy actuator in impedance control mode</li> <li>Command a position step input</li> <li>Monitor position tracking and motor current</li> </ul>"},{"location":"tutorials/actuators/commanding_impedance/#code-structure","title":"Code Structure","text":"<p>The tutorial script is organized into four main sections:</p>"},{"location":"tutorials/actuators/commanding_impedance/#1-configuration","title":"1. Configuration","text":"<pre><code>import time\n\nimport numpy as np\n\nfrom opensourceleg.actuators.base import CONTROL_MODES\nfrom opensourceleg.actuators.dephy import DephyActuator\nfrom opensourceleg.logging.logger import Logger\nfrom opensourceleg.utilities import SoftRealtimeLoop\n\nTIME_TO_STEP = 1.0\nFREQUENCY = 1000\nDT = 1 / FREQUENCY\nGEAR_RATIO = 41.5  # 1.0\n</code></pre> <p>Key parameters:</p> <ul> <li><code>TIME_TO_STEP</code>: Delay before position step (1.0 second)</li> <li><code>FREQUENCY</code>: Control loop rate (1000 Hz)</li> <li><code>GEAR_RATIO</code>: Actuator gear ratio (1.0)</li> </ul>"},{"location":"tutorials/actuators/commanding_impedance/#2-initialization","title":"2. Initialization","text":"<pre><code>def impedance_control():\n    impedance_logger = Logger(\n        log_path=\"./logs\",\n        file_name=\"impedance_control\",\n    )\n    actpack = DephyActuator(\n        port=\"/dev/ttyACM0\",\n        gear_ratio=GEAR_RATIO,\n        frequency=FREQUENCY,\n        debug_level=0,\n        dephy_log=False,\n</code></pre> <p>This section:</p> <ul> <li>Creates a data logger for recording measurements</li> <li>Initializes the Dephy actuator with specified parameters</li> <li>Sets up a real-time loop for consistent timing</li> </ul>"},{"location":"tutorials/actuators/commanding_impedance/#3-control-setup","title":"3. Control Setup","text":"<pre><code>    clock = SoftRealtimeLoop(dt=DT)\n\n    impedance_logger.set_stream_terminator(\"\\r\")\n\n    with actpack:\n        actpack.update()\n        actpack.set_control_mode(mode=CONTROL_MODES.IMPEDANCE)\n        actpack.set_impedance_cc_pidf_gains()\n        actpack.set_output_impedance()\n\n        current_position = actpack.output_position\n        command_position = current_position\n</code></pre> <p>Before the main loop, we:</p> <ul> <li>Configure the actuator for impedance control mode</li> <li>Initialize impedance control gains</li> <li>Get initial position and set up command position</li> <li>Configure logging variables for position and current</li> </ul>"},{"location":"tutorials/actuators/commanding_impedance/#4-control-loop","title":"4. Control Loop","text":"<pre><code>        impedance_logger.track_function(lambda: actpack.output_position, \"Output Position\")\n        impedance_logger.track_function(lambda: command_position, \"Command Position\")\n        impedance_logger.track_function(lambda: actpack.motor_current, \"Motor Current\")\n        impedance_logger.track_function(lambda: time.time(), \"Time\")\n\n        for t in clock:\n            actpack.update()\n\n            if t &gt; TIME_TO_STEP:\n                command_position = current_position + np.deg2rad(6)\n\n            actpack.set_output_position(value=command_position)\n\n            impedance_logger.info(\n                f\"Time: {t}; \"\n                f\"Command Position: {command_position}; \"\n</code></pre> <p>The main loop:</p> <ol> <li>Starts at current position</li> <li>After <code>TIME_TO_STEP</code>, commands a \u03c0/2 radian (90 degree) position step</li> <li>Updates actuator state</li> <li>Logs time, positions, and motor current</li> </ol>"},{"location":"tutorials/actuators/commanding_impedance/#running-the-example","title":"Running the Example","text":"<ol> <li> <p>Navigate to the tutorial directory:</p> <pre><code>cd tutorials/actuators/dephy\n</code></pre> </li> <li> <p>Run the script:</p> <pre><code>python commanding_impedance.py\n</code></pre> </li> <li> <p>Expected behavior:</p> <ul> <li>t &lt; 1.0s: Motor maintains initial position</li> <li>t \u2265 1.0s: Motor moves to position + \u03c0/2 radians</li> <li>Movement will be compliant due to impedance control</li> <li>Data is continuously logged to <code>./logs/commanding_impedance.csv</code></li> </ul> </li> </ol> <p>If you have any questions or need further assistance, please post on the Open Source Leg community forum.</p>"},{"location":"tutorials/actuators/commanding_position/","title":"Commanding Position","text":"<p>This tutorial demonstrates how to command position to a Dephy actuator using the <code>opensourceleg</code> library. You'll learn how to implement a basic step response test by commanding a position setpoint.</p>"},{"location":"tutorials/actuators/commanding_position/#overview","title":"Overview","text":"<p>Position control allows direct control of the actuator's angular position. This example shows how to:</p> <ul> <li>Initialize a Dephy actuator in position control mode</li> <li>Command a position step input</li> <li>Log and monitor the actuator's response</li> </ul>"},{"location":"tutorials/actuators/commanding_position/#code-structure","title":"Code Structure","text":"<p>The tutorial script is organized into four main sections:</p>"},{"location":"tutorials/actuators/commanding_position/#1-configuration","title":"1. Configuration","text":"<pre><code>import time\n\nimport numpy as np\n\nfrom opensourceleg.actuators.base import CONTROL_MODES\nfrom opensourceleg.actuators.dephy import DephyActuator\nfrom opensourceleg.logging.logger import Logger\nfrom opensourceleg.utilities import SoftRealtimeLoop\n\nTIME_TO_STEP = 1.0\nFREQUENCY = 1000\nDT = 1 / FREQUENCY\nGEAR_RATIO = 1.0\n</code></pre> <p>Key parameters:</p> <ul> <li><code>TIME_TO_STEP</code>: Delay before position step (1.0 second)</li> <li><code>FREQUENCY</code>: Control loop rate (1000 Hz)</li> <li><code>GEAR_RATIO</code>: Actuator gear ratio (1.0)</li> </ul>"},{"location":"tutorials/actuators/commanding_position/#2-initialization","title":"2. Initialization","text":"<pre><code>def position_control():\n    position_logger = Logger(\n        log_path=\"./logs\",\n        file_name=\"position_control\",\n    )\n    actpack = DephyActuator(\n        port=\"/dev/ttyACM0\", gear_ratio=GEAR_RATIO, frequency=FREQUENCY, debug_level=0, dephy_log=False\n    )\n    clock = SoftRealtimeLoop(dt=DT)\n</code></pre> <p>This section:</p> <ul> <li>Creates a data logger for recording measurements</li> <li>Initializes the Dephy actuator with specified parameters</li> <li>Sets up a real-time loop for consistent timing</li> </ul>"},{"location":"tutorials/actuators/commanding_position/#3-control-setup","title":"3. Control Setup","text":"<pre><code>    with actpack:\n        actpack.set_control_mode(mode=CONTROL_MODES.POSITION)\n        actpack.set_position_gains()\n\n        actpack.update()\n        current_position = actpack.output_position\n        command_position = current_position\n\n        position_logger.track_function(lambda: actpack.output_position, \"Output Position\")\n        position_logger.track_function(lambda: command_position, \"Command Position\")\n        position_logger.track_function(lambda: time.time(), \"Time\")\n</code></pre> <p>Before the main loop, we:</p> <ul> <li>Configure the actuator for position control mode</li> <li>Initialize position control gains</li> <li>Get initial position and set up command position</li> <li>Configure logging variables for tracking positions</li> </ul>"},{"location":"tutorials/actuators/commanding_position/#4-control-loop","title":"4. Control Loop","text":"<pre><code>        for t in clock:\n            if t &gt; TIME_TO_STEP:\n                command_position = current_position + (1 / 2) * np.pi\n                actpack.set_output_position(value=command_position)\n\n            actpack.update()\n\n            position_logger.info(\n                f\"Time: {t}; \\\n</code></pre> <p>The main loop:</p> <ol> <li>Starts at current position</li> <li>After <code>TIME_TO_STEP</code>, commands a \u03c0/2 radian (90 degree) position step</li> <li>Updates actuator state</li> <li>Logs time and position data</li> </ol>"},{"location":"tutorials/actuators/commanding_position/#running-the-example","title":"Running the Example","text":"<ol> <li> <p>Navigate to the tutorial directory:</p> <pre><code>cd tutorials/actuators/dephy\n</code></pre> </li> <li> <p>Run the script:</p> <pre><code>python commanding_position.py\n</code></pre> </li> <li> <p>Expected behavior:</p> <ul> <li>t &lt; 1.0s: Motor maintains initial position</li> <li>t \u2265 1.0s: Motor moves to position + \u03c0/2 radians (90 degrees)</li> <li>Data is continuously logged to <code>./logs/commanding_position.csv</code></li> </ul> </li> </ol> <p>If you have any questions or need further assistance, please post on the Open Source Leg community forum.</p>"},{"location":"tutorials/actuators/commanding_voltage/","title":"Commanding Voltage","text":"<p>This tutorial demonstrates how to command voltage to a Dephy actuator using the <code>opensourceleg</code> library. You'll learn how to implement a basic step response test by commanding a voltage setpoint.</p>"},{"location":"tutorials/actuators/commanding_voltage/#overview","title":"Overview","text":"<p>Voltage control is the most basic form of motor control. This example shows how to:</p> <ul> <li>Initialize a Dephy actuator in voltage control mode</li> <li>Command a voltage step input</li> <li>Log and monitor the actuator's response</li> </ul>"},{"location":"tutorials/actuators/commanding_voltage/#code-structure","title":"Code Structure","text":"<p>The tutorial script is organized into four main sections:</p>"},{"location":"tutorials/actuators/commanding_voltage/#1-configuration","title":"1. Configuration","text":"<pre><code>import time\n\nfrom opensourceleg.actuators.base import CONTROL_MODES\nfrom opensourceleg.actuators.dephy import DephyActuator\nfrom opensourceleg.logging.logger import Logger\nfrom opensourceleg.utilities import SoftRealtimeLoop\n\nFREQUENCY = 1000\nTIME_TO_STEP = 1.0\nDT = 1 / FREQUENCY\nGEAR_RATIO = 1.0\n</code></pre> <p>Key parameters:</p> <ul> <li><code>TIME_TO_STEP</code>: Delay before applying voltage (1.0 second)</li> <li><code>FREQUENCY</code>: Control loop rate (1000 Hz)</li> <li><code>GEAR_RATIO</code>: Actuator gear ratio (1.0)</li> </ul>"},{"location":"tutorials/actuators/commanding_voltage/#2-initialization","title":"2. Initialization","text":"<pre><code>def voltage_control():\n    voltage_logger = Logger(\n        log_path=\"./logs\",\n        file_name=\"voltage_control\",\n    )\n\n    actpack = DephyActuator(\n        port=\"/dev/ttyACM0\",\n        gear_ratio=GEAR_RATIO,\n        frequency=FREQUENCY,\n        debug_level=0,\n        dephy_log=False,\n    )\n\n    command_voltage = 0\n\n    voltage_logger.track_function(lambda: command_voltage, \"Command Voltage\")\n    voltage_logger.track_function(lambda: actpack.motor_voltage, \"Motor Voltage\")\n    voltage_logger.track_function(lambda: time.time(), \"Time\")\n\n    clock = SoftRealtimeLoop(dt=DT)\n</code></pre> <p>This section:</p> <ul> <li>Creates a data logger for recording measurements</li> <li>Initializes the Dephy actuator with specified parameters</li> <li>Sets up a real-time loop for consistent timing</li> </ul>"},{"location":"tutorials/actuators/commanding_voltage/#3-control-setup","title":"3. Control Setup","text":"<pre><code>    with actpack:\n        actpack.set_control_mode(mode=CONTROL_MODES.VOLTAGE)\n</code></pre> <p>Before the main loop, we:</p> <ul> <li>Initialize command voltage to zero</li> <li>Set up logging variables for voltage and time</li> <li>Configure the real-time loop</li> </ul>"},{"location":"tutorials/actuators/commanding_voltage/#4-control-loop","title":"4. Control Loop","text":"<pre><code>        for t in clock:\n            actpack.update()\n\n            if t &gt; TIME_TO_STEP:\n                command_voltage = 1000\n\n            actpack.set_motor_voltage(value=command_voltage)\n\n            voltage_logger.info(\n                f\"Time: {t}; \"\n                f\"Command Voltage: {command_voltage}; \"\n                f\"Motor Voltage: {actpack.motor_voltage}; \"\n</code></pre> <p>The main loop:</p> <ol> <li>Starts with zero voltage</li> <li>After <code>TIME_TO_STEP</code>, commands 1000 mV</li> <li>Updates actuator state</li> <li>Logs time, motor voltage, and motor current</li> </ol>"},{"location":"tutorials/actuators/commanding_voltage/#running-the-example","title":"Running the Example","text":"<ol> <li> <p>Navigate to the tutorial directory:</p> <pre><code>cd tutorials/actuators/dephy\n</code></pre> </li> <li> <p>Run the script:</p> <pre><code>python commanding_voltage.py\n</code></pre> </li> <li> <p>Expected behavior:</p> <ul> <li>t &lt; 1.0s: Motor maintains 0 mV</li> <li>t \u2265 1.0s: Motor steps to 1000 mV</li> <li>Data is continuously logged to <code>./logs/commanding_voltage.csv</code></li> </ul> </li> </ol>"},{"location":"tutorials/actuators/commanding_voltage/#additional-notes","title":"Additional Notes","text":"<ul> <li>Voltage control provides no feedback regulation</li> <li>Motor speed will vary with load under constant voltage</li> <li>This mode is useful for basic testing and characterization of the motor</li> </ul> <p>If you have any questions or need further assistance, please post on the Open Source Leg community forum.</p>"},{"location":"tutorials/actuators/getting_started/","title":"Getting Started with Actuators","text":"<p>This guide introduces the <code>opensourceleg.actuators</code> module and provides essential safety information for all actuator tutorials.</p>"},{"location":"tutorials/actuators/getting_started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Raspberry Pi</li> <li>Python environment with <code>opensourceleg</code> package installed</li> <li>Supported actuator (Dephy actuator used in examples)</li> <li>External power supply</li> </ul>"},{"location":"tutorials/actuators/getting_started/#hardware-setup","title":"Hardware Setup","text":"<ol> <li>Connect the actuator to your computer via USB (typically at <code>/dev/ttyACM0</code>)</li> <li>Connect and verify the external power supply</li> <li>Ensure proper mounting of the actuator before operation</li> </ol>"},{"location":"tutorials/actuators/getting_started/#safety-guidelines","title":"Safety Guidelines","text":"<p>Please follow these guidelines when following the <code>opensourceleg.actuators</code> tutorials.</p>"},{"location":"tutorials/actuators/getting_started/#1-mechanical-safety","title":"1. Mechanical Safety","text":"<ul> <li>Securely mount the actuator before operation</li> <li>Maintain clear space around moving parts</li> <li>Verify sufficient range of motion for commands</li> <li> <p>Be aware of mechanical limits and stops</p> </li> <li> <p>Have a clear emergency stop plan</p> </li> <li>Know how to quickly terminate scripts (<code>Ctrl+C</code>)</li> <li>Keep emergency stop button accessible</li> </ul>"},{"location":"tutorials/actuators/getting_started/#2-electrical-safety","title":"2. Electrical Safety","text":"<ul> <li>Never exceed rated voltage/current limits</li> <li>Verify proper power supply connection</li> <li>Ensure proper grounding</li> <li>Check all electrical connections before powering on</li> </ul>"},{"location":"tutorials/actuators/getting_started/#3-operational-safety","title":"3. Operational Safety","text":"<ul> <li> <p>Start with conservative values:</p> <ul> <li>Low voltages in voltage control</li> <li>Low currents in current control</li> <li>Small steps in position control</li> </ul> </li> <li> <p>Continuously monitor sensor readings</p> </li> <li>Watch for unexpected behavior:<ul> <li>Oscillations</li> <li>Excessive current draw</li> <li>Unusual sounds or vibrations</li> <li>Unexpected resistance</li> </ul> </li> </ul>"},{"location":"tutorials/actuators/getting_started/#4-best-practices","title":"4. Best Practices","text":"<ul> <li>Verify all connections</li> <li>Check mounting security</li> <li>Clear workspace of obstacles</li> <li> <p>Review emergency procedures</p> </li> <li> <p>Monitor system behavior</p> </li> <li>Keep hands clear</li> <li>Be ready to terminate</li> <li> <p>Log any unusual behavior</p> </li> <li> <p>Power down safely</p> </li> <li>Document any issues</li> <li>Verify data logging</li> <li>Check actuator temperature</li> </ul>"},{"location":"tutorials/actuators/getting_started/#troubleshooting-guide","title":"Troubleshooting Guide","text":"<ul> <li>Check device presence: <code>ls /dev/ttyACM*</code></li> <li> <p>Verify USB permissions, if you see <code>Permission denied</code> error, it is likely because the current user does not have permission to access the serial ports. You can add your user to the <code>dialout</code> group to fix this. If you are on a Linux system, you can run <code>sudo usermod -a -G dialout $USER</code> to add your user to the <code>dialout</code> group. Then you need to restart your system for the changes to take effect.</p> </li> <li> <p>Try physical reconnection:</p> <ol> <li>Unplug USB</li> <li>Wait a few seconds</li> <li>Reconnect</li> </ol> </li> <li> <p>Verify power supply connection</p> </li> <li>Check voltage levels</li> <li>Confirm power LED indicators</li> <li>Monitor current draw</li> </ul>"},{"location":"tutorials/actuators/getting_started/#getting-help","title":"Getting Help","text":"<p>If you encounter any issues or need assistance:</p> <ol> <li>Check the troubleshooting section in the specific tutorial</li> <li>Review the API documentation</li> <li>Post questions on the Open Source Leg community forum</li> </ol>"},{"location":"tutorials/actuators/getting_started/#next-steps","title":"Next Steps","text":"<p>Choose a tutorial to get started:</p> <ul> <li>Reading Sensor Data</li> <li>Commanding Voltage</li> <li>Commanding Current</li> <li>Commanding Position</li> <li>Commanding Impedance</li> </ul> <p>Each tutorial includes specific setup instructions and code examples.</p>"},{"location":"tutorials/actuators/reading_sensor_data/","title":"Reading Sensors","text":"<p>This tutorial demonstrates how to read sensor data from a Dephy actuator using the <code>opensourceleg</code> library. You'll learn how to continuously monitor and log actuator sensor values.</p>"},{"location":"tutorials/actuators/reading_sensor_data/#overview","title":"Overview","text":"<p>This example shows how to:</p> <ul> <li>Initialize a Dephy actuator for sensor reading</li> <li>Continuously monitor sensor values</li> <li>Log sensor data for analysis</li> </ul>"},{"location":"tutorials/actuators/reading_sensor_data/#code-structure","title":"Code Structure","text":"<p>The tutorial script is organized into three main sections:</p>"},{"location":"tutorials/actuators/reading_sensor_data/#1-configuration","title":"1. Configuration","text":"<pre><code>from opensourceleg.actuators.dephy import DephyActuator\nfrom opensourceleg.logging.logger import Logger\nfrom opensourceleg.utilities import SoftRealtimeLoop\n\nFREQUENCY = 1000\nDT = 1 / FREQUENCY\nGEAR_RATIO = 1.0\n</code></pre> <p>Key parameters:</p> <ul> <li><code>FREQUENCY</code>: Sensor reading rate (1000 Hz)</li> <li><code>GEAR_RATIO</code>: Actuator gear ratio (1.0)</li> </ul>"},{"location":"tutorials/actuators/reading_sensor_data/#2-initialization","title":"2. Initialization","text":"<pre><code>if __name__ == \"__main__\":\n    sensor_logger = Logger(\n        log_path=\"./logs\",\n        file_name=\"reading_sensor_data\",\n    )\n    clock = SoftRealtimeLoop(dt=DT)\n    actpack = DephyActuator(\n        port=\"/dev/ttyACM0\",\n        gear_ratio=GEAR_RATIO,\n        frequency=FREQUENCY,\n        debug_level=0,\n        dephy_log=False,\n    )\n    sensor_logger.track_function(lambda: actpack.motor_position, \"Motor Position\")\n    sensor_logger.track_function(lambda: actpack.motor_current, \"Motor Current\")\n</code></pre> <p>This section:</p> <ul> <li>Creates a data logger for recording measurements</li> <li>Initializes the Dephy actuator with specified parameters</li> <li>Sets up a real-time loop for consistent timing</li> <li>Configures which sensor variables to track</li> </ul>"},{"location":"tutorials/actuators/reading_sensor_data/#3-main-loop","title":"3. Main Loop","text":"<pre><code>    with actpack:\n        for t in clock:\n            actpack.update()\n            sensor_logger.info(f\"Time: {t}; Motor Position: {actpack.motor_position};\")\n            sensor_logger.update()\n</code></pre> <p>The main loop:</p> <ol> <li>Updates actuator state to get fresh sensor readings</li> <li>Logs time and sensor values</li> <li>Updates the logger</li> </ol>"},{"location":"tutorials/actuators/reading_sensor_data/#running-the-example","title":"Running the Example","text":"<ol> <li> <p>Navigate to the tutorial directory:</p> <pre><code>cd tutorials/actuators/dephy\n</code></pre> </li> <li> <p>Run the script:</p> <pre><code>python reading_sensor_data.py\n</code></pre> </li> <li> <p>Expected behavior:</p> <ul> <li>Continuous reading of sensor values</li> <li>Data logged to <code>./logs/reading_sensor_data.csv</code></li> <li>No active control (read-only operation)</li> </ul> </li> </ol>"},{"location":"tutorials/actuators/reading_sensor_data/#additional-notes","title":"Additional Notes","text":"<ul> <li>This script operates in read-only mode</li> <li>No control commands are sent to the actuator, feel free to move the actuator output and see the sensor values change</li> </ul>"},{"location":"tutorials/actuators/reading_sensor_data/#available-sensor-readings","title":"Available Sensor Readings","text":"<p>The Dephy actuator provides several sensor values that can be tracked, you can find the list of all the available sensor readings in the Actuator API documentation.</p> <p>If you have any questions or need further assistance, please post on the Open Source Leg community forum.</p>"},{"location":"tutorials/actuators/tmotor_servo_setup/","title":"TMotor Servo Mode Setup Guide","text":""},{"location":"tutorials/actuators/tmotor_servo_setup/#prerequisites","title":"Prerequisites","text":"<p>Before using TMotor actuators in servo mode, you need to configure the CAN interface on your system.</p>"},{"location":"tutorials/actuators/tmotor_servo_setup/#can-interface-configuration","title":"CAN Interface Configuration","text":""},{"location":"tutorials/actuators/tmotor_servo_setup/#initial-setup","title":"Initial Setup","text":"<p>Run the following commands to configure the CAN interface for TMotor servo mode:</p> <pre><code># Bring down the CAN interface\nsudo /sbin/ip link set can0 down\n\n# Configure CAN interface with 1MHz bitrate\nsudo /sbin/ip link set can0 up type can bitrate 1000000\n</code></pre>"},{"location":"tutorials/actuators/tmotor_servo_setup/#verification","title":"Verification","text":"<p>To verify that the CAN interface is properly configured:</p> <pre><code># Check CAN interface status\nip link show can0\n\n# Monitor CAN traffic (optional)\ncandump can0\n</code></pre>"},{"location":"tutorials/actuators/tmotor_servo_setup/#motor-configuration","title":"Motor Configuration","text":""},{"location":"tutorials/actuators/tmotor_servo_setup/#supported-motors","title":"Supported Motors","text":"<ul> <li>AK80-9:</li> <li>Torque constant (Kt): 0.095 Nm/A (driver-compatible value for Delta winding)</li> <li>Gear ratio: 9:1</li> <li> <p>Pole pairs: 21</p> </li> <li> <p>AK10-9:</p> </li> <li>Torque constant (Kt): 0.206 Nm/A</li> <li>Gear ratio: 9:1</li> <li>Pole pairs: 21</li> </ul>"},{"location":"tutorials/actuators/tmotor_servo_setup/#understanding-torque-constant-kt-for-delta-wound-motors","title":"Understanding Torque Constant (Kt) for Delta-Wound Motors","text":""},{"location":"tutorials/actuators/tmotor_servo_setup/#background","title":"Background","text":"<p>The TMotor actuators use Delta-wound motors with CubeMars FOC drivers. There is a discrepancy between different torque constant (Kt) values:</p> <ul> <li>0.095 Nm/A - Driver-compatible Kt (what you should use in your code for AK80-9)</li> <li>0.14 Nm/A - CubeMars specification (power-invariant transform)</li> <li>0.163 Nm/A - Physical Kt from Back-EMF testing (amplitude-invariant transform)</li> </ul>"},{"location":"tutorials/actuators/tmotor_servo_setup/#the-root-cause-delta-vs-wye-windings","title":"The Root Cause: Delta vs Wye Windings","text":"<p>The CubeMars FOC driver defines current as follows:</p> <p>\"The definition of CubeMars' current: Amplitude of the line currents, which using the amplitude-invariant Clarke-Park transform is equivalent to the q-axis current.\"</p> <p>This definition only holds true for Wye-wound motors, where line current equals phase current. However, these motors use Delta winding, where:</p> <pre><code>Line Current (I_l) = \u221a3 \u00d7 Phase Current (I_\u03c6)\n</code></pre> <p>The standard amplitude-invariant Clarke-Park transform is built on phase current (I_\u03c6), but CubeMars sets their I_q equal to the line current amplitude. This causes the I_q value in their FOC driver to be inflated by a factor of \u221a3.</p>"},{"location":"tutorials/actuators/tmotor_servo_setup/#mathematical-analysis","title":"Mathematical Analysis","text":"<p>For a Delta winding motor:</p> <ol> <li> <p>Physical torque equation (from Back-EMF testing):    <pre><code>\u03c4 = Kt^\u03c6 \u00d7 I^\u03c6\nwhere Kt^\u03c6 = 0.163 Nm/A (true physical constant)\n</code></pre></p> </li> <li> <p>Driver torque equation (what CubeMars uses):    <pre><code>\u03c4 = Kt^drv \u00d7 I_q^drv\nwhere I_q^drv = I_l = \u221a3 \u00d7 I^\u03c6\n</code></pre></p> </li> <li> <p>Derivation of the relationship:    <pre><code>Kt^drv \u00d7 (\u221a3 \u00d7 I^\u03c6) = Kt^\u03c6 \u00d7 I^\u03c6\nKt^\u03c6 = \u221a3 \u00d7 Kt^drv\n\u221a3 \u00d7 0.095 \u2248 0.165 Nm/A \u2248 0.163 Nm/A \u2713\n</code></pre></p> </li> </ol> <p>This calculation matches the Back-EMF measurement.</p>"},{"location":"tutorials/actuators/tmotor_servo_setup/#why-use-0095-nma","title":"Why Use 0.095 Nm/A?","text":"<p>Use Kt = 0.095 Nm/A when working with CubeMars drivers and Delta-wound motors because:</p> <ol> <li>It matches the driver's current definition (line current amplitude)</li> <li>The FOC driver settings cannot be easily modified</li> <li>It provides the correct torque calculation when combined with the driver's current interpretation</li> </ol>"},{"location":"tutorials/actuators/tmotor_servo_setup/#practical-implications","title":"Practical Implications","text":"<p>Due to the CubeMars FOC driver settings:</p> <ul> <li>The driver's I_q value is \u221a3 times larger than the true phase current</li> <li>The maximum current limit is also \u221a3 times higher than the physical phase current</li> <li>The motor can be commanded with current values that are \u221a3 times higher than would be expected from the physical Kt (0.163 Nm/A)</li> </ul>"},{"location":"tutorials/actuators/tmotor_servo_setup/#summary-of-three-kt-values","title":"Summary of Three Kt Values","text":"Kt Value Transform Type Usage 0.163 Nm/A Amplitude-invariant (I_q = phase current) Physical/theoretical analysis 0.14 Nm/A Power-invariant (I_q^pwr = \u221a(3/2) \u00d7 I^\u03c6) CubeMars specification 0.095 Nm/A Driver-compatible (I_q = line current) Use this in your code <p>The three values are related by: <pre><code>Kt^\u03c6 = \u221a3 \u00d7 Kt^drv \u2248 1.732 \u00d7 0.095 \u2248 0.165 Nm/A\nKt^pwr = \u221a2 \u00d7 Kt^drv \u2248 1.414 \u00d7 0.095 \u2248 0.134 Nm/A\n</code></pre></p>"},{"location":"tutorials/actuators/tmotor_servo_setup/#control-modes","title":"Control Modes","text":"<p>The TMotor servo mode supports the following control modes:</p> <ol> <li>Position Control (Mode 4): Control motor position in degrees</li> <li>Velocity Control (Mode 3): Control motor velocity in ERPM</li> <li>Current Control (Mode 1): Control motor current in Amps</li> <li>Idle Mode (Mode 7): Motor idle state</li> </ol>"},{"location":"tutorials/actuators/tmotor_servo_setup/#usage-example","title":"Usage Example","text":"<pre><code>from opensourceleg.actuators.tmotor import TMotorServoActuator\n\n# Initialize motor\nmotor = TMotorServoActuator(\n    motor_id=104, #the default CAN ID is 104\n    gear_ratio=9.0,\n    motor_type=\"AK80-9\"\n)\n\n# Start motor\nmotor.start()\n\n# Home the motor\nmotor.home()\n\n# Set control mode\nmotor.set_control_mode(mode=CONTROL_MODES.POSITION)\n\n# Command position\nmotor.set_motor_position(position_rad=1.57)  # 90 degrees\n\n# Stop motor\nmotor.stop()\n</code></pre>"},{"location":"tutorials/actuators/tmotor_servo_setup/#troubleshooting","title":"Troubleshooting","text":""},{"location":"tutorials/actuators/tmotor_servo_setup/#can-bus-initialization-failed","title":"CAN Bus Initialization Failed","text":"<p>If you encounter a \"CAN bus initialization failed\" error:</p> <ol> <li>Ensure the CAN interface is properly configured (see CAN Interface Configuration above)</li> <li>Check that you have the necessary permissions (may require sudo)</li> <li>Verify the CAN hardware is connected</li> <li>Check for conflicting CAN bus processes</li> </ol>"},{"location":"tutorials/actuators/tmotor_servo_setup/#permission-denied","title":"Permission Denied","text":"<p>If you get permission errors when configuring the CAN interface:</p> <pre><code># Add your user to the dialout group\nsudo usermod -a -G dialout $USER\n\n# Logout and login again for changes to take effect\n</code></pre>"},{"location":"tutorials/actuators/tmotor_servo_setup/#can-interface-not-found","title":"CAN Interface Not Found","text":"<p>If <code>can0</code> is not found:</p> <ol> <li> <p>Check if CAN drivers are loaded:    <pre><code>lsmod | grep can\n</code></pre></p> </li> <li> <p>Load CAN drivers if needed:    <pre><code>sudo modprobe can\nsudo modprobe can_raw\nsudo modprobe vcan  # For virtual CAN (testing)\n</code></pre></p> </li> </ol>"},{"location":"tutorials/actuators/tmotor_servo_setup/#notes","title":"Notes","text":"<ul> <li>The CAN interface configuration must be done before initializing the TMotorServoActuator</li> <li>The interface configuration is not persistent across reboots</li> <li>For production use, consider adding the configuration to system startup scripts</li> <li>Always ensure proper grounding and shielding for CAN communication</li> <li>Unlike some motors, in this type the current reading only becomes negative when the velocity and torque directions are opposite.</li> </ul>"},{"location":"tutorials/control/compiled_controller/","title":"Compiled Controllers","text":"<p>The <code>opensourceleg.control</code> module provides functionality for using controllers written in languages other than Python via the <code>CompiledController</code> class. This class wraps a function from a compiled dynamic library and allows it to be called from your main Python code. Using a compiled controller written in another language can be beneficial, especially when speed is a concern.</p>"},{"location":"tutorials/control/compiled_controller/#make-an-example-library","title":"Make an Example Library","text":"<p>In this tutorial, we will write an example linear algebra library in <code>C++</code> that provides a function to compute the dot product between two 3D vectors. This very simple function will allow us to show how to define input and output structures and call the controller. The full script for this example is available at the end of this file. More complex examples using an actual Finite State Machine controller in both <code>C++</code> and MATLAB implementations are provided in the examples folder.</p> <p>The <code>CompiledController</code> class assumes that you have a compiled dynamic library (with extension <code>*.so</code> on Linux) with the function prototype <code>myFunction(Inputs* inputs, Outputs* outputs)</code>, where <code>Inputs</code> and <code>Outputs</code> are structures holding all of the input and output data. Thus, we first need to write and compile our library.</p> <pre><code>/** dot_product_3d.cpp\nAn example cpp file to demonstrate the compiled controller functionality\nin the opensourceleg library.\nKevin Best\nUniversity of Michigan\nOctober 2023\n**/\n\nstruct Vector3D{\n    double x, y, z;\n};\n\nstruct Inputs{\n    Vector3D vector1, vector2;\n};\n\nstruct Outputs{\n    double result;\n};\n\nextern \"C\" void dot_product_3d(Inputs* inputs, Outputs* Outputs) {\n  Outputs-&gt;result = inputs-&gt;vector1.x * inputs-&gt;vector2.x\n                    + inputs-&gt;vector1.y * inputs-&gt;vector2.y\n                    + inputs-&gt;vector1.z * inputs-&gt;vector2.z;\n}\n</code></pre> <p>Note: The <code>extern \"C\"</code> linkage-specification is important to prevent the <code>C++</code> compiler from name mangling. Under the hood, our library uses a <code>C</code> style calling convention, which expects to be able to find the library functions with their standard names.</p> <p>First, navigate to the directory <code>opensourceleg/tutorials/compiled_control/</code>. Then run <code>make</code> to build the library. If successful, a new library named <code>lin_alg.so</code> should be created.</p>"},{"location":"tutorials/control/compiled_controller/#load-the-example-library","title":"Load the Example Library","text":"<p>Next, we need to write a Python script to call our newly compiled library. First, we import the library. We also import <code>os</code> to get the path of the current directory.</p> <pre><code>import os\n\nfrom opensourceleg.control.compiled import CompiledController\n</code></pre> <p>Then we'll make an instance of the <code>CompiledController</code> wrapper and have it load our linear algebra library. We need to pass it both the name of the library (without an extension) and the directory in which to find the library. We also give it the name of our main function as well as any initialization and cleanup functions.</p> <pre><code>my_linalg = CompiledController(\n    library_name=\"lin_alg.so\",\n    library_path=os.path.dirname(__file__),\n    main_function_name=\"dot_product_3d\",\n    initialization_function_name=None,\n    cleanup_function_name=None,\n)\n</code></pre> <p>Note:  If your library provides initialization and cleanup functions, they will be called upon loading and cleanup, respectively. If your library does not need these functions, pass the default argument of <code>None</code>.</p>"},{"location":"tutorials/control/compiled_controller/#define-custom-datatypes","title":"Define Custom Datatypes","text":"<p>Our library uses a <code>Vector3D</code> structure, which we need to define so that the python code can pass the data to the library in the right format. Every structure is built using basic types from <code>my_linalg.types</code>, such as <code>c_double</code>, <code>c_bool</code>, <code>c_int16</code>, etc. We therefore can add <code>Vector3D</code> to the list of known types using the <code>define_type()</code> method, which takes two arguments: (1) a name of the new type definition, and (2) a list of tuples where the first entry is the name of the field and the second entry is the type. For example, the code to define <code>Vector3D</code> is</p> <pre><code>my_linalg.define_type(\n    \"Vector3D\",\n    [\n        (\"x\", my_linalg.types.c_double),\n        (\"y\", my_linalg.types.c_double),\n        (\"z\", my_linalg.types.c_double),\n    ],\n)\n</code></pre> <p>Now the wrapper knows how <code>Vector3D</code> is defined, we can use it in other type definitions, the same way as any other basic type. After all necessary types are defined, we need to define the input and output structures using the <code>define_inputs()</code> and <code>define_outputs()</code> methods. These methods are similar to <code>define_type()</code>, but are special because they tell the wrapper which objects to pass to and from the compiled library. We define the inputs as two <code>Vector3D</code> objects and the output as one double titled result.</p>"},{"location":"tutorials/control/compiled_controller/#option-1-using-lists-recommended-for-simple-structures","title":"Option 1: Using Lists (Recommended for Simple Structures)","text":"<pre><code>my_linalg.define_inputs(input_list=[(\"vector1\", my_linalg.types.Vector3D), (\"vector2\", my_linalg.types.Vector3D)])\nmy_linalg.define_outputs(output_list=[(\"result\", my_linalg.types.c_double)])\n</code></pre>"},{"location":"tutorials/control/compiled_controller/#option-2-using-ctypesstructure-classes-recommended-for-complex-structures","title":"Option 2: Using ctypes.Structure Classes (Recommended for Complex Structures)","text":"<p>Alternatively, you can define custom <code>ctypes.Structure</code> classes and pass them directly to <code>define_inputs()</code> and <code>define_outputs()</code>. This approach is useful when you have complex nested structures that you want to define once and reuse:</p> <pre><code># Define custom ctypes structures\nclass Vector3D(ctypes.Structure):\n    _fields_ = [\n        (\"x\", ctypes.c_double),\n        (\"y\", ctypes.c_double),\n        (\"z\", ctypes.c_double),\n    ]\n\nclass InputsType(ctypes.Structure):\n    _fields_ = [\n        (\"vector1\", Vector3D),\n        (\"vector2\", Vector3D),\n    ]\n\nclass OutputsType(ctypes.Structure):\n    _fields_ = [\n        (\"result\", ctypes.c_double),\n    ]\n\n# Pass the classes directly to define_inputs and define_outputs\nmy_linalg.define_inputs(InputsType)\nmy_linalg.define_outputs(OutputsType)\n</code></pre> <p>Both approaches are functionally equivalent. Choose the one that best fits your code style and complexity needs.</p>"},{"location":"tutorials/control/compiled_controller/#populate-inputs-and-test-the-function","title":"Populate Inputs and Test the Function","text":"<p>Now that the input structure has been defined, we can write to the inputs structure at <code>my_linalg.inputs</code>. First, we declare two vectors and populate their fields with the appropriate values.</p> <pre><code>vector1 = my_linalg.types.Vector3D()\nvector2 = my_linalg.types.Vector3D()\n\nvector1.x = 0.6651\nvector1.y = 0.7395\nvector1.z = 0.1037\nvector2.x = -0.7395\nvector2.y = 0.6716\nvector2.z = -0.0460\n</code></pre> <p>Then we can assign those vectors to the input structure.</p> <pre><code>my_linalg.inputs.vector1 = vector1\nmy_linalg.inputs.vector2 = vector2\n</code></pre> <p>Finally, we can run the dot product function and print the result from the output structure. As our input vectors were orthogonal, we get the expected result of zero.</p> <pre><code>outputs = my_linalg.run()\n\nprint(f\"Dot product: {outputs.result}\")\n</code></pre> <p>We get the following output, showing that our compiled library successfully calculated the dot product between our two orthogonal vectors: <pre><code>Dot product: 3.6549999999971154e-05\n</code></pre></p>"},{"location":"tutorials/control/compiled_controller/#full-code-for-this-tutorial","title":"Full Code for This Tutorial","text":"<pre><code>import os\n\nfrom opensourceleg.control.compiled import CompiledController\n\nmy_linalg = CompiledController(\n    library_name=\"lin_alg.so\",\n    library_path=os.path.dirname(__file__),\n    main_function_name=\"dot_product_3d\",\n    initialization_function_name=None,\n    cleanup_function_name=None,\n)\n\nmy_linalg.define_type(\n    \"Vector3D\",\n    [\n        (\"x\", my_linalg.types.c_double),\n        (\"y\", my_linalg.types.c_double),\n        (\"z\", my_linalg.types.c_double),\n    ],\n)\nmy_linalg.define_inputs(input_list=[(\"vector1\", my_linalg.types.Vector3D), (\"vector2\", my_linalg.types.Vector3D)])\nmy_linalg.define_outputs(output_list=[(\"result\", my_linalg.types.c_double)])\n\nvector1 = my_linalg.types.Vector3D()\nvector2 = my_linalg.types.Vector3D()\n\nvector1.x = 0.6651\nvector1.y = 0.7395\nvector1.z = 0.1037\nvector2.x = -0.7395\nvector2.y = 0.6716\nvector2.z = -0.0460\n\nmy_linalg.inputs.vector1 = vector1\nmy_linalg.inputs.vector2 = vector2\n\noutputs = my_linalg.run()\n\nprint(f\"Dot product: {outputs.result}\")\n</code></pre>"},{"location":"tutorials/control/state_machine/","title":"State Machine Tutorial - Robot Vaccum","text":"<p>The <code>opensourceleg.control</code> module provides functionality for creating and managing finite state machines (FSMs) via the <code>StateMachine</code> class. This tutorial walks you through the implementation of a simple state machine for a robot vaccum cleaner using the <code>finite_state_machine.py</code> example.</p>"},{"location":"tutorials/control/state_machine/#overview","title":"Overview","text":"<p>This tutorial demonstrates how to define states, transitions, and criteria for switching between states using the <code>StateMachine</code> class.</p>"},{"location":"tutorials/control/state_machine/#define-transition-criteria","title":"Define Transition Criteria","text":"<p>First, we define the transition criteria of the FSM after importing the pertinent classes. These are functions that return a boolean value based on some condition. You can define any arguments you like, so here we will use the <code>battery_level</code> to determine when to switch states.</p> <pre><code>from opensourceleg.control.fsm import State, StateMachine\nfrom opensourceleg.logging.logger import Logger\nfrom opensourceleg.utilities import SoftRealtimeLoop\n\n\n# Transition criteria functions\ndef cleaning_to_docking(battery_level: float) -&gt; bool:\n    \"\"\"\n    Transition from 'Cleaning' to 'Docking' when the battery level is below 20%.\n    \"\"\"\n    return battery_level &lt; 20\n\n\ndef charging_to_cleaning(battery_level: float) -&gt; bool:\n    \"\"\"\n    Transition from 'Charging' to 'Cleaning' when the battery is fully charged (100%).\n    \"\"\"\n    return battery_level == 100\n</code></pre>"},{"location":"tutorials/control/state_machine/#define-states-and-state-machine","title":"Define States and State Machine","text":"<p>Next, we define three states for our system: cleaning, charging, and docking. For the docking state, we assume that it takes 10 seconds to go from anywhere in the room to the docking station. We add each of the states as a list to a new instance of the <code>StateMachine</code> module and set the docking state as the initial state.</p> <pre><code>    # Define states\n    cleaning_s = State(name=\"Cleaning\")  # State for cleaning\n    charging_s = State(name=\"Charging\")  # State for charging\n    docking_s = State(name=\"Docking\", minimum_time_in_state=10)  # State for docking, assuming it takes 10 seconds\n\n    # Initialize the state machine with the defined states and the initial state\n    fsm = StateMachine(states=[charging_s, cleaning_s, docking_s], initial_state_name=charging_s.name)\n</code></pre>"},{"location":"tutorials/control/state_machine/#add-transitions-between-states","title":"Add Transitions Between States","text":"<p>Now that the state machine is built, we need to link the states with transitions. We do this using the <code>add_transition()</code> method. Transitions specify the conditions under which the FSM moves from one state to another. Each transition includes:</p> <ul> <li>A source state</li> <li>A destination state</li> <li>An event name</li> <li>A criteria (a function that returns <code>True</code> when the transition should occur)</li> </ul> <pre><code>    # Add transitions between states\n    fsm.add_transition(\n        source=charging_s,\n        destination=cleaning_s,\n        event_name=\"Fully Charged - Beginning Cleaning\",\n        criteria=charging_to_cleaning,\n    )\n    fsm.add_transition(\n        source=cleaning_s,\n        destination=docking_s,\n        event_name=\"Battery Low - Finding Charging Dock\",\n        criteria=cleaning_to_docking,\n    )\n    fsm.add_transition(source=docking_s, destination=charging_s, event_name=\"Docked - Beginning Charging\")\n\n    # Initialize the battery level\n    battery_level = 50.0  # Start with 50% battery\n</code></pre>"},{"location":"tutorials/control/state_machine/#main-loop","title":"Main Loop","text":"<p>We initialize the FSM inside a <code>with</code> context and create an instance of <code>SoftRealtimeLoop</code> to simulate our state machine. Each time through the loop, we call <code>fsm.update(battery_level=battery_level)</code>, which provides the appropriate inputs to the transition functions.</p> <pre><code>    # Run the state machine in a soft real-time loop\n    with fsm:\n        for _t in SoftRealtimeLoop(dt=0.5):  # Loop with a time step of 0.5 seconds\n            # Simulate battery behavior based on the current state\n            if fsm.current_state == charging_s:\n                # Battery charges by 2% per loop iteration\n                battery_level += 2.0\n            elif fsm.current_state == cleaning_s:\n                # Battery drains by 5% per loop iteration during cleaning\n                battery_level -= 5.0\n            else:\n                # Battery drains slowly (0.5%) while docking\n                battery_level -= 0.5\n\n            # Clamp the battery level between 0% and 100%\n            battery_level = min(100, max(battery_level, 0))\n\n            # Update the state machine with the current battery level\n            fsm.update(battery_level=battery_level)\n\n            # Log the current state and battery level\n            fsm_example_logger.info(f\"Current state: {fsm.current_state.name}; Battery level: {battery_level}; \")\n</code></pre>"},{"location":"tutorials/control/state_machine/#example-output","title":"Example Output","text":"<p>When running the example, you can expect the following behavior:</p> <ol> <li>The FSM starts in the <code>Charging</code> state.</li> <li>Once the battery is fully charged, it transitions to the <code>Cleaning</code> state.</li> <li>When the battery level drops below 20%, it transitions to the <code>Docking</code> state.</li> <li>After docking, it transitions back to the <code>Charging</code> state.</li> </ol> <p>This cycle repeats indefinitely, simulating the behavior of the robot vacuum cleaner.</p>"},{"location":"tutorials/control/state_machine/#full-script-for-this-tutorial","title":"Full Script for This Tutorial","text":"<pre><code>from opensourceleg.control.fsm import State, StateMachine\nfrom opensourceleg.logging.logger import Logger\nfrom opensourceleg.utilities import SoftRealtimeLoop\n\n\n# Transition criteria functions\ndef cleaning_to_docking(battery_level: float) -&gt; bool:\n    \"\"\"\n    Transition from 'Cleaning' to 'Docking' when the battery level is below 20%.\n    \"\"\"\n    return battery_level &lt; 20\n\n\ndef charging_to_cleaning(battery_level: float) -&gt; bool:\n    \"\"\"\n    Transition from 'Charging' to 'Cleaning' when the battery is fully charged (100%).\n    \"\"\"\n    return battery_level == 100\n\n\n# Main function\nif __name__ == \"__main__\":\n    # Initialize the logger for the finite state machine\n    fsm_example_logger = Logger(\n        log_path=\"./logs\",  # Directory to store logs\n        file_name=\"fsm.log\",  # Log file name\n    )\n\n    # Define states\n    cleaning_s = State(name=\"Cleaning\")  # State for cleaning\n    charging_s = State(name=\"Charging\")  # State for charging\n    docking_s = State(name=\"Docking\", minimum_time_in_state=10)  # State for docking, assuming it takes 10 seconds\n\n    # Initialize the state machine with the defined states and the initial state\n    fsm = StateMachine(states=[charging_s, cleaning_s, docking_s], initial_state_name=charging_s.name)\n\n    # Add transitions between states\n    fsm.add_transition(\n        source=charging_s,\n        destination=cleaning_s,\n        event_name=\"Fully Charged - Beginning Cleaning\",\n        criteria=charging_to_cleaning,\n    )\n    fsm.add_transition(\n        source=cleaning_s,\n        destination=docking_s,\n        event_name=\"Battery Low - Finding Charging Dock\",\n        criteria=cleaning_to_docking,\n    )\n    fsm.add_transition(source=docking_s, destination=charging_s, event_name=\"Docked - Beginning Charging\")\n\n    # Initialize the battery level\n    battery_level = 50.0  # Start with 50% battery\n\n    # Run the state machine in a soft real-time loop\n    with fsm:\n        for _t in SoftRealtimeLoop(dt=0.5):  # Loop with a time step of 0.5 seconds\n            # Simulate battery behavior based on the current state\n            if fsm.current_state == charging_s:\n                # Battery charges by 2% per loop iteration\n                battery_level += 2.0\n            elif fsm.current_state == cleaning_s:\n                # Battery drains by 5% per loop iteration during cleaning\n                battery_level -= 5.0\n            else:\n                # Battery drains slowly (0.5%) while docking\n                battery_level -= 0.5\n\n            # Clamp the battery level between 0% and 100%\n            battery_level = min(100, max(battery_level, 0))\n\n            # Update the state machine with the current battery level\n            fsm.update(battery_level=battery_level)\n\n            # Log the current state and battery level\n            fsm_example_logger.info(f\"Current state: {fsm.current_state.name}; Battery level: {battery_level}; \")\n</code></pre>"},{"location":"tutorials/control/torque_trajectory/","title":"Torque Trajectory Control Tutorial","text":"<p>This <code>opensourceleg.control</code> module provides functiionality for doing torque control. This tutorial demonstrates how to control the Open Source Leg (OSL) using torque trajectories for both the knee and ankle joints.</p>"},{"location":"tutorials/control/torque_trajectory/#warnings","title":"Warnings:","text":"<ol> <li>This example is not meant to be used as a walking controller. The goal of this example is to provide a reference for how a torque trajectory can be loaded and commanded.</li> <li>While runnig this script make sure to have load on the actuators.</li> <li>Please be cautious while changing mass parameters.</li> </ol>"},{"location":"tutorials/control/torque_trajectory/#overview","title":"Overview","text":"<p>The script implements a torque control system that:</p> <ol> <li>Loads pre-defined torque trajectories for knee and ankle joints</li> <li>Applies these trajectories in a cyclic manner</li> <li>Logs the performance data</li> <li>Generates visualization plots</li> </ol>"},{"location":"tutorials/control/torque_trajectory/#prerequisites","title":"Prerequisites","text":"<ul> <li>OpenSourceLeg hardware setup</li> <li> <p>Python environment with required dependencies:</p> <ul> <li>numpy</li> <li>matplotlib</li> </ul> </li> <li> <p>Access to torque trajectory files:</p> <ul> <li><code>ankle.pkl</code></li> <li><code>knee.pkl</code></li> </ul> </li> </ul>"},{"location":"tutorials/control/torque_trajectory/#command-line-arguments","title":"Command Line Arguments","text":"<p>The script accepts the following command line arguments:</p> <ul> <li><code>--mass</code>: User mass in kg (default: 1.0)</li> <li><code>--stride-time</code>: Stride time in seconds (default: 1.0)</li> <li><code>--frequency</code>: Control loop frequency in Hz (default: 200.0)</li> </ul>"},{"location":"tutorials/control/torque_trajectory/#key-parameters","title":"Key Parameters","text":"<ul> <li><code>USER_MASS</code>: The mass of the user in kg (configurable via command line)</li> <li><code>STRIDE_TIME</code>: The stride time in seconds (configurable via command line)</li> <li><code>FREQUENCY</code>: The control loop frequency in Hz (configurable via command line)</li> <li><code>TRAJECTORY_LEN</code>: Fixed at 150 points. This is the length of the torque trajectories in the ankle.pkl and knee.pkl files.</li> <li><code>GEAR_RATIO</code>: Set to 9 * (83/18)</li> </ul>"},{"location":"tutorials/control/torque_trajectory/#hardware-configuration","title":"Hardware Configuration","text":"<p>The script configures two DephyActuators and two AS5048B encoders:</p> <ol> <li> <p>Actuators:</p> <ul> <li>Knee actuator (port=<code>/dev/ttyACM0</code>)</li> <li>Ankle actuator (port=<code>/dev/ttyACM1</code>)</li> </ul> </li> </ol> <p>Both configured with:</p> <pre><code>  - Specified gear ratio\n  - User-defined frequency\n  - Dephy logging disabled\n</code></pre> <ol> <li> <p>Encoders:</p> <ul> <li>Knee joint encoder (bus=1, A1=True, A2=False)</li> <li>Ankle joint encoder (bus=1, A1=False, A2=True)</li> </ul> </li> </ol>"},{"location":"tutorials/control/torque_trajectory/#functions","title":"Functions","text":""},{"location":"tutorials/control/torque_trajectory/#get-torque","title":"Get Torque","text":"<pre><code>from opensourceleg.utilities import SoftRealtimeLoop\n\nANKLE_TRAJECTORY_PATH = \"./ankle.pkl\"\nKNEE_TRAJECTORY_PATH = \"./knee.pkl\"\n\n\ndef get_torque(t: float, data: list, user_mass: float, stride_time: float, trajectory_len: int) -&gt; int:\n    \"\"\"Calculate the torque setpoint for a given time point in the trajectory.\n\n    Args:\n        t (float): Current time in seconds\n        data (list): List containing the torque trajectory data points\n        user_mass (float): The mass of the user in kg\n        stride_time (float): The stride time in seconds\n        trajectory_len (int): The length of the trajectory\n\n    Returns:\n        int: Torque setpoint scaled by user mass\n\n    The function:\n    1. Calculates walking_time by taking modulo of current time with stride_time\n</code></pre> <p>Calculates the torque setpoint for a given time point:</p> <ul> <li><code>t</code>: Current time in seconds</li> <li><code>data</code>: List containing torque trajectory data points</li> <li><code>user_mass</code>: Mass of the user in kg</li> <li><code>stride_time</code>: Stride time in seconds</li> <li><code>trajectory_len</code>: Length of the trajectory</li> </ul> <p>Returns torque setpoint scaled by user mass</p>"},{"location":"tutorials/control/torque_trajectory/#plot-data","title":"Plot Data","text":"<pre><code>    \"\"\"\n    walking_time = t % stride_time\n    index = int(walking_time * trajectory_len)\n    return user_mass * data[index]\n\n\ndef plot_data(plotting_data: list) -&gt; None:\n    try:\n        import matplotlib.pyplot as plt\n    except ImportError:\n        print(\"matplotlib is not installed, skipping plot\")\n        return\n\n    # plot the data using matplotlib\n    plt.figure(figsize=(12, 10))\n\n    # Create three subplots for better visualization\n    # Ankle Torque\n    plt.subplot(3, 1, 1)\n    plt.plot(plotting_data[0], plotting_data[1], label=\"Ankle Torque Set Point\")\n    plt.plot(plotting_data[0], plotting_data[3], label=\"Ankle Joint Torque\")\n    plt.xlabel(\"Time (s)\")\n    plt.ylabel(\"Torque (Nm)\")\n    plt.title(\"Ankle Torque Trajectory\")\n    plt.legend()\n    plt.grid(True)\n\n    # Knee Torque\n    plt.subplot(3, 1, 2)\n    plt.plot(plotting_data[0], plotting_data[2], label=\"Knee Torque Set Point\")\n    plt.plot(plotting_data[0], plotting_data[4], label=\"Knee Joint Torque\")\n    plt.xlabel(\"Time (s)\")\n    plt.ylabel(\"Torque (Nm)\")\n    plt.title(\"Knee Torque Trajectory\")\n    plt.legend()\n    plt.grid(True)\n\n    # Joint Positions\n    plt.subplot(3, 1, 3)\n    plt.plot(plotting_data[0], np.rad2deg(plotting_data[5]), label=\"Knee Position\")\n    plt.plot(plotting_data[0], np.rad2deg(plotting_data[6]), label=\"Ankle Position\")\n    plt.xlabel(\"Time (s)\")\n    plt.ylabel(\"Joint Position (deg)\")\n    plt.title(\"Joint Positions\")\n</code></pre> <p>Generates three plots:</p> <ol> <li>Ankle torque (setpoint vs. actual)</li> <li>Knee torque (setpoint vs. actual)</li> <li>Joint positions (knee and ankle in degrees)</li> </ol> <p>Saves the plot as <code>plot.png</code></p>"},{"location":"tutorials/control/torque_trajectory/#operation-flow","title":"Operation Flow","text":"<ol> <li> <p>Initialization:</p> <ul> <li>Parses command line arguments</li> <li>Sets up logging with specified frequency</li> <li>Configures actuators and sensors</li> <li>Loads trajectory data from pickle files</li> </ul> </li> <li> <p>Control Sequence:</p> <ul> <li>Homes the OSL</li> <li>Sets control mode to CURRENT for both actuators</li> <li>Sets current gains</li> <li>Waits for user input</li> <li>Executes torque trajectory</li> <li>Logs performance data</li> </ul> </li> <li> <p>Visualization:</p> <ul> <li>Generates plots after completion</li> <li>Saves plots to \"plot.png\"</li> </ul> </li> </ol>"},{"location":"tutorials/control/torque_trajectory/#usage","title":"Usage","text":"<ol> <li> <p>Ensure trajectory files (<code>ankle.pkl</code> and <code>knee.pkl</code>) are in the working directory.    We have provided a sample trajectory file in the <code>tutorials/control/torque_trajectory/</code> directory for both the ankle and knee joints.    These trajectories are output of an high-level controller (not provided here) for level walking.    The torque trajectories present the joint torque setpoints for one gait cycle, and the units are in Nm/kg.</p> </li> <li> <p>Run the script with optional arguments:    <pre><code>python torque_trajectory.py --mass 10 --stride-time 1 --frequency 200\n</code></pre></p> </li> <li>Press Enter when prompted to start the walking trajectory</li> <li>The system will execute the trajectory and generate plots upon completion</li> </ol>"},{"location":"tutorials/control/torque_trajectory/#safety-notes","title":"Safety Notes","text":"<ul> <li>This example is not meant to be used as a walking controller</li> <li>Please be cautious while changing mass parameters</li> <li>Ensure all connections are secure before operation</li> <li>Keep emergency stop accessible during operation</li> </ul>"},{"location":"tutorials/control/torque_trajectory/#output","title":"Output","text":"<p>The script generates:</p> <ol> <li>Real-time logs in the <code>./logs</code> directory with filename \"torque_trajectory\"</li> <li> <p>A plot file (<code>plot.png</code>) showing:</p> <ul> <li>Torque trajectories for both joints</li> <li>Actual vs. commanded torques</li> <li>Joint position data in degrees</li> </ul> </li> </ol>"},{"location":"tutorials/control/torque_trajectory/#full-script-for-this-tutorial","title":"Full Script for this tutorial","text":"<p><pre><code>\"\"\"\nThis example demonstrates how torque trajectories can be loaded and commanded on the Open Source Leg (OSL).\nThis is not a walking controller.\n\nAuthors: Senthur Raj Ayyappan &lt;senthura@umich.edu&gt;, Varun Satyadev Shetty &lt;vashetty@umich.edu&gt;\nNeurobionics Lab\nRobotics Department\nUniversity of Michigan\nMarch 25th, 2025\n\"\"\"\n\nimport argparse\nimport pickle\n\nimport numpy as np\n\nfrom opensourceleg.actuators import CONTROL_MODES\nfrom opensourceleg.actuators.dephy import DephyActuator\nfrom opensourceleg.logging import Logger\nfrom opensourceleg.robots.osl import OpenSourceLeg\nfrom opensourceleg.sensors.encoder import AS5048B\nfrom opensourceleg.utilities import SoftRealtimeLoop\n\nANKLE_TRAJECTORY_PATH = \"./ankle.pkl\"\nKNEE_TRAJECTORY_PATH = \"./knee.pkl\"\n\n\ndef get_torque(t: float, data: list, user_mass: float, stride_time: float, trajectory_len: int) -&gt; int:\n    \"\"\"Calculate the torque setpoint for a given time point in the trajectory.\n\n    Args:\n        t (float): Current time in seconds\n        data (list): List containing the torque trajectory data points\n        user_mass (float): The mass of the user in kg\n        stride_time (float): The stride time in seconds\n        trajectory_len (int): The length of the trajectory\n\n    Returns:\n        int: Torque setpoint scaled by user mass\n\n    The function:\n    1. Calculates walking_time by taking modulo of current time with stride_time\n    2. Converts walking_time to trajectory index based on trajectory_len\n    3. Returns torque value at that index scaled by user_mass\n    \"\"\"\n    walking_time = t % stride_time\n    index = int(walking_time * trajectory_len)\n    return user_mass * data[index]\n\n\ndef plot_data(plotting_data: list) -&gt; None:\n    try:\n        import matplotlib.pyplot as plt\n    except ImportError:\n        print(\"matplotlib is not installed, skipping plot\")\n        return\n\n    # plot the data using matplotlib\n    plt.figure(figsize=(12, 10))\n\n    # Create three subplots for better visualization\n    # Ankle Torque\n    plt.subplot(3, 1, 1)\n    plt.plot(plotting_data[0], plotting_data[1], label=\"Ankle Torque Set Point\")\n    plt.plot(plotting_data[0], plotting_data[3], label=\"Ankle Joint Torque\")\n    plt.xlabel(\"Time (s)\")\n    plt.ylabel(\"Torque (Nm)\")\n    plt.title(\"Ankle Torque Trajectory\")\n    plt.legend()\n    plt.grid(True)\n\n    # Knee Torque\n    plt.subplot(3, 1, 2)\n    plt.plot(plotting_data[0], plotting_data[2], label=\"Knee Torque Set Point\")\n    plt.plot(plotting_data[0], plotting_data[4], label=\"Knee Joint Torque\")\n    plt.xlabel(\"Time (s)\")\n    plt.ylabel(\"Torque (Nm)\")\n    plt.title(\"Knee Torque Trajectory\")\n    plt.legend()\n    plt.grid(True)\n\n    # Joint Positions\n    plt.subplot(3, 1, 3)\n    plt.plot(plotting_data[0], np.rad2deg(plotting_data[5]), label=\"Knee Position\")\n    plt.plot(plotting_data[0], np.rad2deg(plotting_data[6]), label=\"Ankle Position\")\n    plt.xlabel(\"Time (s)\")\n    plt.ylabel(\"Joint Position (deg)\")\n    plt.title(\"Joint Positions\")\n    plt.legend()\n    plt.grid(True)\n\n    plt.tight_layout()\n    plt.savefig(\"plot.png\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    # Set up argument parser\n    parser = argparse.ArgumentParser(description=\"Torque trajectory control for Open Source Leg\")\n    parser.add_argument(\"--mass\", type=float, default=1.0, help=\"User mass in kg (default: 1.0)\", required=False)\n    parser.add_argument(\n        \"--stride-time\", type=float, default=1, help=\"Stride time in seconds (default: 1)\", required=False\n    )\n    parser.add_argument(\n        \"--frequency\", type=float, default=200.0, help=\"Control loop frequency in Hz (default: 200.0)\", required=False\n    )\n\n    # Parse arguments\n    args = parser.parse_args()\n\n    # Set global parameters from arguments\n    USER_MASS = args.mass\n    STRIDE_TIME = args.stride_time\n    FREQUENCY = args.frequency\n\n    # Fixed parameters\n    TRAJECTORY_LEN = 150\n    GEAR_RATIO = 9 * (83 / 18)\n\n    torque_logger = Logger(log_path=\"./logs\", file_name=\"torque_trajectory\")\n    clock = SoftRealtimeLoop(dt=1 / FREQUENCY)\n\n    actuators = {\n        \"knee\": DephyActuator(\n            tag=\"knee\",\n            port=\"/dev/ttyACM0\",\n            gear_ratio=GEAR_RATIO,\n            frequency=FREQUENCY,\n            dephy_log=False,\n        ),\n        \"ankle\": DephyActuator(\n            tag=\"ankle\",\n            port=\"/dev/ttyACM1\",\n            gear_ratio=GEAR_RATIO,\n            frequency=FREQUENCY,\n            dephy_log=False,\n        ),\n    }\n\n    sensors = {\n        \"joint_encoder_knee\": AS5048B(\n            tag=\"joint_encoder_knee\",\n            bus=1,\n            A1_adr_pin=True,\n            A2_adr_pin=False,\n            zero_position=0,\n            enable_diagnostics=False,\n        ),\n        \"joint_encoder_ankle\": AS5048B(\n            tag=\"joint_encoder_ankle\",\n            bus=1,\n            A1_adr_pin=False,\n            A2_adr_pin=True,\n            zero_position=0,\n            enable_diagnostics=False,\n        ),\n    }\n\n    osl = OpenSourceLeg(\n        tag=\"osl\",\n        actuators=actuators,\n        sensors=sensors,\n    )\n\n    plotting_data = [\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n    ]  # Time, ankle_sp, knee_sp, ankle_torque, knee_torque, knee_pos, ankle_pos\n\n    with open(ANKLE_TRAJECTORY_PATH, \"rb\") as f:\n        ankle_data = pickle.load(f)  # noqa: S301\n\n    with open(KNEE_TRAJECTORY_PATH, \"rb\") as f:\n        knee_data = pickle.load(f)  # noqa: S301\n\n    with osl:\n        osl.home()\n\n        osl.knee.set_control_mode(CONTROL_MODES.CURRENT)\n        osl.knee.set_current_gains()\n        osl.knee.set_output_torque(0)\n\n        osl.ankle.set_control_mode(CONTROL_MODES.CURRENT)\n        osl.ankle.set_current_gains()\n        osl.ankle.set_output_torque(0)\n\n        input(\"Press Enter to start walking\")\n\n        for t in clock:\n            osl.update()\n\n            ankle_torque_sp = get_torque(t, ankle_data, USER_MASS, STRIDE_TIME, TRAJECTORY_LEN)\n            knee_torque_sp = get_torque(t, knee_data, USER_MASS, STRIDE_TIME, TRAJECTORY_LEN)\n\n            osl.ankle.set_output_torque(ankle_torque_sp)\n            osl.knee.set_output_torque(knee_torque_sp)\n\n            torque_logger.info(\n                f\"t: {t}, ankle_torque_sp: {ankle_torque_sp}, knee_torque_sp: {knee_torque_sp}, \"\n                f\"ankle_output_torque: {osl.ankle.output_torque}, \"\n                f\"knee_output_torque: {osl.knee.output_torque} \"\n                f\"knee_position: {osl.knee.output_position}, ankle_position: {osl.ankle.output_position}\"\n            )\n            plotting_data[0].append(t)\n            plotting_data[1].append(ankle_torque_sp)\n            plotting_data[2].append(knee_torque_sp)\n            plotting_data[3].append(osl.ankle.output_torque)\n</code></pre> If you have any questions or need further assistance, please post on the Open Source Leg community forum.</p>"},{"location":"tutorials/logging/configuring_logger/","title":"Configuring the Logger","text":"<p>This guide covers the various ways to configure the Logger for your needs. All examples can be found in the <code>configuring_logger.py</code> script.</p>"},{"location":"tutorials/logging/configuring_logger/#initial-setup","title":"Initial Setup","text":""},{"location":"tutorials/logging/configuring_logger/#basic-configuration","title":"Basic Configuration","text":"<p>The Logger can be initialized with several basic parameters that control its behavior. This configuration sets up both file and console logging, with different verbosity levels for each output. The <code>log_path</code> specifies where log files are stored, while <code>file_name</code> determines the base name for log files. The <code>buffer_size</code> parameter helps optimize performance by controlling how frequently logs are written to disk.</p> <pre><code>    logger = Logger(\n        log_path=\"./logs\",  # Log file directory\n        file_name=\"experiment_1\",  # Base name for log files\n        log_format=\"[%(asctime)s] %(levelname)s: %(message)s\",\n        file_level=LogLevel.DEBUG,  # Level for file logging\n        stream_level=LogLevel.INFO,  # Level for console output\n        buffer_size=1000,  # Entries before auto-flush\n        enable_csv_logging=True,  # Enable/disable CSV logging\n    )\n    print(f\"Logger configured with buffer size: {logger.buffer_size}\")\n</code></pre>"},{"location":"tutorials/logging/configuring_logger/#log-levels","title":"Log Levels","text":"<p>Log levels help you control the verbosity of your logging output. You can set different levels for file logging and console output, allowing you to have detailed logs in your files while keeping console output focused on more important messages.</p> <p>The levels range from <code>DEBUG</code> (most verbose) to <code>CRITICAL</code> (most severe), giving you fine-grained control over what gets logged.</p> <pre><code>    print(\"\\n=== Log Levels Example ===\")\n    logger = Logger()\n    # Available log levels (in order of severity):\n    # - LogLevel.DEBUG    - Detailed debugging information\n    # - LogLevel.INFO     - General information\n    # - LogLevel.WARNING  - Warning messages\n    # - LogLevel.ERROR    - Error messages\n    # - LogLevel.CRITICAL - Critical errors\n    logger.set_file_level(LogLevel.DEBUG)  # More detailed file logging\n    logger.set_stream_level(LogLevel.INFO)  # Less console spam\n    print(f\"File level set to: {logger.file_level}\")\n</code></pre>"},{"location":"tutorials/logging/configuring_logger/#file-management","title":"File Management","text":"<p>The Logger includes built-in file management capabilities to help maintain your log files. You can configure file rotation based on size limits and specify how many backup files to keep. This prevents log files from growing too large and consuming excessive disk space while maintaining a history of recent logs.</p> <pre><code>    print(\"\\n=== File Management Example ===\")\n    # Configure logger with file rotation settings\n    logger = Logger(\n        file_max_bytes=1024 * 1024,  # 1MB max file size\n        file_backup_count=5,  # Keep 5 backup files\n    )\n</code></pre>"},{"location":"tutorials/logging/configuring_logger/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"tutorials/logging/configuring_logger/#custom-formatting","title":"Custom Formatting","text":"<p>The Logger supports customizable log message formatting, allowing you to include various pieces of information in each log entry. You can include timestamps, log levels, file names, line numbers, and function names in your log messages. This flexibility helps you create log outputs that match your debugging and monitoring needs.</p> <pre><code>def custom_formatting():\n    \"\"\"Demonstrates custom format string configuration.\"\"\"\n    print(\"\\n=== Custom Formatting Example ===\")\n    logger = Logger()\n    # Available format variables:\n    # %(asctime)s     - Timestamp\n    # %(levelname)s   - Log level\n    # %(message)s     - Log message\n    # %(filename)s    - Source filename\n    # %(lineno)d     - Line number\n</code></pre>"},{"location":"tutorials/logging/configuring_logger/#buffer-management","title":"Buffer Management","text":"<p>Buffer management allows you to optimize the Logger's performance by controlling when logs are written to disk. A larger buffer size reduces I/O operations but increases the amount of memory used. You can also manually flush the buffer when needed, ensuring critical logs are written immediately.</p> <pre><code>def buffer_management():\n    \"\"\"Demonstrates buffer size configuration and manual flushing.\"\"\"\n    print(\"\\n=== Buffer Management Example ===\")\n    # Configure logger with custom buffer settings\n    logger = Logger(\n        buffer_size=500,  # Flush every 500 entries\n        enable_csv_logging=True,  # Enable CSV output\n</code></pre>"},{"location":"tutorials/logging/configuring_logger/#common-configurations","title":"Common Configurations","text":""},{"location":"tutorials/logging/configuring_logger/#debug-configuration","title":"Debug Configuration","text":"<p>This configuration is optimized for development and debugging scenarios. It enables detailed logging both to file and console, including source file information and line numbers. This helps developers track down issues and understand the flow of their application.</p> <pre><code>def debug_configuration():\n    \"\"\"Demonstrates a typical debug configuration setup.\"\"\"\n    print(\"\\n=== Debug Configuration Example ===\")\n    # Setup logger with debug-friendly configuration\n    logger = Logger(\n</code></pre>"},{"location":"tutorials/logging/configuring_logger/#production-configuration","title":"Production Configuration","text":"<p>The production configuration is designed for deployed applications, with an emphasis on performance and stability. It uses more conservative log levels, larger file sizes, and includes rotation to manage disk usage. Console output is limited to warnings and above to reduce unnecessary output in production environments.</p> <pre><code>def production_configuration():\n    \"\"\"Demonstrates a typical production configuration setup.\"\"\"\n    print(\"\\n=== Production Configuration Example ===\")\n    # Setup logger with production-ready configuration\n    logger = Logger(\n</code></pre> <p>If you have any questions or need further assistance, please post on the Open Source Leg community forum.</p>"},{"location":"tutorials/logging/getting_started/","title":"Getting Started with Logging","text":"<p>The <code>opensourceleg</code> library provides an easy-to-use yet powerful logging system that helps you track what's happening in your application. Whether you're debugging issues, monitoring performance, or collecting data, our logging system has you covered.</p>"},{"location":"tutorials/logging/getting_started/#overview","title":"Overview","text":"<p>Our <code>Logger</code> class builds upon Python's native <code>logging</code> module and adds several powerful features:</p> <ul> <li>Data Logging: Easily track variables and measurements over time</li> <li>Flexible Output: Write to both console and files simultaneously</li> <li>Thread Safety: Safe to use in multi-threaded applications</li> <li>Singleton Pattern: One logger instance across your entire application</li> </ul>"},{"location":"tutorials/logging/getting_started/#quick-start","title":"Quick Start","text":""},{"location":"tutorials/logging/getting_started/#1-create-your-logger","title":"1. Create Your Logger","text":"<p>First, create a logger instance in your Python file:</p> <pre><code>from opensourceleg.logging import Logger, LogLevel\n\nlogger = Logger(\n    log_path=\"./logs\",\n    file_name=\"my_application\"\n)\n</code></pre>"},{"location":"tutorials/logging/getting_started/#2-start-logging","title":"2. Start Logging!","text":"<p>It's as simple as:</p> <pre><code># Log some basic information\nlogger.info(\"Application started\")\n\n# Log when something might be wrong\nlogger.warning(\"Battery level below 20%\")\n\n# Log errors when they occur\nlogger.error(\"Failed to connect to sensor\")\n</code></pre>"},{"location":"tutorials/logging/getting_started/#3-understanding-log-levels","title":"3. Understanding Log Levels","text":"<p>We provide five log levels, from least to most severe:</p> <pre><code># For detailed debugging information\nlogger.debug(\"Motor position: 123.4 degrees\")\n\n# For general information\nlogger.info(\"Robot initialized successfully\")\n\n# For potential issues\nlogger.warning(\"Battery running low\")\n\n# For serious problems\nlogger.error(\"Failed to read sensor data\")\n\n# For fatal errors\nlogger.critical(\"System shutdown required\")\n</code></pre>"},{"location":"tutorials/logging/getting_started/#4-customizing-your-logger","title":"4. Customizing Your Logger","text":"<p>You can configure the logger to match your needs:</p> <pre><code>logger = Logger(\n    log_path=\"./logs\",          # Where to save your log files\n    file_name=\"robot_test\",     # Name your log files (e.g., robot_test_2024_03_20.log)\n    buffer_size=1000,           # Save to file every 1000 entries\n    console_level=LogLevel.INFO # Show INFO and above in console\n)\n</code></pre>"},{"location":"tutorials/logging/getting_started/#understanding-logger-instances","title":"Understanding Logger Instances","text":"<p>Our logging system uses a singleton pattern, which means there's only one logger instance per configuration. Here's how to properly use it in your applications:</p>"},{"location":"tutorials/logging/getting_started/#creating-your-own-logger-recommended","title":"Creating Your Own Logger (Recommended)","text":"<pre><code>from opensourceleg.logging import Logger\n\n# Create your own logger instance\nlogger = Logger(\n    log_path=\"./logs\",\n    file_name=\"my_experiment\"\n)\n\n# Use your logger instance throughout your application\nlogger.info(\"Application started\")\nlogger.debug(\"Configuration loaded\")\n</code></pre>"},{"location":"tutorials/logging/getting_started/#about-the-global-logger-for-internal-use","title":"About the Global Logger (For Internal Use)","text":"<p>The library includes a global <code>LOGGER</code> instance, but this is primarily for internal library use:</p> <pre><code>from opensourceleg.logging import LOGGER  # Meant for library internal use\n\n# Prefer creating your own logger instance instead of using LOGGER directly\n</code></pre>"},{"location":"tutorials/logging/getting_started/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Use Appropriate Log Levels</p> <ul> <li><code>DEBUG</code>: Detailed information for debugging</li> <li><code>INFO</code>: General operational messages</li> <li><code>WARNING</code>: Something unexpected but not critical</li> <li><code>ERROR</code>: Something failed but application continues</li> <li><code>CRITICAL</code>: Application cannot continue</li> </ul> </li> <li> <p>Include Relevant Details</p> <pre><code>logger.error(f\"Sensor read failed: {sensor_id}, Error: {error_message}\")\n</code></pre> <p>f-strings are preferred over string interpolation. This is because they are more readable and easier to debug.</p> </li> <li> <p>Log Early, Log Often</p> <ul> <li>Better to have too much information than too little</li> <li>You can always filter logs later</li> </ul> </li> </ol>"},{"location":"tutorials/logging/getting_started/#next-steps","title":"Next Steps","text":"<p>Ready to dive deeper? Check out these tutorials:</p> <ol> <li>Configuring the Logger - Learn all configuration options</li> <li>Logging Data - Master data logging and analysis</li> <li>API Reference - Complete API documentation</li> </ol> <p>Need help? Join our community discussion or open an issue on GitHub!</p>"},{"location":"tutorials/logging/logging_data/","title":"Logging Data","text":"<p>This guide explains how to use the Logger for data collection and variable tracking. Whether you're debugging your robot's behavior, collecting experimental data, or monitoring system performance, proper data logging is essential. All examples can be found in the <code>logging_data.py</code> script.</p>"},{"location":"tutorials/logging/logging_data/#variable-tracking","title":"Variable Tracking","text":"<p>The Logger provides powerful variable tracking capabilities that let you monitor values over time. This is particularly useful for:</p> <ul> <li>Recording sensor readings</li> <li>Tracking control variables</li> <li>Monitoring system state</li> <li>Collecting experimental data</li> </ul> <p>Here's how to set it up:</p> <pre><code>    logger = Logger(log_path=\"./logs\", file_name=\"basic_variable_tracking\")\n\n    # Track a simple variable\n    x = 42\n    logger.track_function(lambda: x, \"x_value\")\n\n    # Track class attributes\n    class Robot:\n        def __init__(self):\n            self.position = 0.0\n            self.velocity = 0.0\n\n    robot = Robot()\n    logger.track_attributes(robot, [\"position\", \"velocity\"])\n\n    # Update logged values\n    logger.update()  # Records current values to buffer\n    logger.info(\"Basic variables tracked and updated\")\n</code></pre> <p>In this example:</p> <ul> <li><code>track_function()</code> tells the logger to monitor a specific variable<ul> <li>The first argument is a function that returns the current value</li> <li>The second argument is the variable name (used in CSV headers)</li> <li>You can track multiple variables simultaneously</li> </ul> </li> <li><code>track_attributes()</code> tells the logger to monitor attributes of the <code>robot</code> object.<ul> <li>The first argument is the object to track from</li> <li>The second argument is the attribute name(s)</li> <li>In the logs, the specific attributes will be prefixed with the name of the object.</li> </ul> </li> <li>Variables are added to a buffer every time <code>update()</code> is called</li> <li>The buffer is flushed based on the <code>buffer_size</code> parameter in the <code>Logger</code> constructor or manually with <code>flush_buffer()</code></li> <li>The buffer is automatically flushed when the Logger is destroyed</li> </ul> <pre><code>    # Update logged values\n    logger.update()  # Records current values to buffer\n    logger.info(\"Basic variables tracked and updated\")\n\n    # We reset the logger just to start the next example, you don't need to reset the logger in your code\n    logger.reset()\n</code></pre>"},{"location":"tutorials/logging/logging_data/#more-examples","title":"More Examples","text":""},{"location":"tutorials/logging/logging_data/#1-recording-sensor-data","title":"1. Recording Sensor Data","text":"<p>This example demonstrates how to log data from a sensor in real-time. While this uses a simulated sensor, the pattern works for any sensor type:</p> <pre><code>class Sensor:\n    \"\"\"Example sensor class for demonstration.\"\"\"\n\n    def __init__(self):\n        self.temperature = 20.0\n        self.humidity = 0.5\n\n    def update(self):\n        \"\"\"Simulate sensor updates.\"\"\"\n        self.temperature += 0.1\n        self.humidity += 0.01\n</code></pre> <p>Key features demonstrated:</p> <ul> <li>Continuous data collection</li> <li>Real-time logging</li> <li>Error handling for sensor failures</li> <li>Proper resource cleanup</li> </ul> <p>Example usage showing how to integrate this into your application:</p> <pre><code>    sensor = Sensor()\n    logger = Logger(log_path=\"./logs\", file_name=\"sensor_data\")\n\n    # Track sensor values\n    logger.track_function(lambda: sensor.temperature, \"Temperature (C)\")\n    logger.track_function(lambda: sensor.humidity, \"Humidity (%)\")\n\n    # Simulate a few updates\n    for _ in range(3):\n        sensor.update()\n        logger.update()\n        time.sleep(0.1)\n\n    logger.info(\"Sensor data logged\")\n</code></pre>"},{"location":"tutorials/logging/logging_data/#2-experiment-data-collection","title":"2. Experiment Data Collection","text":"<p>A more complex example showing how to structure data collection for an experiment, including proper resource management and error handling.</p> <pre><code>class Experiment:\n    \"\"\"Example experiment class demonstrating data collection.\"\"\"\n\n    def __init__(self):\n        self.logger = Logger(\n            log_path=\"./experiments\", file_name=f\"trial_{time.strftime('%Y%m%d_%H%M%S')}\", buffer_size=5000\n        )\n\n        self.input = 0.0\n        self.output = 0.0\n        self.error = 0.0\n        self.steps = 0\n        self.max_steps = 5  # For demonstration\n\n        # Track experimental variables\n        self.logger.track_function(lambda: self.input, \"Input\")\n        self.logger.track_function(lambda: self.output, \"Output\")\n        self.logger.track_function(lambda: self.error, \"Error\")\n\n    def is_complete(self):\n        \"\"\"Check if experiment is complete.\"\"\"\n        return self.steps &gt;= self.max_steps\n\n    def step(self):\n        \"\"\"Simulate one step of the experiment.\"\"\"\n        self.input += 0.1\n        self.output = self.input * 2\n        self.error = abs(self.output - self.input)\n        self.steps += 1\n\n    def run(self):\n        \"\"\"Run the experiment.\"\"\"\n        while not self.is_complete():\n            self.step()\n            self.logger.update()\n</code></pre> <p>Example usage:</p> <pre><code>    experiment.run()\n    print(\"Experiment completed and data saved\")\n</code></pre>"},{"location":"tutorials/logging/logging_data/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Variable Naming</p> <ul> <li>Use clear, descriptive names for tracked variables</li> <li>Follow a consistent naming convention</li> <li>Consider adding units to variable names (e.g., \"angle_deg\", \"velocity_mps\")</li> </ul> </li> <li> <p>Update Frequency</p> <ul> <li>Call <code>update()</code> at a consistent rate</li> <li>Consider your data storage requirements</li> <li>Balance logging frequency with system performance</li> </ul> </li> <li> <p>Resource Management</p> <ul> <li>Always use proper cleanup procedures</li> <li>Consider using context managers (<code>with</code> statements)</li> <li>Handle interruptions gracefully</li> </ul> </li> <li> <p>Data Organization</p> <ul> <li>Use meaningful file names</li> <li>Structure your data logically</li> <li>Include metadata when relevant</li> </ul> </li> </ol>"},{"location":"tutorials/logging/logging_data/#working-with-logged-data","title":"Working with Logged Data","text":"<p>Your logged data can be easily analyzed using common data analysis packages like <code>pandas</code> and <code>matplotlib</code> or used with other programs like Matlab.</p>"},{"location":"tutorials/logging/logging_data/#common-issues-and-solutions","title":"Common Issues and Solutions","text":"<ol> <li> <p>High-Frequency Data</p> <ul> <li>Increase buffer size for better performance</li> <li>Consider logging only essential variables</li> <li>Use appropriate data types</li> </ul> </li> <li> <p>Large Files</p> <ul> <li>Split logs into manageable chunks</li> <li>Clean up old logs regularly</li> <li>Monitor disk space usage</li> </ul> </li> <li> <p>System Performance</p> <ul> <li>Profile your logging impact</li> <li>Adjust buffer sizes as needed</li> <li>Balance logging frequency with requirements</li> </ul> </li> </ol> <p>If you have any questions or need further assistance, please post on the Open Source Leg community forum.</p>"},{"location":"tutorials/robots/getting_started/","title":"Getting Started with Robots and the OSL","text":"<p>This guide introduces the <code>opensourceleg.robots</code> module and provides essential safety information for robot tutorials. To preface, the robot class is a combination of actuator and sensor instances that are implemented and organized for you. The class is adapted from the <code>OpenSourceLeg</code> class to provide a generalized framework for any robotics platform. The class used for non OSL applications is called <code>RobotBase</code>, and more documentation can be found here.</p>"},{"location":"tutorials/robots/getting_started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Raspberry Pi</li> <li>Python environment with <code>opensourceleg</code> package installed</li> <li>Open source leg or robot platform with sensors and/or actuators</li> <li>External power supply</li> </ul>"},{"location":"tutorials/robots/getting_started/#hardware-setup","title":"Hardware Setup","text":"<p>The hardware setup will be unique to each robot platform. If you are having trouble with your setup, please refer to the specific documentation regarding actuators and sensors below.</p> <ul> <li>Actuator Setup Guide</li> <li>Sensor Setup Guide</li> </ul>"},{"location":"tutorials/robots/getting_started/#safety-guidelines","title":"Safety Guidelines","text":"<p>Please follow these guidelines when following the <code>opensourceleg.robots</code> tutorials.</p>"},{"location":"tutorials/robots/getting_started/#1-mechanical-safety","title":"1. Mechanical Safety","text":"<ul> <li>Securely mount the OSL or robot platform before operation</li> <li>Maintain clear space around moving parts</li> <li>Verify sufficient range of motion for commands</li> <li> <p>Be aware of mechanical limits and stops</p> </li> <li> <p>Have a clear emergency stop plan</p> </li> <li>Know how to quickly terminate scripts (<code>Ctrl+C</code>)</li> <li>Keep emergency stop button accessible</li> </ul>"},{"location":"tutorials/robots/getting_started/#2-electrical-safety","title":"2. Electrical Safety","text":"<ul> <li>Never exceed rated voltage/current limits</li> <li>Verify proper power supply connection</li> <li>Ensure proper grounding</li> <li>Check all electrical connections before powering on</li> </ul>"},{"location":"tutorials/robots/getting_started/#3-operational-safety","title":"3. Operational Safety","text":"<ul> <li>Continuously monitor sensor readings</li> <li>Watch for unexpected behavior:<ul> <li>Oscillations</li> <li>Excessive current draw</li> <li>Unusual sounds or vibrations</li> <li>Unexpected resistance</li> </ul> </li> </ul>"},{"location":"tutorials/robots/getting_started/#4-best-practices","title":"4. Best Practices","text":"<ul> <li>Verify all connections</li> <li>Check mounting security</li> <li>Clear workspace of obstacles</li> <li> <p>Review emergency procedures</p> </li> <li> <p>Monitor system behavior</p> </li> <li>Keep hands clear</li> <li>Be ready to terminate</li> <li> <p>Log any unusual behavior</p> </li> <li> <p>Power down safely</p> </li> <li>Document any issues</li> <li>Verify data logging</li> <li>Check actuator temperature</li> </ul>"},{"location":"tutorials/robots/getting_started/#troubleshooting-guide","title":"Troubleshooting Guide","text":"<ul> <li>Check device presence: <code>ls /dev/ttyACM*</code></li> <li> <p>Verify USB permissions, if you see <code>Permission denied</code> error, it is likely because the current user does not have permission to access the serial ports. You can add your user to the <code>dialout</code> group to fix this. If you are on a Linux system, you can run <code>sudo usermod -a -G dialout $USER</code> to add your user to the <code>dialout</code> group. Then you need to restart your system for the changes to take effect.</p> </li> <li> <p>Try physical reconnection:</p> <ol> <li>Unplug USB</li> <li>Wait a few seconds</li> <li>Reconnect</li> </ol> </li> <li> <p>Verify power supply connection</p> </li> <li>Check voltage levels</li> <li>Confirm power LED indicators</li> <li>Monitor current draw</li> </ul>"},{"location":"tutorials/robots/getting_started/#getting-help","title":"Getting Help","text":"<p>If you encounter any issues or need assistance:</p> <ol> <li>Check the troubleshooting section in the specific tutorial</li> <li>Review the API documentation</li> <li>Post questions on the Open Source Leg community forum</li> </ol>"},{"location":"tutorials/robots/getting_started/#next-steps","title":"Next Steps","text":"<p>Choose a tutorial to get started:</p> <ul> <li>Homing OSL Joints</li> </ul> <p>Each tutorial includes specific setup instructions and code examples.</p>"},{"location":"tutorials/robots/homing_joints/","title":"Homing OSL Joints","text":"<p>This tutorial demonstrates how to home the knee and ankle joints on the Open Source Leg (OSL) using the <code>opensourceleg</code> Python library. You\u2019ll learn how to initialize actuators and encoders, configure the robot platform, and use the built-in <code>home()</code> method to calibrate the joints by driving them into physical stops and applying offsets.</p>"},{"location":"tutorials/robots/homing_joints/#overview","title":"Overview","text":"<p>This example shows how to:</p> <ul> <li>Initialize <code>DephyActuator</code> instances for the knee and ankle joints</li> <li>Configure <code>AS5048B</code> magnetic absolute encoders via I2C</li> <li>Instantiate the <code>OpenSourceLeg</code> platform with the defined components</li> <li>Use the <code>home()</code> method to detect joint limits and assign calibrated offsets</li> <li>Use callback functions to execute code at the homed positions</li> <li>Log joint and encoder positions to the terminal in real-time</li> </ul>"},{"location":"tutorials/robots/homing_joints/#hardware-setup","title":"Hardware Setup","text":"<ul> <li>Actuators: Two Dephy Actuators are connected to <code>/dev/ttyACM0</code> and <code>/dev/ttyACM1</code>. These control the knee and ankle respectively.</li> <li>Encoders: Two AS5048B encoders are connected to I2C bus on the host controller.</li> </ul> <p>For detailed setup instructions, refer to:</p> <ul> <li>Actuator Setup Guide</li> <li>Sensor Setup Guide</li> </ul>"},{"location":"tutorials/robots/homing_joints/#software-setup","title":"Software Setup","text":"<p>Ensure the <code>opensourceleg</code> Python package is installed. Before running the full integration script, verify that each actuator and encoder is working individually. This helps isolate configuration issues.</p>"},{"location":"tutorials/robots/homing_joints/#code-structure","title":"Code Structure","text":"<p>The tutorial script is structured into seven key sections:</p>"},{"location":"tutorials/robots/homing_joints/#1-configuration","title":"1. Configuration","text":"<pre><code>import numpy as np\n\nfrom opensourceleg.actuators.base import CONTROL_MODES\nfrom opensourceleg.actuators.dephy import DephyActuator\nfrom opensourceleg.logging.logger import Logger\nfrom opensourceleg.robots.osl import OpenSourceLeg\nfrom opensourceleg.sensors.encoder import AS5048B\nfrom opensourceleg.utilities import SoftRealtimeLoop\n\nTIME_TO_STEP = 1.0\nFREQUENCY = 200\nDT = 1 / FREQUENCY\nGEAR_RATIO = 9 * (83 / 18)\n</code></pre> <p>Key parameters:</p> <ul> <li><code>FREQUENCY</code>: Control loop rate (200 Hz)</li> <li><code>DT</code>: Timestep per loop cycle, defined as <code>1 / FREQUENCY</code></li> <li><code>GEAR_RATIO</code>: Compound gear ratio applied to each joint (\u224841.5:1)</li> </ul>"},{"location":"tutorials/robots/homing_joints/#2-real-time-loop-and-logger","title":"2. Real-time loop and Logger","text":"<pre><code>def home_joints():\n    homing_logger = Logger(\n        log_path=\"./logs\",\n        file_name=\"homing_joint\",\n    )\n\n    clock = SoftRealtimeLoop(dt=DT)\n</code></pre> <p>This section:</p> <ul> <li>Initializes a <code>Logger</code> instance to write homing data to the <code>./logs</code> directory</li> <li>Starts a <code>SoftRealtimeLoop</code> for accurate timing</li> </ul>"},{"location":"tutorials/robots/homing_joints/#3-actuator-initialization","title":"3. Actuator Initialization","text":"<pre><code>    actuators = {\n        \"knee\": DephyActuator(\n            tag=\"knee\",\n            port=\"/dev/ttyACM0\",\n            gear_ratio=GEAR_RATIO,\n            frequency=FREQUENCY,\n            dephy_log=False,\n        ),\n        \"ankle\": DephyActuator(\n            tag=\"ankle\",\n            port=\"/dev/ttyACM1\",\n            gear_ratio=GEAR_RATIO,\n            frequency=FREQUENCY,\n            dephy_log=False,\n        ),\n    }\n</code></pre> <p>This section:</p> <ul> <li>Instantiates two <code>DephyActuator</code> objects for the knee and ankle</li> <li>Assigns ports, frequency, gear ratio, and disables internal logging</li> </ul>"},{"location":"tutorials/robots/homing_joints/#4-sensor-initialization","title":"4. Sensor Initialization","text":"<pre><code>    sensors = {\n        \"joint_encoder_knee\": AS5048B(\n            tag=\"joint_encoder_knee\",\n            bus=\"/dev/i2c-2\",\n            A1_adr_pin=True,\n            A2_adr_pin=False,\n            zero_position=0,\n            enable_diagnostics=False,\n        ),\n        \"joint_encoder_ankle\": AS5048B(\n            tag=\"joint_encoder_ankle\",\n            bus=\"/dev/i2c-3\",\n            A1_adr_pin=False,\n            A2_adr_pin=True,\n            zero_position=0,\n            enable_diagnostics=False,\n        ),\n    }\n</code></pre> <p>This section:</p> <ul> <li>Instantiates two <code>AS5048B</code> encoders using the I2C interface</li> <li>Each encoder is tagged and assigned its A1/A2 pin configuration</li> <li>Zero position is temporarily set to 0</li> </ul>"},{"location":"tutorials/robots/homing_joints/#5-using-callbacks-for-homing-completion","title":"5. Using Callbacks for Homing Completion","text":"<p>The <code>home()</code> method also supports an optional <code>callback_functions</code> argument. This allows you to specify a list of functions (one per actuator) that will be called when each actuator finishes its homing routine. This is useful for custom notifications, logging, or triggering additional actions like zeroing joint encoders.</p> <p>For example, to print a message when each joint completes homing:</p> <pre><code>    # Define callback functions for homing completion\n    def knee_homing_complete():\n        osl.joint_encoder_knee.update()\n        osl.joint_encoder_knee.zero_position = osl.joint_encoder_knee.counts\n        print(\"Knee homing complete!\")\n\n    def ankle_homing_complete():\n        osl.joint_encoder_ankle.update()\n        osl.joint_encoder_ankle.zero_position = osl.joint_encoder_ankle.counts + osl.joint_encoder_ankle.deg_to_counts(\n            30\n        )\n        print(\"Ankle homing complete!\")\n\n    callbacks = {\"knee\": knee_homing_complete, \"ankle\": ankle_homing_complete}\n</code></pre> <p>If you do not wish to use callbacks, you can omit the <code>callback_functions</code> argument or pass a list of <code>None</code> values.</p>"},{"location":"tutorials/robots/homing_joints/#6-initialize-osl-platform","title":"6. Initialize OSL Platform","text":"<pre><code>    osl = OpenSourceLeg(\n        tag=\"osl\",\n        actuators=actuators,\n        sensors=sensors,\n    )\n</code></pre> <p>This section:</p> <ul> <li>Creates an instance of <code>OpenSourceLeg</code> and passes in the actuator and sensor dictionaries</li> </ul>"},{"location":"tutorials/robots/homing_joints/#7-run-homing-routine","title":"7. Run Homing Routine","text":"<pre><code>    with osl:\n        osl.home(\n            homing_voltage=2000,\n            homing_frequency=FREQUENCY,\n            homing_direction={\"knee\": -1, \"ankle\": -1},\n            output_position_offset={\"knee\": 0.0, \"ankle\": np.deg2rad(30.0)},\n            current_threshold=5000,\n            velocity_threshold=0.001,\n            callbacks=callbacks,\n        )\n</code></pre> <p>This section:</p> <ul> <li>Calls <code>osl.home()</code> with user-defined voltages, direction, and thresholds</li> <li>Each actuator rotates in a specified direction until one of the following is true:</li> <li>Velocity falls below <code>0.001 rad/s</code></li> <li>Current exceeds <code>5000 mA</code></li> <li>Once stopped, the motor is zeroed based on its position, and a calibrated offset is added (30\u00b0 for ankle, 0\u00b0 for knee)</li> </ul>"},{"location":"tutorials/robots/homing_joints/#8-reset-torque-and-start-logging","title":"8. Reset Torque and Start Logging","text":"<pre><code>        osl.knee.set_control_mode(CONTROL_MODES.CURRENT)\n        osl.knee.set_current_gains()\n\n        osl.ankle.set_control_mode(CONTROL_MODES.CURRENT)\n        osl.ankle.set_current_gains()\n\n        osl.knee.set_output_torque(0)\n        osl.ankle.set_output_torque(0)\n\n        # homing_logger.set_stream_terminator(\"\\r\")\n        for t in clock:\n            osl.update()\n\n            homing_logger.info(\n                f\"Time: {t:.2f}; Knee Output Position: {np.rad2deg(osl.knee.output_position):.2f}; \"\n                f\"Ankle Output Position: {np.rad2deg(osl.ankle.output_position):.2f}; \"\n                f\"Knee Encoder Position: {np.rad2deg(osl.joint_encoder_knee.position):.2f}; \"\n                f\"Ankle Encoder Position: {np.rad2deg(osl.joint_encoder_ankle.position):.2f}; \"\n            )\n</code></pre> <p>This section:</p> <ul> <li>Switches both actuators to <code>CURRENT</code> control mode</li> <li>Sets joint torques to 0 so they can be moved freely</li> <li>Logs the following information continuously:</li> <li>Elapsed time</li> <li>Output positions of the knee and ankle (in degrees)</li> <li>Raw encoder readings of the knee and ankle (in degrees)</li> </ul>"},{"location":"tutorials/robots/homing_joints/#running-the-script","title":"Running the Script","text":"<ol> <li> <p>Navigate to the tutorial directory:</p> <pre><code>cd tutorials/robots/osl\n</code></pre> </li> <li> <p>Run the script:</p> <pre><code>python homing_joints.py\n</code></pre> </li> <li> <p>Expected behavior:</p> <ul> <li>Both motors rotate slowly in a negative direction</li> <li>Movement stops once physical limits are detected (via current or velocity thresholds)</li> <li>Homing offsets are applied to calibrate the zero position</li> <li>Control mode switches to current control, torque is zeroed</li> <li>Joint and encoder positions print continuously in the terminal</li> </ul> </li> </ol> <p>Note: You can use Ctrl+C to terminate the loop at any time.</p>"},{"location":"tutorials/sensors/getting_started/","title":"Getting Started with Sensors","text":"<p>This guide introduces the <code>opensourceleg.sensors</code> module and provides essential information for all sensor tutorials.</p>"},{"location":"tutorials/sensors/getting_started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Raspberry Pi</li> <li>Python environment with <code>opensourceleg</code> package installed</li> <li> <p>Supported sensors:</p> <ul> <li>AS5048B Encoder</li> <li>Lord Microstrain IMU</li> <li>Dephy Loadcell Amplifier</li> </ul> </li> </ul>"},{"location":"tutorials/sensors/getting_started/#hardware-setup","title":"Hardware Setup","text":"<p>Each sensor has specific connection requirements:</p> <ol> <li> <p>Encoder (AS5048B):</p> <ul> <li>Connects via I2C interface</li> <li>Uses GPIO pins</li> </ul> </li> <li> <p>IMU (Lord Microstrain):</p> <ul> <li>Connects via serial (typically at <code>/dev/ttyUSB0</code>)</li> <li>Keep note of the orientation of the IMU</li> </ul> </li> <li> <p>Loadcell (Dephy Amplifier):</p> <ul> <li>Connects via I2C interface</li> <li>Requires proper calibration matrix of your loadcell</li> <li>Needs correct amplifier gain settings</li> </ul> </li> </ol>"},{"location":"tutorials/sensors/getting_started/#best-practices","title":"Best Practices","text":""},{"location":"tutorials/sensors/getting_started/#1-initialization","title":"1. Initialization","text":"<ul> <li>Verify proper connections before powering on</li> <li>Check communication interfaces (I2C, USB)</li> <li>Ensure correct device addresses</li> <li>Initialize sensors with appropriate parameters</li> </ul>"},{"location":"tutorials/sensors/getting_started/#2-data-collection","title":"2. Data Collection","text":"<ul> <li>Use appropriate sampling frequencies</li> <li>Implement proper error handling</li> <li>Log data for analysis</li> <li>Monitor sensor readings for anomalies</li> </ul>"},{"location":"tutorials/sensors/getting_started/#3-maintenance","title":"3. Maintenance","text":"<ul> <li>Regular calibration checks</li> <li>Check connections periodically</li> <li>Monitor for drift or inconsistencies</li> </ul>"},{"location":"tutorials/sensors/getting_started/#troubleshooting-guide","title":"Troubleshooting Guide","text":"<p>Common issues and solutions:</p> <ul> <li>I2C Communication:</li> </ul> <p><pre><code># List I2C devices\ni2cdetect -y 1\n</code></pre>   also make sure i2c is enabled in raspi-config if you are using a raspberry pi</p> <ul> <li>USB Device Detection:</li> </ul> <pre><code># Check USB devices\nls /dev/ttyUSB*\nls /dev/ttyACM*\n</code></pre> <ul> <li>Permission Issues:</li> </ul> <pre><code># Add user to required groups\nsudo usermod -a -G dialout $USER\n</code></pre>"},{"location":"tutorials/sensors/getting_started/#getting-help","title":"Getting Help","text":"<p>If you encounter any issues:</p> <ol> <li>Check the specific sensor's documentation</li> <li>Review the API documentation</li> <li>Post questions on the Open Source Leg community forum</li> </ol>"},{"location":"tutorials/sensors/getting_started/#next-steps","title":"Next Steps","text":"<p>Choose a sensor tutorial to get started:</p> <ul> <li>Reading Encoder Data</li> <li>Reading IMU Data</li> <li>Reading Loadcell Data</li> </ul> <p>Each tutorial includes specific setup instructions and code samples.</p>"},{"location":"tutorials/sensors/reading_adc/","title":"Using the ADS131M0x Analog to Digital Converter","text":"<p>This tutorial demonstrates how to use the ADS131M0x analog to digital converter with the Open Source Leg platform. This example shows how to:</p> <ul> <li>Initialize and configure an ADS131M0x ADC</li> <li>Read voltage data</li> </ul>"},{"location":"tutorials/sensors/reading_adc/#hardware-setup","title":"Hardware Setup","text":"<ol> <li>Connect the ADS131M0x ADC to your Raspberry Pi's SPI pins</li> <li>Make sure the ADC is powered on and the SPI pins are connected correctly</li> </ol>"},{"location":"tutorials/sensors/reading_adc/#code-structure","title":"Code Structure","text":"<p>The tutorial script is organized as follows:</p>"},{"location":"tutorials/sensors/reading_adc/#1-initialization","title":"1. Initialization","text":"<pre><code>from opensourceleg.logging.logger import Logger\nfrom opensourceleg.sensors.adc import ADS131M0x\nfrom opensourceleg.utilities import SoftRealtimeLoop\n\nFREQUENCY = 500\nDT = 1 / FREQUENCY\n\nif __name__ == \"__main__\":\n    adc_logger = Logger(\n        log_path=\"./logs\",\n        file_name=\"reading_adc_data\",\n    )\n    clock = SoftRealtimeLoop(dt=DT)\n    adc = ADS131M0x(\n        tag=\"ADS131M0x\",\n        spi_bus=0,\n        spi_cs=0,\n        data_rate=FREQUENCY,\n        clock_freq=8192000,\n        num_channels=6,\n        gains=[1] * 6,\n        voltage_reference=1.2,\n        gain_error=[0] * 6,\n        offline=False,\n    )\n    adc_logger.track_function(lambda: adc.data, \"Ch Voltages\")\n</code></pre> <p>This section:</p> <ol> <li>Creates a data logger for recording measurements</li> <li>Sets up a real-time loop for consistent timing</li> <li>Initializes the ADS131M0x ADC with specified parameters</li> <li>Gets the latest ADC data in millivolts</li> </ol>"},{"location":"tutorials/sensors/reading_adc/#2-main-loop","title":"2. Main Loop","text":"<pre><code>    with adc:\n        adc.calibrate()\n        for t in clock:\n            adc.update()\n            adc_logger.info(f\"Time: {t}; Ch Voltages = {adc.data}\")\n            adc_logger.update()\n</code></pre> <p>The main loop:</p> <ol> <li>Updates the ADC to get the latest reading</li> <li>Logs the time and current voltage reading</li> </ol>"},{"location":"tutorials/sensors/reading_adc/#adc-parameters","title":"ADC Parameters","text":"<p>When initializing the ADS131M0x ADC, several parameters can be configured:</p> <pre><code>    adc = ADS131M0x(\n        tag=\"ADS131M0x\",\n        spi_bus=0,\n        spi_cs=0,\n        data_rate=FREQUENCY,\n        clock_freq=8192000,\n        num_channels=6,\n        gains=[1] * 6,\n        voltage_reference=1.2,\n        gain_error=[0] * 6,\n        offline=False,\n</code></pre>"},{"location":"tutorials/sensors/reading_adc/#parameter-details","title":"Parameter Details","text":"<ol> <li> <p>tag (str):</p> <ul> <li>Unique identifier for the ADC instance</li> <li>Useful when using multiple ADCs</li> <li>Default is \"ADS131M0x\"</li> </ul> </li> <li> <p>spi_bus (int):</p> <ul> <li>SPI bus number</li> <li>Default bus on Raspberry Pi is typically <code>0</code></li> </ul> </li> <li> <p>spi_cs (int):</p> <ul> <li>SPI chip select line</li> <li>Default is <code>0</code></li> </ul> </li> <li> <p>data_rate (int):</p> <ul> <li>Sampling rate in Hz</li> <li>Default is 500 Hz</li> </ul> </li> <li> <p>clock_freq (int):</p> <ul> <li>SPI clock frequency in Hz</li> <li>Default is 8192000 Hz.</li> </ul> </li> <li> <p>num_channels (int):</p> <ul> <li>Number of ADC channels</li> <li>Default is 6</li> </ul> </li> <li> <p>gains (List[int]):</p> <ul> <li>Programmable gain values for each channel</li> <li>Default is [1] * num_channels.</li> </ul> </li> <li> <p>voltage_reference (float):</p> <ul> <li>ADC reference voltage in volts</li> <li>Default reference for ADS131M0x ADC is 1.2 V and should not be changed if using this ADC</li> </ul> </li> <li> <p>gain_error (List[int]):</p> <ul> <li>Gain error correction values for each channel</li> <li>Default is None.</li> </ul> </li> <li> <p>offline (bool):</p> <ul> <li>Enables and disables offline mode for ADS131M0x ADC</li> <li>If <code>True</code>, the ADC operates in offline mode, meaning that the ADC hardware does not have to be connected in order for your script to run</li> <li>Default is <code>False</code></li> </ul> </li> </ol>"},{"location":"tutorials/sensors/reading_adc/#available-properties","title":"Available Properties","text":"<p>The ADS131M0x ADC provides the following properties:</p> <ol> <li> <p>is_streaming</p> <ul> <li>Checks if ADC is streaming data</li> <li>Returns <code>True</code> if streaming, <code>False</code> otherwise</li> </ul> </li> <li> <p>gain:</p> <ul> <li>Gets the programmable gain values for each channel</li> <li>Returns array of gain values (np.ndarray)</li> </ul> </li> <li> <p>data</p> <ul> <li>Gets the latest ADC data in millivolts</li> <li>Returns array of voltage readings for each channel (np.ndarray)</li> </ul> </li> <li> <p>data_counts</p> <ul> <li>Gets the latest ADC data in raw counts</li> <li>Returns array of raw ADC counts for each channel (np.ndarray)</li> </ul> </li> <li> <p>num_channels</p> <ul> <li>Get the number of ADC channels.</li> <li>Returns # of channels (int)</li> </ul> </li> </ol>"},{"location":"tutorials/sensors/reading_adc/#running-the-example","title":"Running the Example","text":"<ol> <li> <p>Navigate to the tutorial directory:    <pre><code>cd tutorials/sensors\n</code></pre></p> </li> <li> <p>Run the script:    <pre><code>python reading_adc.py\n</code></pre></p> </li> <li> <p>Expected behavior:</p> <ul> <li>ADC begins reading voltage values in mV continuously at sampling rate (default is 500 Hz)</li> <li>Data is logged to <code>./logs/reading_adc_data.csv</code></li> </ul> </li> </ol>"},{"location":"tutorials/sensors/reading_adc/#common-issues","title":"Common Issues","text":"<p>If you have any questions or need further assistance, please post on the Open Source Leg community forum.</p>"},{"location":"tutorials/sensors/reading_encoder_data/","title":"Using the AS5048B Encoder","text":"<p>This tutorial demonstrates how to use the AS5048B magnetic encoder with the Open Source Leg platform.</p>"},{"location":"tutorials/sensors/reading_encoder_data/#hardware-setup","title":"Hardware Setup","text":"<ol> <li>Connect the AS5048B encoder to your Raspberry Pi's I2C pins</li> <li>Make sure the encoder is powered on and the I2C pins are connected correctly</li> <li>Note the encoder's address pin configuration (A1 and A2)</li> </ol> <p>This example shows how to:</p> <ul> <li>Initialize and configure an AS5048B encoder</li> <li>Read angular position data</li> </ul>"},{"location":"tutorials/sensors/reading_encoder_data/#code-structure","title":"Code Structure","text":"<p>The tutorial script is organized into several main sections:</p>"},{"location":"tutorials/sensors/reading_encoder_data/#1-initialization","title":"1. Initialization","text":"<pre><code>from opensourceleg.logging.logger import Logger\nfrom opensourceleg.sensors.encoder import AS5048B\nfrom opensourceleg.utilities import SoftRealtimeLoop\n\nFREQUENCY = 1000\nDT = 1 / FREQUENCY\n\nif __name__ == \"__main__\":\n    encoder_logger = Logger(\n        log_path=\"./logs\",\n        file_name=\"reading_encoder_data\",\n    )\n    clock = SoftRealtimeLoop(dt=DT)\n    encoder = AS5048B(\n        tag=\"encoder1\",\n        bus=\"/dev/i2c-1\",\n        A1_adr_pin=False,\n        A2_adr_pin=True,\n        zero_position=0,\n        enable_diagnostics=False,\n    )\n</code></pre> <p>This section:    - Creates a data logger for recording measurements    - Sets up a real-time loop for consistent timing    - Initializes the AS5048B encoder with specified parameters</p>"},{"location":"tutorials/sensors/reading_encoder_data/#2-main-loop","title":"2. Main Loop","text":"<pre><code>    with encoder:\n        for t in clock:\n            encoder.update()\n            encoder_logger.info(f\"Time: {t}; Encoder Angle: {encoder.position};\")\n            encoder_logger.update()\n</code></pre> <p>The main loop: 1. Updates the encoder to get the latest reading 2. Logs the time and current encoder angle 3. Updates the logger</p>"},{"location":"tutorials/sensors/reading_encoder_data/#encoder-parameters","title":"Encoder Parameters","text":"<p>When initializing the AS5048B encoder, several important parameters can be configured:</p> <pre><code>    encoder = AS5048B(\n        tag=\"encoder1\",\n        bus=\"/dev/i2c-1\",\n        A1_adr_pin=False,\n        A2_adr_pin=True,\n        zero_position=0,\n</code></pre>"},{"location":"tutorials/sensors/reading_encoder_data/#parameter-details","title":"Parameter Details","text":"<ol> <li> <p>tag (str):</p> <ul> <li>Unique identifier for the encoder instance</li> <li>Useful when using multiple encoders</li> </ul> </li> <li> <p>bus (str):</p> <ul> <li>Specifies the I2C bus to use</li> <li>Should be a path (e.g., <code>\"/dev/i2c-1\"</code>)</li> <li>Default bus on Raspberry Pi is typically <code>1</code></li> </ul> </li> <li> <p>A1_adr_pin and A2_adr_pin (bool):</p> <ul> <li>Controls the I2C address of the encoder</li> <li>Corresponds to the physical address pins on the AS5048B</li> <li>Used to connect multiple encoders on the same I2C bus</li> <li>Base address is <code>0b1000000</code> (0x40)</li> </ul> </li> <li> <p>zero_position (int):</p> <ul> <li>Sets the zero position reference</li> <li>Value between 0 and 16383 (2\u00b9\u2074-1)</li> <li>Affects the returned <code>position</code> value</li> </ul> </li> <li> <p>enable_diagnostics (bool):</p> <ul> <li>When enabled, performs additional checks during updates</li> <li>Verifies data validity and magnetic field strength</li> <li>May raise exceptions for invalid data or show warnings</li> </ul> </li> </ol>"},{"location":"tutorials/sensors/reading_encoder_data/#available-properties","title":"Available Properties","text":"<p>The AS5048B encoder provides several useful properties:</p> <ol> <li> <p>position:</p> <ul> <li>Current angular position in radians</li> <li>Calculated from raw encoder output with proper scaling</li> </ul> </li> <li> <p>velocity:</p> <ul> <li>Angular velocity in radians per second</li> <li>Calculated from consecutive position readings</li> </ul> </li> <li> <p>abs_ang:</p> <ul> <li>Absolute angle tracking multiple rotations</li> <li>Keeps track of full rotations for continuous tracking</li> </ul> </li> <li> <p>zero_position:</p> <ul> <li>Gets/sets the zero position offset</li> <li>Use <code>set_zero_position()</code> method to calculate midpoint automatically</li> </ul> </li> <li> <p>Diagnostic Properties:</p> <ul> <li><code>diag_compH</code>: High magnetic field compensation</li> <li><code>diag_compL</code>: Low magnetic field compensation</li> <li><code>diag_COF</code>: CORDIC overflow flag</li> <li><code>diag_OCF</code>: Offset compensation finished flag</li> </ul> </li> </ol>"},{"location":"tutorials/sensors/reading_encoder_data/#running-the-example","title":"Running the Example","text":"<ol> <li> <p>Navigate to the tutorial directory:    <pre><code>cd tutorials/sensors\n</code></pre></p> </li> <li> <p>Run the script:    <pre><code>python reading_encoder.py\n</code></pre></p> </li> <li> <p>Expected behavior:</p> <ul> <li>Encoder begins reading angular position continuously at 1000Hz</li> <li>Data is logged to <code>./logs/reading_encoder_data.csv</code></li> <li>Position values will change as you rotate the encoder</li> </ul> </li> </ol>"},{"location":"tutorials/sensors/reading_encoder_data/#advanced-usage","title":"Advanced Usage","text":""},{"location":"tutorials/sensors/reading_encoder_data/#setting-zero-position","title":"Setting Zero Position","text":"<p>You can set the zero position in two ways:</p> <ol> <li> <p>Manual Setting:    <pre><code>encoder.zero_position = new_zero_value  # Sets specific zero offset\n</code></pre></p> </li> <li> <p>Interactive Setting:    <pre><code>encoder.set_zero_position()  # Interactive process to set midpoint\n</code></pre>    This method prompts you to position the joint at minimum and maximum angles, then calculates the midpoint.    Read more about this method here.</p> </li> </ol>"},{"location":"tutorials/sensors/reading_encoder_data/#common-issues","title":"Common Issues","text":"<ul> <li>I2C Communication Errors: Verify connections and run <code>i2cdetect -y 1</code></li> <li>Permission Denied: Add user to i2c group: <code>sudo usermod -a -G i2c $USER</code></li> <li>Incorrect Readings: Check encoder orientation and magnetic field strength</li> <li>Unstable Values: Check for mechanical vibration or electromagnetic interference</li> </ul> <p>If you have any questions or need further assistance, please post on the Open Source Leg community forum.</p>"},{"location":"tutorials/sensors/reading_imu_data/","title":"Using the Lord Microstrain IMU","text":"<p>This tutorial demonstrates how to use the Lord Microstrain IMU with the Open Source Leg platform.</p>"},{"location":"tutorials/sensors/reading_imu_data/#hardware-setup","title":"Hardware Setup","text":"<ol> <li>Connect the Lord Microstrain IMU to your computer via USB</li> <li>Note the device port (typically <code>/dev/ttyUSB0</code>)</li> <li>Mount the IMU securely with proper orientation</li> <li>Verify the LED indicators are active</li> </ol> <p>This example shows how to:</p> <ul> <li>Initialize and configure a Lord Microstrain IMU</li> <li>Read orientation, angular velocity, and acceleration data</li> <li>Log IMU measurements</li> </ul>"},{"location":"tutorials/sensors/reading_imu_data/#code-structure","title":"Code Structure","text":"<p>The tutorial script is organized into several main sections:</p>"},{"location":"tutorials/sensors/reading_imu_data/#1-initialization","title":"1. Initialization","text":"<pre><code>from opensourceleg.logging.logger import Logger\nfrom opensourceleg.sensors.imu import LordMicrostrainIMU\nfrom opensourceleg.utilities import SoftRealtimeLoop\n\nFREQUENCY = 200\nDT = 1 / FREQUENCY\n\nif __name__ == \"__main__\":\n    imu_logger = Logger(\n        log_path=\"./logs\",\n        file_name=\"reading_imu_data\",\n    )\n    clock = SoftRealtimeLoop(dt=DT)\n    imu = LordMicrostrainIMU(\n        tag=\"LordMicrostrainIMU\",\n        port=r\"/dev/ttyS0\",\n        baud_rate=921600,\n        frequency=FREQUENCY,\n        update_timeout=500,\n        max_packets=1,\n</code></pre> <p>This section:</p> <ul> <li>Creates a data logger for recording measurements</li> <li>Sets up a real-time loop for consistent timing</li> <li>Initializes the LordMicrostrainIMU with specified parameters</li> <li>Configures variable tracking for roll, pitch, and yaw angles</li> </ul>"},{"location":"tutorials/sensors/reading_imu_data/#2-main-loop","title":"2. Main Loop","text":"<pre><code>        offline=False,\n    )\n    imu_logger.track_function(lambda: imu.roll, \"Roll\")\n    imu_logger.track_function(lambda: imu.pitch, \"Pitch\")\n    imu_logger.track_function(lambda: imu.yaw, \"Yaw\")\n\n    with imu:\n        for t in clock:\n            imu.update()\n            imu_logger.info(f\"Time: {t}; Roll: {imu.roll}; Pitch: {imu.pitch}; Yaw: {imu.yaw};\")\n</code></pre> <p>The main loop:</p> <ol> <li>Updates the IMU to get the latest reading</li> <li>Logs the time and current orientation data</li> <li>Updates the logger</li> </ol>"},{"location":"tutorials/sensors/reading_imu_data/#imu-parameters","title":"IMU Parameters","text":"<p>When initializing the LordMicrostrainIMU, several important parameters can be configured:</p> <pre><code>    imu = LordMicrostrainIMU(\n        tag=\"LordMicrostrainIMU\",\n        port=r\"/dev/ttyS0\",\n        baud_rate=921600,\n        frequency=FREQUENCY,\n        update_timeout=500,\n        max_packets=1,\n        return_packets=False,\n        offline=False,\n    )\n</code></pre>"},{"location":"tutorials/sensors/reading_imu_data/#parameter-details","title":"Parameter Details","text":"<ol> <li> <p>tag (str):</p> <ul> <li>Unique identifier for the IMU instance</li> <li>Useful when using multiple sensors</li> <li>Defaults to \"LordMicrostrainIMU\"</li> </ul> </li> <li> <p>port (str):</p> <ul> <li>Specifies the serial port where the IMU is connected</li> <li>Default is <code>/dev/ttyUSB0</code></li> <li>Use <code>ls /dev/ttyUSB*</code> to see available devices</li> </ul> </li> <li> <p>baud_rate (int):</p> <ul> <li>Communication speed for serial connection</li> <li>Default is 921600 baud</li> <li>Must match IMU's configured baud rate</li> </ul> </li> <li> <p>frequency (int):</p> <ul> <li>Data streaming frequency in Hz</li> <li>Default is 200 Hz</li> <li>Higher rates provide more data but increase processing load</li> </ul> </li> <li> <p>update_timeout (int):</p> <ul> <li>Timeout for data packet retrieval in milliseconds</li> <li>Default is 500ms</li> <li>Increase if data retrieval is unreliable</li> </ul> </li> <li> <p>max_packets (int):</p> <ul> <li>Maximum number of data packets to retrieve per update</li> <li>Default is 1</li> <li>Higher values can buffer more data</li> </ul> </li> <li> <p>return_packets (bool):</p> <ul> <li>If True, returns the raw data packets in the update() method</li> <li>Default is False</li> <li>Useful for advanced processing</li> </ul> </li> </ol>"},{"location":"tutorials/sensors/reading_imu_data/#available-properties","title":"Available Properties","text":"<p>The LordMicrostrainIMU provides several useful properties:</p> <ol> <li> <p>Orientation (roll, pitch, yaw):</p> <ul> <li>Current angular orientation in radians</li> <li>Returned as Euler angles   <pre><code>imu.roll    # Rotation around X-axis\nimu.pitch   # Rotation around Y-axis\nimu.yaw     # Rotation around Z-axis\n</code></pre></li> </ul> </li> <li> <p>Angular Velocity (vel_x, vel_y, vel_z):</p> <ul> <li>Angular rates in radians per second   <pre><code>imu.vel_x   # Angular velocity around X-axis\nimu.vel_y   # Angular velocity around Y-axis\nimu.vel_z   # Angular velocity around Z-axis\n</code></pre></li> </ul> </li> <li> <p>Linear Acceleration (acc_x, acc_y, acc_z):</p> <ul> <li>Linear accelerations in m/s\u00b2   <pre><code>imu.acc_x   # Acceleration along X-axis\nimu.acc_y   # Acceleration along Y-axis\nimu.acc_z   # Acceleration along Z-axis\n</code></pre></li> </ul> </li> <li> <p>Raw Data:</p> <ul> <li>Access to complete data packet   <pre><code>imu.data    # Dictionary with all available channels\n</code></pre></li> </ul> </li> </ol>"},{"location":"tutorials/sensors/reading_imu_data/#running-the-example","title":"Running the Example","text":"<ol> <li> <p>Navigate to the tutorial directory:    <pre><code>cd tutorials/sensors\n</code></pre></p> </li> <li> <p>Run the script:    <pre><code>python imu.py\n</code></pre></p> </li> <li> <p>Expected behavior:</p> <ul> <li>IMU begins reading orientation data continuously at 200Hz</li> <li>Data is logged to <code>./logs/reading_imu_data.csv</code></li> <li>Roll, pitch, and yaw values update as you rotate the IMU</li> </ul> </li> </ol>"},{"location":"tutorials/sensors/reading_imu_data/#common-issues","title":"Common Issues","text":"<ul> <li>Device Not Found: Verify connections and run <code>ls /dev/ttyUSB*</code></li> <li>Permission Denied: Add user to dialout group: <code>sudo usermod -a -G dialout $USER</code></li> <li>Incorrect Readings: Check IMU orientation and mounting</li> <li>Missing Data: Verify baud rate and connection quality</li> <li>MSCL Import Error: Install the MSCL library from Lord Microstrain</li> </ul>"},{"location":"tutorials/sensors/reading_imu_data/#additional-resources","title":"Additional Resources","text":"<ul> <li>MSCL Documentation</li> </ul> <p>If you have any questions or need further assistance, please post on the Open Source Leg community forum.</p>"},{"location":"tutorials/sensors/reading_loadcell_data/","title":"Using the Dephy Loadcell Amplifier","text":"<p>This tutorial demonstrates how to use the Dephy Loadcell Amplifier with the Open Source Leg platform to measure forces and moments. It includes examples for both standard I2C communication and custom callbacks for advanced use cases, including using the Dephy Actpack to interface with the amplifier directly instead of the Raspberry Pi's I2C bus.</p>"},{"location":"tutorials/sensors/reading_loadcell_data/#hardware-setup","title":"Hardware Setup","text":"<ol> <li>Connect the loadcell to the Dephy Loadcell Amplifier and the amplifier to the Raspberry Pi via I2C. Alternatively, raw amplifier readings can be read from the <code>genvars</code> property of the <code>DephyActuator</code> class and fed into the amplifier update method as a custom callback (see example below).</li> <li>Verify proper power supply connections.</li> <li>Ensure proper grounding.</li> <li>Mount the loadcell securely.</li> </ol> <p>This example shows how to:</p> <ul> <li>Initialize and configure a Dephy Loadcell Amplifier.</li> <li>Read forces and moments (6-axis measurements).</li> <li>Log loadcell measurements.</li> <li>Use custom callbacks for advanced data handling.</li> </ul>"},{"location":"tutorials/sensors/reading_loadcell_data/#code-structure","title":"Code Structure","text":"<p>The tutorial script for reading loadcell data has two main functions. The first shows the standard implementation where the I2C bus on a Raspberry Pi is used to communicate with the strain amplifier. The second shows an alternative use where raw ADC values are passed to the sensor in a custom data callback function. This second implementation is useful when the raw values are provided via a method other than I2C, such as reading them directly from a Dephy Actuator.</p>"},{"location":"tutorials/sensors/reading_loadcell_data/#1-initialization","title":"1. Initialization","text":"<pre><code>import numpy as np\n\nfrom opensourceleg.actuators.dephy import DephyActuator\nfrom opensourceleg.logging.logger import Logger\nfrom opensourceleg.sensors.loadcell import DephyLoadcellAmplifier, NBLoadcellDAQ\nfrom opensourceleg.utilities import SoftRealtimeLoop\n\nFREQUENCY = 200\nDT = 1 / FREQUENCY\n\nLOADCELL_CALIBRATION_MATRIX_M3564F = np.array([\n    (-38.72600, -1817.74700, 9.84900, 43.37400, -44.54000, 1824.67000),\n    (-8.61600, 1041.14900, 18.86100, -2098.82200, 31.79400, 1058.6230),\n    (\n        -1047.16800,\n        8.63900,\n        -1047.28200,\n        -20.70000,\n        -1073.08800,\n        -8.92300,\n    ),\n    (20.57600, -0.04000, -0.24600, 0.55400, -21.40800, -0.47600),\n    (-12.13400, -1.10800, 24.36100, 0.02300, -12.14100, 0.79200),\n    (-0.65100, -28.28700, 0.02200, -25.23000, 0.47300, -27.3070),\n])\n</code></pre> <p>This section:</p> <ul> <li>Sets up constants and configuration parameters</li> <li>Defines the calibration matrix</li> </ul>"},{"location":"tutorials/sensors/reading_loadcell_data/#2-standard-setup-with-i2c-communication","title":"2. Standard Setup with I2C Communication","text":"<p>This section demonstrates how to use the loadcell with standard I2C communication. It includes:</p> <ul> <li>Initializing the loadcell with I2C parameters.</li> <li>Calibrating the loadcell.</li> <li>Reading and logging force/torque data.</li> </ul> <pre><code>    (-943.401, 4.143, 8.825, -16.57, 952.216, 10.892),\n    (539.853, 14.985, -1111.656, -0.812, 546.9, -18.949),\n    (13.155, 533.082, -4.582, 534.843, 10.827, 536.327),\n    (0.138, -10.419, 0.202, 0.14, 0.063, 10.518),\n    (-0.075, 6.213, -0.239, -12.094, 0.181, 6.156),\n    (-19.912, 0.082, -20.347, 0.022, -19.486, 0.013),\n])\n\n\ndef demo_loadcell_i2c(loadcell_logger, clock):\n    loadcell = DephyLoadcellAmplifier(\n        calibration_matrix=LOADCELL_CALIBRATION_MATRIX_M3564F,\n        tag=\"loadcell\",\n        amp_gain=125,\n        exc=5,\n        bus=1,\n        i2c_address=102,\n    )\n\n    loadcell_logger.track_function(lambda: loadcell.fx, \"Fx\")\n    loadcell_logger.track_function(lambda: loadcell.fy, \"Fy\")\n    loadcell_logger.track_function(lambda: loadcell.fz, \"Fz\")\n    loadcell_logger.track_function(lambda: loadcell.mx, \"Mx\")\n    loadcell_logger.track_function(lambda: loadcell.my, \"My\")\n    loadcell_logger.track_function(lambda: loadcell.mz, \"Mz\")\n</code></pre>"},{"location":"tutorials/sensors/reading_loadcell_data/#3-custom-callback-communication","title":"3. Custom Callback Communication","text":"<p>This section demonstrates how to use a custom callback to provide raw data to the loadcell. It includes:</p> <ul> <li>Using a DephyActuator to retrieve raw amplifier readings.</li> <li>Passing the raw data to the loadcell using a callback function.</li> <li>Calibrating the loadcell with the custom callback.</li> <li>Reading and logging force/torque data.</li> </ul> <pre><code>        for t in clock:\n            loadcell.update()\n            loadcell_logger.info(\n                f\"Time: {t}; Fx: {loadcell.fx}; Fy: {loadcell.fy}; Fz: {loadcell.fz};\"\n                f\"Mx: {loadcell.mx}; My: {loadcell.my}; Mz: {loadcell.mz};\"\n            )\n            loadcell_logger.update()\n\n\ndef demo_loadcell_actpack(loadcell_logger, clock):\n    actpack = DephyActuator(\n        port=\"/dev/ttyACM1\",\n        gear_ratio=9,\n        frequency=FREQUENCY,\n        debug_level=0,\n        dephy_log=False,\n    )\n\n    loadcell = DephyLoadcellAmplifier(\n        calibration_matrix=LOADCELL_CALIBRATION_MATRIX_M3564F,\n        tag=\"loadcell\",\n        amp_gain=125,\n        exc=5,\n    )\n    loadcell_logger.track_function(lambda: loadcell.fx, \"Fx\")\n    loadcell_logger.track_function(lambda: loadcell.fy, \"Fy\")\n    loadcell_logger.track_function(lambda: loadcell.fz, \"Fz\")\n    loadcell_logger.track_function(lambda: loadcell.mx, \"Mx\")\n    loadcell_logger.track_function(lambda: loadcell.my, \"My\")\n    loadcell_logger.track_function(lambda: loadcell.mz, \"Mz\")\n\n    def get_raw_loadcell_actpack():\n        actpack.update()\n        return actpack.genvars\n</code></pre>"},{"location":"tutorials/sensors/reading_loadcell_data/#important-class-parameters","title":"Important Class Parameters","text":"<p>When initializing the <code>DephyLoadcellAmplifier</code>, several important parameters can be configured:</p> <pre><code>    (539.853, 14.985, -1111.656, -0.812, 546.9, -18.949),\n    (13.155, 533.082, -4.582, 534.843, 10.827, 536.327),\n    (0.138, -10.419, 0.202, 0.14, 0.063, 10.518),\n    (-0.075, 6.213, -0.239, -12.094, 0.181, 6.156),\n    (-19.912, 0.082, -20.347, 0.022, -19.486, 0.013),\n])\n</code></pre>"},{"location":"tutorials/sensors/reading_loadcell_data/#parameter-details","title":"Parameter Details","text":"<ol> <li> <p>calibration_matrix (np.array):</p> <ul> <li>6x6 matrix that converts raw sensor values to physical units</li> <li>Specific to each loadcell and must be provided for accurate measurements</li> <li>Obtained from manufacturer after calibration procedure</li> </ul> </li> <li> <p>tag (str):</p> <ul> <li>Unique identifier for the loadcell instance</li> <li>Useful when using multiple sensors</li> </ul> </li> <li> <p>amp_gain (float):</p> <ul> <li>Amplifier gain setting</li> <li>Typically 125 for the Dephy amplifier</li> <li>Affects sensitivity and measurement range</li> </ul> </li> <li> <p>exc (float):</p> <ul> <li>Excitation voltage in volts</li> <li>Typically 5V for the Dephy amplifier</li> <li>Must match the hardware configuration</li> </ul> </li> <li> <p>bus (int):</p> <ul> <li>I2C bus number</li> <li>Typically 1 on Raspberry Pi</li> <li>Use <code>i2cdetect -y 1</code> to verify</li> </ul> </li> <li> <p>i2c_address (int):</p> <ul> <li>Device address on the I2C bus</li> <li>Default is 102 (0x66 in hexadecimal)</li> <li>Can be configured on some amplifiers</li> </ul> </li> </ol>"},{"location":"tutorials/sensors/reading_loadcell_data/#available-properties","title":"Available Properties","text":"<p>The <code>DephyLoadcellAmplifier</code> provides six measurement properties:</p> <ol> <li> <p>Forces (fx, fy, fz):</p> <ul> <li>Linear forces in Newtons (N)</li> <li>Three orthogonal directions   <pre><code>loadcell.fx  # Force in X direction\nloadcell.fy  # Force in Y direction\nloadcell.fz  # Force in Z direction\n</code></pre></li> </ul> </li> <li> <p>Moments (mx, my, mz):</p> <ul> <li>Torques/moments in Newton-meters (Nm)</li> <li>Rotation around three orthogonal axes   <pre><code>loadcell.mx  # Moment around X axis\nloadcell.my  # Moment around Y axis\nloadcell.mz  # Moment around Z axis\n</code></pre></li> </ul> </li> </ol>"},{"location":"tutorials/sensors/reading_loadcell_data/#running-the-example","title":"Running the Example","text":"<ol> <li> <p>Navigate to the tutorial directory:    <pre><code>cd tutorials/sensors\n</code></pre></p> </li> <li> <p>Run the script:    <pre><code>python reading_loadcell_data.py\n</code></pre></p> </li> <li> <p>Expected behavior:</p> <ul> <li>Loadcell begins reading force/torque data continuously at 200Hz</li> <li>Data is logged to <code>./logs/reading_loadcell_data.csv</code></li> <li>Force and moment values update as you apply loads to the sensor</li> </ul> </li> <li> <p>To change between I2C and using custom data callbacks, swap the <code>if __name__ == \"__main__\"</code> between the two demo function calls:</p> </li> </ol> <pre><code>def demo_loadcell_nb_daq(loadcell_logger, clock):\n</code></pre>"},{"location":"tutorials/sensors/reading_loadcell_data/#common-issues","title":"Common Issues","text":"<ul> <li>I2C Communication Errors: Verify connections with <code>i2cdetect -y 1</code></li> <li>Permission Denied: Add user to i2c group: <code>sudo usermod -a -G i2c $USER</code></li> <li>Incorrect Readings: Check calibration matrix and amplifier settings</li> <li>Noise in Measurements: Verify grounding and power supply stability</li> <li>Drift in Readings: The loadcell might have to be re-calibrated by the manufacturer</li> </ul>"},{"location":"tutorials/sensors/reading_loadcell_data/#calibration","title":"Calibration","text":"<p>The calibration matrix is crucial for accurate measurements. The provided matrix:</p> <p><pre><code>LOADCELL_CALIBRATION_MATRIX = np.array([\n    (-38.72600, -1817.74700, 9.84900, 43.37400, -44.54000, 1824.67000),\n    # ... additional rows ...\n])\n</code></pre> should be replaced with your specific loadcell's calibration values.</p> <p>If you have any questions or need further assistance, please post on the Open Source Leg community forum.</p>"},{"location":"tutorials/utilities/profiler/profiling_code/","title":"Profiling Code with the Profiler Class","text":"<p>The <code>Profiler</code> class in the utilities module is a powerful tool for measuring the execution time of code. It is particularly useful for identifying performance bottlenecks and optimizing real-time applications.</p> <p>This tutorial walks you through the key features of the <code>Profiler</code> class and explains the examples provided in the <code>profiling_code.py</code> example script.</p>"},{"location":"tutorials/utilities/profiler/profiling_code/#key-features-of-the-profiler","title":"Key Features of the Profiler","text":"<p>The <code>Profiler</code> class supports four main usage patterns:</p> <ol> <li>Tic-Toc Timing: Measure the duration of specific code blocks that are wrapped in <code>Tic()</code> and <code>Toc()</code> commands.</li> <li>Expression Profiling: Profile the execution time of an expression by passing it to the profiler wrapped in a lambda function.</li> <li>Decorator: Automatically profile a function by decorating it.</li> <li>Context Manager: Use the profiler as a context manager to measure the execution time of a block of code.</li> </ol>"},{"location":"tutorials/utilities/profiler/profiling_code/#example-1-tic-toc-timing","title":"Example 1: Tic-Toc Timing","text":"<p>The <code>tic</code> and <code>toc</code> methods allow you to measure the duration of specific code blocks.</p> <pre><code>def example_tic_toc():\n    \"\"\"\n    Example demonstrating the use of tic and toc for profiling.\n    \"\"\"\n    profiler = Profiler(\"tic_toc_example\")\n    profiler.tic()\n    time.sleep(0.1)  # Simulate some work\n    duration = profiler.toc()\n    print(f\"Duration of operation: {duration:.3f} seconds\")\n</code></pre>"},{"location":"tutorials/utilities/profiler/profiling_code/#explanation","title":"Explanation","text":"<ul> <li><code>tic()</code>: Starts the timer.</li> <li><code>toc()</code>: Stops the timer and returns the elapsed time.</li> <li>This pattern is useful for profiling specific sections of code.</li> </ul>"},{"location":"tutorials/utilities/profiler/profiling_code/#example-2-profiling-an-expression-with-a-lambda","title":"Example 2: Profiling an Expression with a Lambda","text":"<p>The <code>profile</code> method allows you to measure the execution time of an expression or a small block of code by passing it as a lambda function.</p> <pre><code>def example_lambda():\n    \"\"\"\n    Example demonstrating the use of the Profiler with a lambda function.\n    \"\"\"\n    profiler = Profiler(\"lambda_example\")\n    for _ in range(5):\n        profiler.profile(lambda: time.sleep(0.05))  # Simulate some work\n\n    print(f\"Total runs: {profiler.N}, Total time: {profiler.agg:.3f} seconds\")\n</code></pre>"},{"location":"tutorials/utilities/profiler/profiling_code/#explanation_1","title":"Explanation","text":"<ul> <li><code>profile(func)</code>: Measures the execution time of the provided function or expression.</li> <li><code>N</code>: The number of times the profiler has been used.</li> <li><code>agg</code>: The total time spent in all profiled expressions.</li> </ul> <p>This pattern is particularly useful for profiling small, self-contained expressions or blocks of code without needing to define a separate function. For example, you can use it to measure the time taken by a single line of code or a quick computation.</p>"},{"location":"tutorials/utilities/profiler/profiling_code/#example-3-using-the-profiler-as-a-decorator","title":"Example 3: Using the Profiler as a Decorator","text":"<p>The <code>decorate</code> method allows you to profile a function by simply adding a decorator.</p> <pre><code>def example_decorator():\n    \"\"\"\n    Example demonstrating the use of the Profiler as a decorator.\n    \"\"\"\n    profiler = Profiler(\"decorator_example\")\n\n    @profiler.decorate\n    def simulated_work():\n        time.sleep(0.05)  # Simulate some work\n\n    for _ in range(5):\n        simulated_work()\n\n    print(f\"Total runs: {profiler.N}, Total time: {profiler.agg:.3f} seconds\")\n</code></pre>"},{"location":"tutorials/utilities/profiler/profiling_code/#explanation_2","title":"Explanation","text":"<ul> <li><code>@profiler.decorate</code>: Automatically profiles the decorated function.</li> <li>This pattern is useful for profiling functions without modifying their code.</li> </ul>"},{"location":"tutorials/utilities/profiler/profiling_code/#example-4-using-the-profiler-as-a-context-manager","title":"Example 4: Using the Profiler as a Context Manager","text":"<p>The <code>Profiler</code> class can also be used as a context manager to measure the execution time of a block of code.</p> <pre><code>def example_context():\n    \"\"\"\n    Example demonstrating the use of the Profiler with a context manager.\n    \"\"\"\n    profiler = Profiler(\"context_example\")\n    with profiler:\n        time.sleep(0.1)  # Simulate some work\n    with profiler:\n        time.sleep(0.2)  # Simulate some more work\n\n    print(f\"Total runs: {profiler.N}, Total time: {profiler.agg:.3f} seconds\")\n    print(f\"Average time per run: {profiler.agg / profiler.N:.3f} seconds\")\n    print(f\"Variance: {profiler.aggvar:.3f}\")\n</code></pre>"},{"location":"tutorials/utilities/profiler/profiling_code/#explanation_3","title":"Explanation","text":"<ul> <li><code>with profiler</code>: Uses the profiler instance to measure the execution time of the code inside the <code>with</code> block.</li> <li><code>N</code>: The number of times the profiler has been used.</li> <li><code>agg</code>: The total time spent in all profiled blocks.</li> </ul> <p>This pattern provides an alternative to the <code>tic()</code> <code>toc()</code> usage that may produce cleaner code.</p>"},{"location":"tutorials/utilities/profiler/profiling_code/#summary","title":"Summary","text":"<p>The <code>Profiler</code> class provides flexible tools for measuring execution time in real-time applications. Whether you need to profile specific code blocks, repeated function calls, or entire functions, the <code>Profiler</code> class has you covered.</p> <p>If you have any questions or need further assistance, please post on the Open Source Leg community forum.</p>"},{"location":"tutorials/utilities/softrealtimeloop/getting_started/","title":"Soft Realtime Loop Module Tutorial","text":"<p>The <code>softrealtimeloop</code> module provides tools for creating soft real-time loops in Python, which is particularly useful for robotics and control applications. The module consists of two main classes:</p> <ul> <li><code>LoopKiller</code>: Handles graceful shutdown of loops</li> <li><code>SoftRealtimeLoop</code>: Manages timing-precise execution of functions</li> </ul>"},{"location":"tutorials/utilities/softrealtimeloop/getting_started/#core-features","title":"Core Features","text":"<ul> <li>Precise timing control with configurable time steps</li> <li>Graceful shutdown handling (including CTRL+C)</li> <li>Fade-out capability for smooth transitions</li> <li>Performance statistics reporting</li> <li>Iterator-based interface</li> </ul>"},{"location":"tutorials/utilities/softrealtimeloop/getting_started/#basic-usage","title":"Basic Usage","text":"<p>The simplest way to use the SoftRealtimeLoop is to create a loop with a specific time step and run a function. See the Running Functions tutorial for more details.</p> <pre><code>from opensourceleg.utilities import SoftRealtimeLoop\n\nrt_loop = SoftRealtimeLoop(dt=0.001)  # 1ms time step\nrt_loop.run(your_function)\n</code></pre>"},{"location":"tutorials/utilities/softrealtimeloop/getting_started/#iterator-interface","title":"Iterator Interface","text":"<p>The module provides an iterator interface for more flexible control. See the Using Iterators tutorial for more details.</p> <pre><code>rt_loop = SoftRealtimeLoop(dt=0.1)  # 10Hz loop\nfor t in rt_loop:\n    print(f\"Time: {t:.1f}s\")\n</code></pre>"},{"location":"tutorials/utilities/softrealtimeloop/getting_started/#advanced-features","title":"Advanced Features","text":"<p>The module supports advanced features like:</p> <ul> <li>Fade-out capabilities</li> <li>Performance monitoring</li> </ul> <p>Check out the Real-time Control tutorial for more details.</p>"},{"location":"tutorials/utilities/softrealtimeloop/getting_started/#key-parameters","title":"Key Parameters","text":"<p>When creating a <code>SoftRealtimeLoop</code>, you can specify:</p> <ul> <li><code>dt</code>: Time step in seconds (default: 0.001)</li> <li><code>report</code>: Enable/disable performance reporting (default: True)</li> <li><code>fade</code>: Fade-out duration in seconds (default: 0.0)</li> <li><code>maintain_original_phase</code>: Flag to try to maintain the original loop schedule created at startup (default: False)</li> </ul>"},{"location":"tutorials/utilities/softrealtimeloop/getting_started/#interrupt-handling","title":"Interrupt Handling","text":"<p>The loop provides built-in handling for:</p> <ul> <li><code>SIGTERM</code> signals</li> <li><code>SIGINT</code> signals (Ctrl+C)</li> <li><code>SIGHUP</code> signals (where available)</li> </ul>"},{"location":"tutorials/utilities/softrealtimeloop/getting_started/#performance-monitoring","title":"Performance Monitoring","text":"<p>When reporting is enabled, the loop provides statistics on:</p> <ul> <li>Average timing error</li> <li>Standard deviation of timing error</li> <li>Percentage of time spent sleeping</li> </ul>"},{"location":"tutorials/utilities/softrealtimeloop/getting_started/#note-on-maintaining-original-phase","title":"Note on Maintaining Original Phase","text":"<p>The <code>SoftRealtimeLoop</code> can operate in two modes, controlled by the <code>maintain_original_phase</code> parameter:</p> <ol> <li>Consistent Time Step (<code>maintain_original_phase=False</code> (default)):<ul> <li>In this mode, the loop focuses on maintaining a consistent time step between iterations, regardless of any delays or errors in previous iterations.</li> <li>This mode can be helpful in real-time control where you don't want previous loop errors to impact the current execution rate.</li> <li>Example:   <pre><code>rt_loop = SoftRealtimeLoop(dt=0.01, maintain_original_phase=False)\nfor t in rt_loop:\n    print(f\"Time: {t:.3f}s\")\n</code></pre></li> </ul> </li> <li>Maintain Original Phase (<code>maintain_original_phase=True</code>):<ul> <li>In this mode, the loop attempts to ensure that the time elapsed since the start of the loop aligns with the expected schedule <code>(loop_number * dt)</code>.</li> <li>This is useful for applications where precise timing relative to the start of the loop is critical, such as synchronized control systems where the total time is important to maintain.</li> <li>If the loop falls behind schedule, it will attempt to catch up by reducing sleep time in subsequent iterations.</li> <li>Example:   <pre><code>rt_loop = SoftRealtimeLoop(dt=0.01, maintain_original_phase=True)\nfor t in rt_loop:\n    print(f\"Time: {t:.3f}s\")\n</code></pre></li> </ul> </li> </ol>"},{"location":"tutorials/utilities/softrealtimeloop/getting_started/#key-differences","title":"Key Differences:","text":"<ul> <li>Original Phase Mode: Prioritizes alignment with the overall schedule, even if it means adjusting the timing of individual iterations.</li> <li>Consistent Time Step Mode: Prioritizes uniform spacing between iterations, even if it deviates from the overall schedule.</li> </ul> <p>Choose the mode that best suits your application's requirements. Most often, we use the default mode for OSL controllers.</p>"},{"location":"tutorials/utilities/softrealtimeloop/getting_started/#next-steps","title":"Next Steps","text":"<ol> <li>Start with the Running Functions to learn fundamental concepts</li> <li>Explore the Using Iterators for more flexible control</li> <li>Check out the Real-time Control for complex examples</li> </ol>"},{"location":"tutorials/utilities/softrealtimeloop/realtime_control/","title":"Advanced Usage Tutorial","text":"<p>This tutorial covers advanced features of SoftRealtimeLoop</p>"},{"location":"tutorials/utilities/softrealtimeloop/realtime_control/#sensor-data-acquisition","title":"Sensor Data Acquisition","text":"<p>Example of reading from a simulated sensor at precise intervals:</p> <pre><code>class SimpleSensorSimulator:\n    def __init__(self):\n        self.start_time = time.monotonic()\n\n    def read(self, t):\n        # Simulate a 0.5 Hz sine wave sensor reading\n        return 100 * sin(2 * pi * 0.5 * t)\n\n\ndef sensor_example():\n    # Create a 20Hz loop (0.05 second period)\n    rt_loop = SoftRealtimeLoop(dt=0.05)\n\n    # Initialize sensor and data storage\n    sensor = SimpleSensorSimulator()\n    readings = []\n\n    print(\"Recording simulated sensor data for 2 seconds...\")\n\n    for t in rt_loop:\n        reading = sensor.read(t)\n        readings.append(reading)\n        print(f\"Time: {t:.2f}s, Sensor value: {reading:.1f}\")\n\n        if t &gt; 2.0:  # Stop after 2 seconds\n            rt_loop.stop()\n\n    print(f\"\\nCollected {len(readings)} samples at 20Hz\")\n    print(f\"Average sampling period: {2.0 / len(readings):.3f} seconds\")\n</code></pre>"},{"location":"tutorials/utilities/softrealtimeloop/realtime_control/#graceful-shutdown-with-fade-out","title":"Graceful Shutdown with Fade-out","text":"<p>Demonstration of the fade-out feature for a smooth shutdown:</p> <pre><code>def fade_example():\n    # Create a 10Hz loop with 1-second fade-out\n    rt_loop = SoftRealtimeLoop(dt=0.1, fade=1.0)\n\n    print(\"Running loop with fade-out...\")\n    print(\"Press Ctrl+C to test graceful shutdown!\")\n\n    try:\n        for t in rt_loop:\n            fade_value = rt_loop.fade\n            print(f\"Time: {t:.1f}s, Fade value: {fade_value:.2f}\")\n\n            if t &gt; 10.0:  # Auto-stop after 10 seconds if no Ctrl+C\n                rt_loop.stop()\n\n    except KeyboardInterrupt:\n        print(\"\\nCtrl+C detected - demonstrating fade-out...\")\n        # The loop will automatically handle the fade-out\n\n    print(\"\\nLoop completed with graceful shutdown!\")\n</code></pre>"},{"location":"tutorials/utilities/softrealtimeloop/realtime_control/#understanding-performance-statistics","title":"Understanding Performance Statistics","text":"<p>When a SoftRealtimeLoop completes (either through normal termination or interruption), it prints detailed timing statistics if reporting is enabled (default). Let's understand what these metrics mean and how to use them:</p>"},{"location":"tutorials/utilities/softrealtimeloop/realtime_control/#available-statistics","title":"Available Statistics","text":"<p>The loop reports three key metrics:</p> <pre><code># Example output:\nIn 1000 cycles at 100.00 Hz:\n    avg error: 0.123 milliseconds\n    stddev error: 0.045 milliseconds\n    percent of time sleeping: 85.2 %\n</code></pre> <ol> <li> <p>Average Error: Shows how far off your timing is from the target on average</p> <ul> <li>Values under 1ms are typically good for most applications</li> <li>Higher values indicate your loop might be overloaded</li> </ul> </li> <li> <p>Standard Deviation Error: Shows how consistent your timing is</p> <ul> <li>Lower values mean more consistent timing</li> <li>High variance might indicate interference from other processes</li> </ul> </li> <li> <p>Percent Time Sleeping: Shows how much CPU headroom you have</p> <ul> <li>Higher values (&gt;50%) indicate your loop has plenty of processing time</li> <li>Low values suggest your loop might be struggling to keep up</li> </ul> </li> </ol>"},{"location":"tutorials/utilities/softrealtimeloop/realtime_control/#improving-performance","title":"Improving Performance","text":"<p>If your statistics show timing issues, here are some general ways to improve your real-time performance:</p> <ul> <li>Reduce other system load</li> <li>Increase process priority</li> <li>Move computationally intensive operations outside the loop</li> </ul>"},{"location":"tutorials/utilities/softrealtimeloop/realtime_control/#monitoring-performance","title":"Monitoring Performance","text":"<p>You can access timing statistics programmatically:</p> <pre><code>rt_loop = SoftRealtimeLoop(dt=0.001)\n# ... run your loop ...\navg_error = rt_loop.sum_err / rt_loop.n if rt_loop.n &gt; 0 else 0\nsleep_percentage = (rt_loop.sleep_t_agg / rt_loop.time_since_start) * 100 if rt_loop.time_since_start &gt; 0 else 0\n</code></pre> <p>By monitoring these statistics, you can ensure your real-time applications maintain precise timing and reliable performance. The statistics help identify when your loop needs tuning or when system resources are becoming constrained.</p>"},{"location":"tutorials/utilities/softrealtimeloop/realtime_control/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Choose Appropriate Time Steps:</p> <ul> <li>Faster loops (smaller dt) require more CPU resources</li> <li>Balance between control requirements and system capabilities</li> </ul> </li> <li> <p>Monitor Resource Usage:</p> <ul> <li>Watch for sleep percentages below 20%</li> <li>Consider operating at a lower frequency if the system is struggling</li> </ul> </li> <li> <p>Use Fade-out for Clean Graceful Shutdown:</p> <pre><code>rt_loop = SoftRealtimeLoop(dt=0.01, fade=1.0)  # 1-second fade-out\n</code></pre> </li> <li> <p>Reset for Multiple Uses:</p> <pre><code>rt_loop.reset()  # Clears statistics for new measurements\n</code></pre> </li> </ol> <p>If you have any questions or need further assistance, please post on the Open Source Leg community forum.</p>"},{"location":"tutorials/utilities/softrealtimeloop/running_functions/","title":"Basic Usage Tutorial","text":"<p>This tutorial explains the fundamental usage of the SoftRealtimeLoop class.</p>"},{"location":"tutorials/utilities/softrealtimeloop/running_functions/#simple-one-shot-function","title":"Simple One-Shot Function","text":"<p>The most basic usage is running a function once in the loop. The function returns 0 to stop the loop:</p> <pre><code>def main():\n    # Create loop with 1ms timestep\n    rt_loop = SoftRealtimeLoop(dt=0.001)\n\n    # Example 1: Simple function that runs once\n    def basic_function() -&gt; int:\n        print(\"Basic loop iteration\")\n        return 0  # Stop after one iteration\n\n    print(\"Running basic function...\")\n</code></pre>"},{"location":"tutorials/utilities/softrealtimeloop/running_functions/#timed-execution","title":"Timed Execution","text":"<p>You can run a function for a specific duration by tracking elapsed time:</p> <pre><code>    print(\"\\nRunning timed function for 3 seconds...\")\n    start_time = time.monotonic()\n\n    def timed_function() -&gt; Union[int, None]:\n        elapsed = time.monotonic() - start_time\n        print(f\"Time elapsed: {elapsed:.2f} seconds\")\n        if elapsed &gt; 3:\n            return 0  # Stop after 3 seconds\n        return None\n</code></pre>"},{"location":"tutorials/utilities/softrealtimeloop/running_functions/#key-concepts","title":"Key Concepts","text":"<ol> <li>The <code>run()</code> method is blocking and continues until the function returns or a signal interrupts the loop.</li> <li>The time step (<code>dt</code>) determines the loop frequency</li> <li>The loop maintains precise timing automatically</li> </ol> <p>If you have any questions or need further assistance, please post on the Open Source Leg community forum.</p>"},{"location":"tutorials/utilities/softrealtimeloop/using_iterators/","title":"Iterator Usage Tutorial","text":"<p>This tutorial demonstrates how to use SoftRealtimeLoop as an iterator.</p>"},{"location":"tutorials/utilities/softrealtimeloop/using_iterators/#basic-iterator-pattern","title":"Basic Iterator Pattern","text":"<p>The iterator interface provides a more Pythonic way to work with the loop:</p> <pre><code>    # Create a 10Hz loop (0.1 second period)\n    rt_loop = SoftRealtimeLoop(dt=0.1)\n\n    print(\"Counting up every 0.1 seconds...\")\n\n    # Using the loop as an iterator\n    for t in rt_loop:\n        print(f\"Time: {t:.3f} seconds\")\n</code></pre>"},{"location":"tutorials/utilities/softrealtimeloop/using_iterators/#key-concepts","title":"Key Concepts","text":"<ol> <li>The <code>t</code> value represents the time since the loop started (in seconds)</li> <li>Each iteration occurs at precise time intervals</li> <li>The loop can be stopped by breaking the for loop, calling <code>rt_loop.stop()</code>, or sending an interrupt signal (Ctrl+C)</li> </ol> <p>If you have any questions or need further assistance, please post on the Open Source Leg community forum.</p>"}]}